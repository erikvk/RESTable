var store = [{"title":"Home","text":"Welcome to the Mopedo documentation site! Here is where we keep all documentation for the Mopedo DSP, along with supporting technologies like RESTar and Dynamit. Mopedo docs • Mopedo DSP A decentralized DSP were you're in control. • Contact information You can also use the issue tracker to report an issue. Supporting technologies • RESTar A REST API Framework for Starcounter. • RESTar.SQLite An open-source SQLite resource provider for RESTar. • RESTar.OData An open-source OData 4.0 protocol provider for RESTar. • RESTar.Tutorial Learn the basics of RESTar with a hands-on tutorial. • Dynamit An open-source .NET library for creating dynamic table definitions in Starcounter. • StarConfig An open-source .NET library for creating and accessing dynamic XML and JSON application configurations with zero setup.","excerpt":"Welcome to the Mopedo documentation site! Here is where we keep all documentation for the Mopedo DSP, along with supporting technologies like RESTar and Dynamit. Mopedo docs • Mopedo DSP A decentralized DSP were you're in control. • Contact informati","tags":"","url":"/"},{"title":"Home","text":"Related technologies • RESTar.SQLite An open-source SQLite resource provider for RESTar. • RESTar.OData An open-source OData 4.0 protocol provider for RESTar.","excerpt":"Related technologies • RESTar.SQLite An open-source SQLite resource provider for RESTar. • RESTar.OData An open-source OData 4.0 protocol provider for RESTar.","tags":"","url":"/"},{"title":"Contact information","text":"Carl-Johan Runer (CEO) calle.runer@mopedo.com Erik von Krusenstierna (CTO) erik.von.krusenstierna@mopedo.com Sebastian de Rzewuski (Developer) sebastian.de.rzewuski@mopedo.com Address Hovslagargatan 3, 111 48 Stockholm, Sweden","excerpt":"Carl-Johan Runer (CEO) calle.runer@mopedo.com Erik von Krusenstierna (CTO) erik.von.krusenstierna@mopedo.com Sebastian de Rzewuski (Developer) sebastian.de.rzewuski@mopedo.com Address Hovslagargatan 3, 111 48 Stockholm, Sweden","tags":"","url":"/Contact%20information"},{"title":"Mopedo DSP","text":"Mopedo DSP This section of the documentation gives a technical description of the Mopedo DSP, a software product developed by Mopedo to provide easy demand side access to the Mopedo platform. Using the DSP, an advertiser can perform common DSP tasks such as segmenting audiences, setting up campaigns, responding to bid requests and tracking campaign spending over time. Data uploads and downloads are done by means of the REST API). The Mopedo DSP is a Windows application running on the Starcounter in-memory database system. It's connected to the Mopedo backend, from which it continuously receives bid requests and data, and to which it responds with bids. When up and running, it will have registered several REST resources that are available through the REST API. The application is administrated solely by reading from and writing to these resources using HTTP requests and JSON and/or Excel data, which enables easy integration with other systems and services that speak HTTP and JSON. For all examples in these articles we consider a DSP application running at https://my-dsp.com, the REST API listening on port 8282 and root URI /rest, and an all-access API key mykey. All this can of course be configured when setting up an actual Mopedo DSP. While reading this documentation, it may also be useful to reference the OpenRTB specification. Use the navigation menu to the left to explore the documentation. Contact For any questions about this documentation, or the Mopedo DSP in general, please contact develop@mopedo.com.","excerpt":"Mopedo DSP This section of the documentation gives a technical description of the Mopedo DSP, a software product developed by Mopedo to provide easy demand side access to the Mopedo platform. Using the DSP, an advertiser can perform common DSP tasks ","tags":"","url":"/Mopedo%20DSP"},{"title":"RESTar","text":"What is RESTar? RESTar is a .NET REST API framework for Starcounter applications, that is free to use and easy to set up in new or existing applications. Its purpose is to provide a set of high-quality tools for developers to build great REST APIs, without having to deal with the complexities (and sometimes utter boringness) associated with client authentication, request processing, data integrations, performance optimizations, URI conventions and documentation. If the term \"REST API\" is unfamiliar to you, we recommend that you read this excellent tutorial, that covers all you need to know. Using RESTar tools, developers can quickly build powerful REST APIs that, among other things: Terminology A RESTar application is any Starcounter application that uses the tools of RESTar to establish a REST API. We will refer to the REST API as simply the web services provided by a RESTar application. RESTar web service and RESTar API are also used interchangeably in these articles to refer to the web services of a RESTar application. A web resource, or just resource, is – in common terminology – anything that can be named, addressed or interacted with using, for example, a REST API.","excerpt":"What is RESTar? RESTar is a .NET REST API framework for Starcounter applications, that is free to use and easy to set up in new or existing applications. Its purpose is to provide a set of high-quality tools for developers to build great REST APIs, w","tags":"","url":"/RESTar"},{"title":"_site","text":"Welcome to the Mopedo documentation site! Here is where we keep all documentation for the Mopedo DSP, along with supporting technologies like RESTar and Dynamit. Mopedo docs • Mopedo DSP A decentralized DSP were you're in control. • Contact information You can also use the issue tracker to report an issue. Supporting technologies • RESTar A REST API Framework for Starcounter. • RESTar.SQLite An open-source SQLite resource provider for RESTar. • RESTar.OData An open-source OData 4.0 protocol provider for RESTar. • RESTar.Tutorial Learn the basics of RESTar with a hands-on tutorial. • Dynamit An open-source .NET library for creating dynamic table definitions in Starcounter. • StarConfig An open-source .NET library for creating and accessing dynamic XML and JSON application configurations with zero setup.","excerpt":"Welcome to the Mopedo documentation site! Here is where we keep all documentation for the Mopedo DSP, along with supporting technologies like RESTar and Dynamit. Mopedo docs • Mopedo DSP A decentralized DSP were you're in control. • Contact informati","tags":"","url":"/_site"},{"title":"What's new","text":"What's new nothing right now","excerpt":"What's new nothing right now","tags":"","url":"/RESTar/What's%20new"},{"title":"Resource kinds","text":"RESTar resource kinds When using a RESTar API, for example our demo service, you may notice that there is are multiple kinds of resources that are available to you. Let's make a request to the demo API and list some available resources for the API key restar. For the sake of brevity, let's include only the Name and Kind properties: Response body (abbreviated): As we can see, there are four different values for the Kind properties of the listed resources. Let's go through them in order. Entity resources Entity resources are the kind of web resource we should all be familiar with. They are modelled as sets of entities that can be represented using various content types – for example JSON, and that can be manipulated using common REST methods like POST, PATCH and DELETE. The semantics of entity resource interaction is, to a great extent, defined by the HTTP protocol. Entity resources are the most common resources in RESTar, and a large part of the documentation is specific to working with them. See also: Binary resources Binary resources contain read-only binary data of arbitrary size with a specific pre-defined content type. Just like with entity resources, we use HTTP to interact with binary resources. We can, however, only use the GET method. Unlike entity resources, the Accept request header is ignored when requesting a binary resource – we cannot request the content of a binary resource in any content type other than its native type. Binary resources are useful when we have read-only document data – for example an XML document or a text file – that should be exposed over the REST API. A good example is the RESTar.OData metadata document, which contains XML metadata for all resources in a RESTar application. See also: Terminal resources Terminal resources are small, single-purpose console applications that are hosted by a RESTar application, and that can be launched, controlled and terminated by API consumers. Once launched, they establish a two-way communication socket with the client, over which commands and data can be exchanged. While entity resources and binary resources are closely coupled with the HTTP protocol, which is what we use to interact with them, terminal resources have a similar coupling with another TCP protocol – the WebSocket protocol.​ Terminal resources are useful when we want to provide high reactivity and interactivity between the server and the client – for example to build a real-time log resource that pushes data to multiple clients, or a command line interpreter. They exist to enable effective data interaction between client and server, whereas entity resources and binary resources are commonly used as sources of said data. See also: Event resources Event resources define transient event objects that are raised (triggered) from within the RESTar application itself, and that can be listened for and used as triggers for various actions. To understand why event resources exist, imagine that we want to build an entity resource holding notifications, with entities inserted from within the RESTar application itself, as well as from other computers that send POST requests to our API. It stands to reason that clients would want to be notified once entities are added to the resource, but without event resources the best we can do is to tell the client to make frequent GET requests to check for new entities. We could also implement this using a terminal resource, but that would require the client to have an open websocket to the API in order to receive notifications. None of these solutions are favorable. With entity resources, we can let the application raise a notification event once a notification is created, carrying the notification entity as payload, that can then trigger actions – for example a webhook that sends the notification to a remote server. Unlike the other resource kinds, we do not consume event resources by sending requests for them. Instead we listen for them, and interact with their data once they're raised. See also: Each event carries a payload, the data that is associated with the event. The RESTar application developer defines what the payload is for a given event resource a description of the payload should be included in the resource documentation, so that consumers and administrators know what to expect when working with the event resource.","excerpt":"RESTar resource kinds When using a RESTar API, for example our demo service, you may notice that there is are multiple kinds of resources that are available to you. Let's make a request to the demo API and list some available resources for the API ke","tags":"","url":"/RESTar/Resource%20kinds"},{"title":"Contact information","text":"Carl-Johan Runer (CEO) calle.runer@mopedo.com Erik von Krusenstierna (CTO) erik.von.krusenstierna@mopedo.com Sebastian de Rzewuski (Developer) sebastian.de.rzewuski@mopedo.com Address Hovslagargatan 3, 111 48 Stockholm, Sweden","excerpt":"Carl-Johan Runer (CEO) calle.runer@mopedo.com Erik von Krusenstierna (CTO) erik.von.krusenstierna@mopedo.com Sebastian de Rzewuski (Developer) sebastian.de.rzewuski@mopedo.com Address Hovslagargatan 3, 111 48 Stockholm, Sweden","tags":"","url":"/_site/Contact%20information"},{"title":"Mopedo DSP","text":"Mopedo DSP This section of the documentation gives a technical description of the Mopedo DSP, a software product developed by Mopedo to provide easy demand side access to the Mopedo platform. Using the DSP, an advertiser can perform common DSP tasks such as segmenting audiences, setting up campaigns, responding to bid requests and tracking campaign spending over time. Data uploads and downloads are done by means of the REST API). The Mopedo DSP is a Windows application running on the Starcounter in-memory database system. It's connected to the Mopedo backend, from which it continuously receives bid requests and data, and to which it responds with bids. When up and running, it will have registered several REST resources that are available through the REST API. The application is administrated solely by reading from and writing to these resources using HTTP requests and JSON and/or Excel data, which enables easy integration with other systems and services that speak HTTP and JSON. For all examples in these articles we consider a DSP application running at https://my-dsp.com, the REST API listening on port 8282 and root URI /rest, and an all-access API key mykey. All this can of course be configured when setting up an actual Mopedo DSP. While reading this documentation, it may also be useful to reference the OpenRTB specification. Use the navigation menu to the left to explore the documentation. Contact For any questions about this documentation, or the Mopedo DSP in general, please contact develop@mopedo.com.","excerpt":"Mopedo DSP This section of the documentation gives a technical description of the Mopedo DSP, a software product developed by Mopedo to provide easy demand side access to the Mopedo platform. Using the DSP, an advertiser can perform common DSP tasks ","tags":"","url":"/_site/Mopedo%20DSP"},{"title":"Configuration guide","text":"Configuration guide During the installation steps, an XML configuration file will be created for the Mopedo DSP, from which the DSP reads settings during startup. In the configuration file, we can set the following properties: Property name | Description\n----------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\nSeatId | The unique ID you have been given by Mopedo\nPassword | The password you have been given by Mopedo\nEmail | The email address of your DSP administrator\nBroadcaster | ID(s) or URI(s) for the Mopedo broadcasting server(s)\nHttpPort | The port on which to listen for incoming HTTP traffic (default 8004)\nUdpPort | The port on which to listen for incoming UDP traffic (default 9004)\nBidRequestFilter | The current bid request filter\nRESTPort | The port on which the REST API listens for incoming requests\nRESTUri | The base URI for the REST API, default is /rest\nRequireApiKey | Should the REST API require API keys in requests? Default is true\nAllowAllOrigins | Should all CORS origins be allowed? Default is false\nApiKey | Registers an API key for the REST API\nAllowedOrigin | Allowed CORS origins for the REST API\nRoutineUpdateIntervalMinutes | The minutes between routine runs (default is 360)\nSpendingSnapshotStoragePeriod | The setting for spending snapshot trimming, can be \"Short\", \"Medium\" (default), \"Long\" or \"NoTrimming\".\nDefaultCurrency | An optional ISO 4217 currency code for the default currency to use, for example SEK or USD. If omitted, USD is used.\nDomainName | An optional domain name to use in calls to this DSP from the Mopedo backend, instead of the public IP. For example my-dsp.com Example","excerpt":"Configuration guide During the installation steps, an XML configuration file will be created for the Mopedo DSP, from which the DSP reads settings during startup. In the configuration file, we can set the following properties: Property name | Descrip","tags":"","url":"/Mopedo%20DSP/Administration%20guides/Configuration%20guide"},{"title":"Getting started","text":"Getting started The integration process consists of the following steps: 1. Business agreement The first step is to sign a business contract with Mopedo, which will give you an account and password for accessing the Mopedo platform. The account and password will ensure that only you can bid using your assigned seat id. For more information about the business agreement, please contact info@mopedo.com. When you have your account credentials, you are ready to setup your DSP instance. 2. Choosing a server for the DSP For bidding to work fast and reliably, it's important that the DSP is located geographically close to the server that broadcasts the bid requests. Usually, the DSP has 100 milliseconds or less to receive the bid request, evaluate it and return a bid response. If the network latency is too high, the DSP will not be able to respond in time, and will therefore not win any auctions. How close is close enough, however, depends on how the DSP is to be used. If you have a server and want to test latency, it's easy to run a latency test and see if the results are adequate for your use case. The optimal solution, however, is to place the DSP on a Google Cloud VM instance in Google's western Europe datacenter (Belgium). That is where the Mopedo backend is located, so DSPs running on the same datacenter have optimal network latency. Mopedo provides a guide for how to set up a Google Cloud VM instance. We have also had DSPs set up at Amazon AWS in Frankfurt, which works fine. Technical spec. | Minimum requirement\n---------------- | ---------------------------\nOperating system | Windows Server 2012 or 2016\nCores | 2\nRAM | 8 gigabytes\nDisks | 120 gigabytes This configuration is adequate for most new client DSPs, but as you increase your purchased volume, the server may need to be upgraded as well. 3. Installing the Mopedo DSP When you have a server on which you would like to run the Mopedo DSP, follow the steps described in the Mopedo DSP Installation Guide to install the DSP software. 4. Setting up firewall rules When installing the DSP you created a configuration file in which, among other things, three network ports were selected. For the DSP to work properly, we need to open these ports in the Windows firewall, as well as any other firewalls active for the DSP server. We need to open the UdpPort for incoming and outgoing UDP traffic and the HttpPort and RESTPort ports for incoming and outgoing TCP traffic. Feel free to change any of these ports in the configuration file – the Mopedo backend will only communicate with the DSP over the UdpPort and HttpPort ports, and is automatically notified when ports change in the configuration. 5. Securing the REST API The REST API of the Mopedo DSP is a powerful interface, so it's important that proper security measures are in place to protect the API from unauthorized use. It's recommended to always: 6. Website integration and user matching Once your DSP instance is up and running, you will begin receiving bid requests from the Mopedo backend. The User objects contained within these bid requests may be unknown to you, but you can still bid on them if you want to. To add your own users, you need to set up user matching from one or more websites where you want to record activity. 7. Testing The final step of the integration is to create a test campaign, match some test users and test the solution from user matching to bidding. One common way to do this is to (1) user match a browser you currently use, (2) assign some unique segment to the UserExtension object belonging to the User that is generated, (3) setting up bid rules to target that unique segment only and (4) visiting some media sites with the browser to generate bid requests.","excerpt":"Getting started The integration process consists of the following steps: 1. Business agreement The first step is to sign a business contract with Mopedo, which will give you an account and password for accessing the Mopedo platform. The account and p","tags":"","url":"/Mopedo%20DSP/Administration%20guides/Getting%20started"},{"title":"Starcounter management guide","text":"Starcounter management guide The Mopedo DSP application runs inside a Starcounter in-memory database. This means that all the information that is used by the Mopedo DSP is stored on the server that runs the application. On the Starcounter developer site, there are some useful guides for how to set up things like backups, data exports and imports, crash dumps and more.","excerpt":"Starcounter management guide The Mopedo DSP application runs inside a Starcounter in-memory database. This means that all the information that is used by the Mopedo DSP is stored on the server that runs the application. On the Starcounter developer s","tags":"","url":"/Mopedo%20DSP/Administration%20guides/Starcounter%20management%20guide"},{"title":"Troubleshooting guide","text":"Troubleshooting guide Should you encounter any issues with your Mopedo DSP application, here are some steps to take to troubleshoot and create an issue report. Since the DSP application runs inside Starcounter, and possibly behind a HTTPS compatible proxy server, the first thing we need to check when encountering errors is that the application is running. We could, for example, receive 502 responses from the REST API when we use a proxy – even when the app is not running. You can check the status of the application from the Starcounter administrator website, usually available at localhost:8181. By clicking on the database from the Databases tab, you can see all applications currently running in that database. If your application is not started, try starting it. Issue guides If you get this error while trying to start the DSP application, which is commmon when trying to restart an application that failed during startup – click the Stop button next to the database name, and then Start. This will restart the Starcounter database. Then try again to start the DSP application. In some rare cases, it can be necessary to restart the Starcounter service, and the DSP application during troubleshooting. First check if there is an error with the current application configuration. The Log section of the Starcounter administrator should contain an configuration-related error description if the issue is with the configuration. If you need help from Mopedo, the best way to report issues is via our GitHub issue tracker. We will look at it right away. You can also contact develop@mopedo.com. These responses are most commonly due to some error in the network setup. If you are using a proxy, make sure that requests are forwarded correctly, and that the correct firewall rules are in place. If the response contains the RESTar-info header, the issue is likely due to some internal issue with the REST API. In these cases:","excerpt":"Troubleshooting guide Should you encounter any issues with your Mopedo DSP application, here are some steps to take to troubleshoot and create an issue report. Since the DSP application runs inside Starcounter, and possibly behind a HTTPS compatible ","tags":"","url":"/Mopedo%20DSP/Administration%20guides/Troubleshooting%20guide"},{"title":"Google Cloud setup guide","text":"Google Cloud setup guide Introduction This article explains how to set up a Windows Server instance on the Google Cloud Platform. Having an instance on Google Cloud is the best way to ensure that demand side applications, for example DSPs and DMPs, have the fastest possible response times when listening and responding to bid requests from the Mopedo backend. The article will focus on a basic setup, the kind of setup you are most likely interested in if you want to begin testing and initial trading on the Mopedo platform. Once your volume increases, however, you may want to upgrade your instance to a more powerful setup. You can do a lot of improvements in terms of auto-scaling, load balancing and performance monitoring on Google Cloud. Those aspects will not be covered in this article, but are included in the official Google Cloud documentation. Once you have a Google account, head over to the Google Cloud Console at console.cloud.google.com. It's from this console that you will control and edit your VM instances. Go to the VM instances sub-section in the Compute Engine section and press the CREATE INSTANCE button in the top menu. Fill in the following information: Next, head over to the Disks sub-section. We shall add a separate disk to run the Starcounter in-memory database from. Press the CREATE DISK button in the top menu. Enter the following information: Now head back to the VM instances sub-section, click on your newly created instance in the list and then press the EDIT button in the top menu. Scroll down to the Network tags section. Add a new mopedo tag in the Network tags text field by writing \"mopedo\" in the blank field and pressing the return key. About half-way down on the page, find the Additional disks section. Press the + Add item button and select your database disk from the drop-down menu. You have now added the database disk to your VM instance. Scroll to the bottom and press the Save button. Head over to the VPC network section via the ≡ button. Start by clicking the External IP addresses sub-section. By assigning a static external IP address, you can make sure your app always keeps the same IP even after instance restarts. If this seems like a good idea – press the RESERVE STATIC ADDRESS button, fill in the form and attach the static IP to your VM instance. Go to the Firewall rules sub-section. Here we create firewall rules to enable networking to and from your VM instance. To enable incoming bid requests from the Mopedo backend, you need to enable incoming UDP traffic over some port – default is 9004 – and incoming TCP traffic over some port – default is 8004. The Mopedo DSP has a REST API as well as ports for Mopedo Backend communication. If you want to enable communication through the REST API, you must create rules for these ports as well. Default REST API TCP ports are 8282 and 8283, but you can pick any ports as long as you provide the same ports as settings when configuring the DSP. It's up to you how to restrict traffic to the REST API, our recommendation is to always filter incoming traffic to certain allowed IP addresses if no other means of authorization is used to secure the REST API. To get login credentials for your instance, go to the VM instances sub-section in the Compute Engine section and click on your instance in the list. From here, click the Set Windows password button and follow the instructions. When done you will have a Windows user account and password. You will use this information when logging in to the instance over Remote Desktop. Click the RDP button in the Remote access section to read more about remote desktop, or press the downward arrow to open a drop-down menu and select Download the RDP file to download the file used to connect over remote desktop. Using a remote desktop client, for example Microsoft Remote Desktop, connect to your instance external IP address and use the account credentials to log in to the Windows desktop. When logged in to Windows, there are two things you need to do: You are now ready to install the software that will run on your server. To install a Mopedo DSP, see this guide.","excerpt":"Google Cloud setup guide Introduction This article explains how to set up a Windows Server instance on the Google Cloud Platform. Having an instance on Google Cloud is the best way to ensure that demand side applications, for example DSPs and DMPs, h","tags":"","url":"/Mopedo%20DSP/Administration%20guides/Google%20Cloud%20setup%20guide"},{"title":"IIS reverse proxy setup guide","text":"IIS Reverse Proxy setup guide Introduction This article explains how to use Microsoft Internet Information Services (IIS) to create a website on a Windows computer, that will forward requests to a Mopedo DSPs REST API using reverse proxy. The purpose of this setup is to allow SSL secured connections to the REST API. This is the default setup for your Mopedo DSP networking: The setup we want to achieve is this: We handle incoming HTTPS requests on a web server separate from the DSP (running on the same computer) that can handle HTTPS requests – in this case Microsoft IIS. IIS will secure incoming requests with SSL/TLS, and forward the secure requests to the DSP on some internal TCP port used for the REST API (18282 in the example). This setup is called a reverse proxy, and receiving HTTPS requests and forwarding them as HTTP requests to some other server is called SSL offloading. IMPORTANT: Due to the way IIS handles URIs and query strings, it's required that REST request to IIS with URIs containing certain special characters (for example < and >) contain a question mark (?) directly after the base URI. This is so that IIS will parse the special characters as part of the query string, and not part of the URI. IIS will not accept the URI in the following request: The URI will instead have to be: Setup guide Before you begin, you need the following: A registered domain that can be pointed to the external IP address of the DSP An SSL certificate In the Server Manager in Windows Server, click Add roles and features Click Next Click Next Click Next Select Web Server (IIS) and click Next Click Next Click Install and wait until the installation completes Download and run Microsoft Web Platform Installer from http://www.microsoft.com/web/downloads/platform.aspx In the Web Platform Installer, install the following modules: This process is different for different SSL certificate formats. IIS is a commonly used web server, however, so your certificate vendor will likely be able to help. When done, your certificate should be visible in the Server certificates view in the IIS Manager. Launch Internet Information Services (IIS) Manager by either searching for \"IIS\" from Start or by navigating to Control Panel\\System and Security\\Administrative Tools and double-clicking on Internet Information Services (IIS) Manager. Expand the view of your server in the left side panel by double-clicking on it Right-click on Sites and click Add Website… Give your website a name and as physical path In the Bindings section, add an HTTPS binding for your website. You will now have an HTTPS compatible web server listening for incoming requests on some port. The only thing remaining now is to forward those requests to the DSP. This forwarding is called reverse proxy. To create a reverse proxy, you need the modules we installed in step 2. First, lets activate the Application Request Routing proxy feature. Select the server in the left side panel by clicking on it Double click the Application Request Routing Cache icon in the server features view Click Server Proxy Settings… in the Actions side panel Check the Enable proxy checkbox Click Apply in the Actions side panel Select your website in the left side panel Double-click on URL Rewrite Click Add rule(s)… in the right side panel Select Reverse Proxy and click OK In the text field, enter 127.0.0.1: where is the internal HTTP port you want the REST traffic routed to. If you, for example, want to route incoming HTTPS traffic to the Mopedo REST API, and the REST API is listening on port 18282, you put 127.0.0.1:18282 in the text field. Make sure that the Enable SSL Offloading checkbox is checked Click OK Double-click on your newly created URL rewrite rule. In this window, you can add conditions or change the regular expression pattern used to rewrite the URLs of incoming requests. This is useful if you have multiple rewrite rules for different servers, on the same computer. For now, what we want to change is at the bottom of this window, so scroll down to the Action Properties section. The Rewrite URL will look something like this: http://127.0.0.1:18282/{R:1}. The port number may be different depending on what you entered in step 5. Replace the text after the port number (including the forward slash) with {UNENCODED_URL} The Rewrite URL should now look like this: http://127.0.0.1:18282{UNENCODED_URL} Uncheck the Append query string check box When redirecting HTTP requests from the IIS proxy to the Starcounter application, IIS will by default change the Host header to 127.0.0.1, which is generally not desirable. To tell IIS to preserve original Host headers: Disabling IIS error pages makes for a cleaner error handling, especially when receiving errors from the Mopedo REST API. Click on your site in the left side-panel Double-click on Error Pages Remove all list items","excerpt":"IIS Reverse Proxy setup guide Introduction This article explains how to use Microsoft Internet Information Services (IIS) to create a website on a Windows computer, that will forward requests to a Mopedo DSPs REST API using reverse proxy. The purpose","tags":"","url":"/Mopedo%20DSP/Administration%20guides/IIS%20reverse%20proxy%20setup%20guide"},{"title":"Installation guide","text":"Installation guide It is easy to install and update instances of the Mopedo DSP, much thanks to how applications are distributed using the Starcounter application platform. This guide will assume that you have a working Windows Server VM instance running in Google Cloud, or some other cloud provider. For information about how to setup a Google Cloud instance, see the separate Google Cloud Setup Guide article. Installing a Mopedo DSP The Mopedo DSP application is built on top of Starcounter, a high-performance in-memory database and app platform. To install a Mopedo DSP on a computer, we first need to install Starcounter. Download the latest Starcounter version from here. Run the Starcounter installer and choose Production on the first screen. If you have specified a separate database disk or want the DSP's database to be located at some location other than the user directory, make sure to select the Change additional settings option on the first screen of the installation wizard, and select that folder as the database repositories path (not the same as installation folder). If you have set up a blank database disk, create a folder called \"Starcounter\" on that disk and select that folder as database repositories path. When the installation is complete, you will have two new icons on the desktop: Starcounter Personal Server This shortcut launches the Starcounter service. If the administrator web page cannot be reached, try right-clicking on this icon and choosing Run as administrator. Starcounter Personal Administrator This shortcut launches the Starcounter administrator web page, which is where we can create new databases, install apps and check application logs. Continue by clicking the Starcounter Personal Administrator icon. If the web page cannot be reached, right-click on the Starcounter Personal Server icon and click Run as administrator, and then click the Starcounter Personal Administrator icon again. Create a new Starcounter database. All Starcounter applications run from inside a database. From the Starcounter Administrator web page, click the Databases tab in the top menu, and then New database. Give your new database a fitting name and click Create. Click the App Warehouse tab in the top view and scroll down until you see the Mopedo DSP in the list of apps: Click Download to download and install the DSP application to the current database. Download the template Mopedo.config file, an XML text file that will contain the configuration for your Mopedo DSP, and place it in the C:\\Mopedo directory (create the directory if it does not already exist). Set the properties of the Mopedo.config file. See the configuration section for more information. If the server will run more than one DSP application instance, you will need multiple databases – one for each DSP. To specify multiple configuration files, create one subfolder in C:\\Mopedo for each database – with the same name as database – and place your configuration files inside the respective folder. Example: C:\\Mopedo\\mydatabase\\Mopedo.config. If you want to make changes to the configuration file while the app is running, you must stop and start the app again before changes are applied. To update a Mopedo DSP to a newer version, go to the App Warehouse for the database that the DSP is running from, find the Mopedo DSP with the latest version number, and click the Upgrade button. The latest version of the app can then be launched from the database home window. If the app was already running, it will start automatically. Some updates to the Mopedo DSP requires you to also update your Starcounter version. The Warehouse page will by default only show versions compatible with your current version of Starcounter. If you need to update, but cannot see the new version, it's likely that you need to update Starcounter before you can continue. You can check if there are incompatible versions of the Mopedo DSP by unchecking the Show Compatible checkbox at the top of the Warehouse page and scrolling down to the Mopedo DSP versions.","excerpt":"Installation guide It is easy to install and update instances of the Mopedo DSP, much thanks to how applications are distributed using the Starcounter application platform. This guide will assume that you have a working Windows Server VM instance run","tags":"","url":"/Mopedo%20DSP/Administration%20guides/Installation%20guide"},{"title":"REST API introduction","text":"REST API introduction The REST API is a web interface established by a Mopedo DSP, over which its web resources are published so that external clients can interact with the DSP and its data. By sending and receiving messages through this interface, client systems, for example an advertiser's CRM system or a web site backend, can communicate with and update the content of the Mopedo DSP. If the term \"REST API\" is unfamiliar to you, we recommend that you read this excellent tutorial, that covers all you need to know. The REST API is implemented using RESTar – a REST API framework for the Starcounter platform, which has a separate documentation. Here are the essential sections in that documentation, useful for working with a Mopedo DSP: • Consuming a RESTar API Learn how to make requests to a RESTar API, for example a Mopedo DSP, and what to expect in responses. • Administering a RESTar API Set up role-based access control and deploy features that make it simple and secure for consumers to interact with the RESTar API. The Mopedo DSP has a number of available web resources, that can be read and manipulated using the REST API. Each resource has a unique name, and we can get the content of the resource, the entities, by using the following request URI schema: A concrete instance of the above schema, a GET request listing all Mopedo.Bidding.Campaign entities of a given DSP, could have the following syntax: By substituting GET with another HTTP method in the request above, we can perform other operations, for example insert new campaigns or delete an existing campaign. Different resources have different read and write permissions, which limits which REST methods are available.","excerpt":"REST API introduction The REST API is a web interface established by a Mopedo DSP, over which its web resources are published so that external clients can interact with the DSP and its data. By sending and receiving messages through this interface, c","tags":"","url":"/Mopedo%20DSP/Developer%20guides/REST%20API%20introduction"},{"title":"Bid request filtering","text":"Bid request filtering Bid request filtering is a powerful feature of the Mopedo DSP, which allows it to make an early coarse-grained selection of which incoming bid requests to accept, based upon the Matched status of their containing User or Device entities. Skipped requests are not stored in the BidRequest resource. This filtering is done before bid request evaluation is initiated, which means that filtered bid requests will not be evaluated at all – saving a great deal of CPU power and RAM memory usage. There is a big difference, performance-wise, between using bid request filters and using regular bid rules for selecting bid requests to respond to. A bid request filter can filter a large number of bid requests with a minimal impact on system performance – which is generally not the case for bid rules. It's therefore recommended to always use the most restricting bid request filter that is adequate with respect to the campaigns currently running on the DSP. You can configure the bid request filter by giving a value to the BidRequestFilter property in the Mopedo configuration file. The bid request filter can also be programmatically changed during DSP runtime by setting the property BidRequestFilter in the Mopedo.Settings resource. Available filter settings The OnlyMatchedUsers filter filters incoming bid requests based on the Matched status of the User contained in each bid request. If and only if Matched equals true for the user, will the bid request generate a BidRequest instance and be forwarded for evaluation. This filter is appropriate if the DSP should be set up to listen only for traffic with matched users. The OnlyMatchedDevices filter filters incoming bid requests based on the Matched status of the Device contained in each bid request. If and only if Matched equals true for the device, will the bid request generate a BidRequest instance and be forwarded for evaluation. This filter is appropriate if the DSP should be set up to listen only for traffic with matched devices. The MatchedUsersOrMatchedDevices filter filters incoming bid requests based on the Matched status of the User and Device entities contained in each bid request. If and only if Matched equals true for either the User or the Device, will the bid request generate a BidRequest instance and be forwarded for evaluation. This filter is appropriate if the DSP should be set up to listen only for traffic with either matched users or devices. The MatchedUsersWithMatchedDevices filter filters incoming bid requests based on the Matched status of the User and Device contained in each bid request. If and only if Matched equals true for both the User and the Device, will the bid request generate a BidRequest instance and be forwarded for evaluation. This filter is appropriate if the DSP should be set up to listen only for traffic with both a matched user and a matched device. The All filter setting applies no filtering and simply forwards all incoming bid requests to the evaluation step. This is an appropriate filter if the DSP should be set up to listen to as much traffic as possible, and has the necessary system resources to do so.","excerpt":"Bid request filtering Bid request filtering is a powerful feature of the Mopedo DSP, which allows it to make an early coarse-grained selection of which incoming bid requests to accept, based upon the Matched status of their containing User or Device ","tags":"","url":"/Mopedo%20DSP/Feature%20guides/Bid%20request%20filtering"},{"title":"User matching","text":"User matching User matching, as the term is used here, is the process of creating unique identifiers for the users in an audience, and associating these identifiers with user information that can later be used to determine an appropriate advertising message. User matching is essential for retargeting to work. The classic case is this: Someone visits an online store looking for some new sneakers. The shoe store recognizes this visitor and decides they want to show ads to him or her at some point in the future. They need some way to communicate this to their DSP, so that the DSP may detect that same user later in an incoming bid request – so they can respond with a relevant sneaker ad. To accomplish this, they assign a unique user ID to the user, put that ID in a cookie in the visitor's web browser, and then sync that ID – and any other relevant information they can find about the user – to their DSP. The first part of the user matching process, setting cookies and communicating IDs, is called cookie syncing. The latter part, sending the relevant data to the DSP, is called data uploading. The syncing is done automatically by a Mopedo server. All the advertiser needs to do is to embed a JavaScript tag on their relevant web pages, so that Mopedo can assign user IDs to the web site visitors. The second part, data uploading, is done by the advertiser upon receiving the Mopedo user ID from the cookie syncing step. By forwarding this ID to the DSP, together with relevant customer data, the advertiser can give the DSP the necessary information for later bid decisions. (1) and (2) in the model represent the two user matching steps. (3) and (4) represents the steps when the same matched user visits a media site, which will generate a bid request to the DSP from the Mopedo backend, that is evaluated against the segmentation data that was uploaded in step (2). Lastly, in (5), the DSP responds with an appropriate advertising message to the media site in the form of bids that are evaluated at an ad exchange on the sell-side of the Mopedo backend.","excerpt":"User matching User matching, as the term is used here, is the process of creating unique identifiers for the users in an audience, and associating these identifiers with user information that can later be used to determine an appropriate advertising ","tags":"","url":"/Mopedo%20DSP/Feature%20guides/User%20matching"},{"title":"API keys","text":"API keys API keys are character strings that are used for authenticating and authorizing RESTar API consumers in a role-based fashion. Whether API keys are required for a specific RESTar web service or not is decided by the application developer, but for services that require them, the consumer is expected to include a valid key in the Authorization header in HTTP requests. Failure to do so will result in a 403: Forbidden response. The administrator will set up and manage these API keys for web services that require them. It's best practice to set up an admin key with a wide scope and more restricted consumer keys with well-defined roles. For applications that use API keys, the developer will have defined a location for an XML configuration file. To add an API to this file, we insert an node inside the root node.","excerpt":"API keys API keys are character strings that are used for authenticating and authorizing RESTar API consumers in a role-based fashion. Whether API keys are required for a specific RESTar web service or not is decided by the application developer, but","tags":"","url":"/RESTar/Administering%20a%20RESTar%20API/API%20keys"},{"title":"Dynamic resources","text":"Dynamic resources Dynamic resources are persistent entity resources that have no pre-defined schemas. They can be changed not only in content, but in structure as well, and even created during runtime. They do, however, have some limitations due to their dynamic nature. This article will cover their basics. Dynamic resources in RESTar are Dynamit DDictionary entities. Dynamit is a free to use and open-source class library for creating dynamic table definitions in Starcounter. To illustrate the difference between dynamic and non-dynamic – static – resources, consider the object-oriented programming concept object, and its standard implementations in Java and JavaScript respectively. In Java – which is class-based – objects are static with regards to their members, and this structure is defined in compile-time in a class definition. We can change the contents of objects – that is, assign values to instance variables – during runtime, but we cannot change the structure of objects without first recompiling the application. In JavaScript – which is prototype-based - however, both the content and the structure of objects can change during runtime. Entities of dynamic resources behave like JavaScript objects in this regard. There is no common schema of property names and types that applies to all entities in a dynamic resource, and their members can have any name and data type, regardless of members and types of other entities in the same resource. The advantages and disadvantages of dynamic resources are the same as for the dynamic objects of JavaScript, their biggest advantage being, of course, their runtime flexibility. Dynamic resources can be created and deleted in runtime, and properties and property types can be added, changed or deleted in runtime. This flexibility makes them easy to use while importing data, since entities in the data source can have any structure. Dynamic resources are, however, slower than static resources, and are not type-safe in the same way that static resources are. Dynamic resources are automatically placed in the RESTar.Dynamic namespace, so their access rights can be controlled like any other resources. To restrict a set of dynamic resources to only some consumers, the administrator can either add them separately as access rights to their API keys, or place the resources in a common namespace using naming, for example RESTar.Dynamic.MyInnerNamespace, which can then be targeted with API keys. To manage the dynamic resources of a RESTar application, use the RESTar.Dynamic.Resource meta-resource. Example To create a new dynamic resource, insert an entity into RESTar.Dynamic.Resource: We can now insert whatever we like into our new resource:","excerpt":"Dynamic resources Dynamic resources are persistent entity resources that have no pre-defined schemas. They can be changed not only in content, but in structure as well, and even created during runtime. They do, however, have some limitations due to t","tags":"","url":"/RESTar/Administering%20a%20RESTar%20API/Dynamic%20resources"},{"title":"CORS","text":"CORS If you are unfamiliar with CORS (Cross-Origin Resource Sharing), check out this excellent introduction RESTar has built-in support for handling incoming CORS requests, and allows the administrator to set up a pre-defined list of whitelisted origins that should be allowed to make such request. For applications that accept whitelisting of CORS origins, the administrator can add such origins by including nodes inside the root node of the XML configuration file.","excerpt":"CORS If you are unfamiliar with CORS (Cross-Origin Resource Sharing), check out this excellent introduction RESTar has built-in support for handling incoming CORS requests, and allows the administrator to set up a pre-defined list of whitelisted orig","tags":"","url":"/RESTar/Administering%20a%20RESTar%20API/CORS"},{"title":"HTTPS","text":"HTTPS To protect the integrity of HTTP requests to the REST API, which is especially important when sending sensitive information like customer information or API keys, it's recommended that an HTTPS compatible web server is set up next to the REST API, which then routes requests to the REST API using reverse proxy. Starcounter 2.3.2, which is the version currently targeted by RESTar, has no native support for HTTPS and SSL, but it's easy to implement a secure solution using tools already included in Windows Server. Mopedo has an article on how to create a reverse proxy using Microsoft IIS. All you need is a registered domain and an SSL certificate. Starcounter also provides the following guides for setting up HTTPS for Starcounter servers:","excerpt":"HTTPS To protect the integrity of HTTP requests to the REST API, which is especially important when sending sensitive information like customer information or API keys, it's recommended that an HTTPS compatible web server is set up next to the REST A","tags":"","url":"/RESTar/Administering%20a%20RESTar%20API/HTTPS"},{"title":"JSON output formats","text":"JSON Output formats Sometimes when RESTar applications are consumed from other systems, for example dashboard systems like Bime or other RESTful web services, the JSON output from the RESTar application needs to conform to some external standard, for example JSend. RESTar supports placing the JSON array produced by the GET request to some resource inside an arbitrarily defined JSON object structure - and the format can be set on a per-request basis using the format meta-condition. For more information, and how to work with JSON output formats, see the documentation for the RESTar.Admin.OutputFormat resource.","excerpt":"JSON Output formats Sometimes when RESTar applications are consumed from other systems, for example dashboard systems like Bime or other RESTful web services, the JSON output from the RESTar application needs to conform to some external standard, for","tags":"","url":"/RESTar/Administering%20a%20RESTar%20API/JSON%20output%20formats"},{"title":"Introduction","text":"Administering a RESTar API Apart from the usual tasks associated with running a web service, the task of administering a RESTar API can be defined as:","excerpt":"Administering a RESTar API Apart from the usual tasks associated with running a web service, the task of administering a RESTar API can be defined as:","tags":"","url":"/RESTar/Administering%20a%20RESTar%20API/Introduction"},{"title":"Macros","text":"Macros Macros is a powerful feature of RESTar, that allows an administrator to create pre-defined requests that are used as syntactic templates, pre evaluation, to fill in properties for incoming API requests. Macros can be used to replace the URI, body or headers of calling requests. They enable advanced use cases such as simplifying complicated and often repeated requests or enabling integration with REST clients that cannot make certain requests, etc. For more information, and how to manage Macros, see the documentation for the RESTar.Admin.Macro resource.","excerpt":"Macros Macros is a powerful feature of RESTar, that allows an administrator to create pre-defined requests that are used as syntactic templates, pre evaluation, to fill in properties for incoming API requests. Macros can be used to replace the URI, b","tags":"","url":"/RESTar/Administering%20a%20RESTar%20API/Macros"},{"title":"Webhooks","text":"Webhooks Sometimes it's useful to make a web application send data to a remote computer, not only when the remote computer makes a request for it – for example using a GET request – but automatically when certain events occur on the server. We could, for example, have a notification resource in the RESTar application, where we add entities representing new notifications. The client could get the latest notifications using GET requests, but the solution is not really a useful unless the application has some way to push new notifications automatically to the client once they are created. For this purpose, we use webhooks. Webhooks are custom HTTP callback opterations that define automatic outgoing HTTP requests, triggered by [events]() that occur in the RESTar application. Each event carries a payload, which by default is used as the body of the outgoing HTTP request. The webhook can also define the HTTP method and custom headers that are used in the outgoing request. As an advanced feature, RESTar webhooks can even override the payload of the event, and define a custom request used for fetching the data to include as body of the ougoing request. For more information on how to work with webhooks, see the documentation for the RESTar.Admin.Webhook resource.","excerpt":"Webhooks Sometimes it's useful to make a web application send data to a remote computer, not only when the remote computer makes a request for it – for example using a GET request – but automatically when certain events occur on the server. We could,","tags":"","url":"/RESTar/Administering%20a%20RESTar%20API/Webhooks"},{"title":"Datetime","text":"Datetime (ISO 8601) An ISO 8601 datetime is a string that encodes a date and time according to the ISO 8601 standard. The date and time: Is encoded into the following ISO 8601 string: ISO 8601 datetimes can include an optional time zone designator. If not present, the DSP will assume that the time is expressed in the UTC time format. The DSP writes UTC datetimes in JSON output, for example: Z is the zone designator for the zero UTC offset according to ISO 8601.","excerpt":"Datetime (ISO 8601) An ISO 8601 datetime is a string that encodes a date and time according to the ISO 8601 standard. The date and time: Is encoded into the following ISO 8601 string: ISO 8601 datetimes can include an optional time zone designator. I","tags":"","url":"/RESTar/Built-in%20resources/Datetime"},{"title":"Overview","text":"Built-in resources overview RESTar has a number of built-in web resources that provide useful utilities and API metadata for consumers and administrators. The resources are ordered into three namespaces: Utilities for consumers and administrators Utilities for administrators Dynamic resources created at runtime It is recommended that the RESTar.Admin namespace is restricted to only administrators. Use the sidebar menu to explore the namespaces.","excerpt":"Built-in resources overview RESTar has a number of built-in web resources that provide useful utilities and API metadata for consumers and administrators. The resources are ordered into three namespaces: Utilities for consumers and administrators Uti","tags":"","url":"/RESTar/Built-in%20resources/Overview"},{"title":"Configuration","text":"Configuration The RESTar configuration file is an XML text file that is stored somewhere on the computer that runs the RESTar application. It contains API keys and allowed CORS origins that are used by RESTar to control access to the API. The developer will define where the file is to be stored, and the administrator makes sure that the file contains the correct keys and origins. If the configuration file path is C:\\Mopedo\\Config.xml for example, we create a new text file Config.xml, and place it in the C:\\Mopedo directory. The configuration file contains three main XML node types: Configuration file example The node is an XML node type used in RESTar configuration files to assign access rights to an API key. It has four inner node types: Each node must contain exacly one node, and at least one node. The node contains a character string that is used to be used as an API key in the REST API. It has the following syntactical limitations: Each assigns additional access rights to an API key. Each node must contain at least one node, and exacly one node. The total access scope, defined here as a set of method-resource pairs such that the key can be used with the method for the resource, for a key k is equal to the set union of all method-resource pairs assigned in the nodes for k. This means that we cannot exclude resources or methods from the scope of k by simply adding additional nodes with smaller sets of resources and/or methods. A defines one or more resources that should be included in the scope of a node. It consists either of the full name of a REST resource, or of a resource namespace followed by a dot and the wildcard character *. The wildcard character is used to include multiple resources from a namespace, excluding inner namespaces. If we have the following resources in our REST API… … the following node will select both the Mopedo.Bidding.Ad and Mopedo.Bidding.Campaign resources: The following node… … will select Mopedo.Currency, but not any of the resources from the Mopedo.Bidding namespace. To include all resources, we can use this set of nodes: The node contains all the methods to assign to the set of resources selected by the nodes of the containing node. The content of the node is either a comma-separated list of REST methods, e.g. GET, POST, DELETE, or the * character, that is equivalent to GET, POST, PATCH, PUT, DELETE, REPORT, HEAD. Note that the REPORT and HEAD methods are automatically made available if GET is made available. The last key, 1Rc5TCSJWmB7Mq7X, can make GET, REPORT, HEAD and PUT requests to the Mopedo.Database.User resource, GET, REPORT and HEAD requests to Mopedo.Database.Device as well as GET, POST, PATCH, PUT, DELETE, REPORT and HEAD requests to all the resources in the Mopedo.ClientData namespace. nodes are used in RESTar configuration files to whitelist an origin for use with CORS requests. The value is simply the URL of the origin to whitelist. If the RESTar application is set up to allow requests from all CORS origins, whitelisted origins will be ignored. To allow CORS requests from mysite.com, which can be accessed using the HTTP and HTTPS URL schemes, we add the following the the configuration file:","excerpt":"Configuration The RESTar configuration file is an XML text file that is stored somewhere on the computer that runs the RESTar application. It contains API keys and allowed CORS origins that are used by RESTar to control access to the API. The develop","tags":"","url":"/RESTar/Administering%20a%20RESTar%20API/Configuration"},{"title":"Body and data sources","text":"Body and data sources POST, PATCH and PUT requests require a data source to insert and/or update resources from. There are two ways to associate a data source with a request – either by including the data in the body of the HTTP request, or to include a path to the data in the Source header. The REST API can read and write data in two formats: JSON and Excel. Of these two, JSON is the most flexible and commonly used. Excel works well for human readability and reading and writing large data sets, but cannot handle nested objects – which is a limitation when dealing with resources modeled with inner objects. Technically, the correct MIME type to include in requests when reading or writing Excel (.xlsx) files is application/vnd.openxmlformats-officedocument.spreadsheetml.sheet. For testing and debugging purposes, the REST API also accepts the shorter excel as MIME type string. POST using JSON text POST using an Excel file To upload Excel data, include the file as binary in the body and set the Content-Type header to application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.","excerpt":"Body and data sources POST, PATCH and PUT requests require a data source to insert and/or update resources from. There are two ways to associate a data source with a request – either by including the data in the body of the HTTP request, or to includ","tags":"","url":"/RESTar/Consuming%20a%20RESTar%20API/Body%20and%20data%20sources"},{"title":"Demo service","text":"Demo service While exploring the RESTar documentation, feel free to use this demo server and API key: Using a REST client Using your REST client of choice (Postman is a good one), send an HTTP GET request to the URI above, and include \"apikey restar\" as the value of the Authorization header. The response you see contains a list of all resources made available for the API key \"restar\". One such resource is the RESTarTutorial.Superhero resource, on which only GET requests are allowed. To query this particular resource, use the following URI: You will now see the contents of the RESTarTutorial.Superhero entity resource – that is – all Superhero entities. To only list superheroes with secret identities, use the following URI: This is the basics of how to consume a RESTar API using HTTP requests. URIs are used to specify what resource and what entities within a resource to operate on, the method specifies what operation to perform (for example GET), and headers like Authorization are used to pass additional information to the web service. Using WebSockets The most flexible way to explore the web resources of a RESTar service is to plug in to its Shell resource using a WebSocket connection. To connect to the demo service, use a WebSocket client like wscat or this chrome extension, with this URI: An introduction to how to work with WebSockets and connect to the demo service can be found here.","excerpt":"Demo service While exploring the RESTar documentation, feel free to use this demo server and API key: Using a REST client Using your REST client of choice (Postman is a good one), send an HTTP GET request to the URI above, and include \"apikey restar\"","tags":"","url":"/RESTar/Consuming%20a%20RESTar%20API/Demo%20service"},{"title":"Introduction","text":"Introduction This part of the documentation provides a technical specification of the RESTar protocol, used to consume the web services provided by a RESTar application, for example a Mopedo DSP. RESTar can be setup to support additional protocols, for example OData, but for now, let's focus on the default protocol. We will only describe the format of REST requests and responses here. For a description of the actual web resources of a specific application – for example the User and Site resources of the Mopedo DSP application, see the documentation provided for that application. As an API consumer, the application administrator will make resources available for you by creating API keys, and binding certain web resources and methods to them. Different API keys can have different access rights, so make sure to keep your API key secure. When you know the location of the web service – that is – its URI, and your assigned API key, you are ready to begin sending requests to the service.","excerpt":"Introduction This part of the documentation provides a technical specification of the RESTar protocol, used to consume the web services provided by a RESTar application, for example a Mopedo DSP. RESTar can be setup to support additional protocols, f","tags":"","url":"/RESTar/Consuming%20a%20RESTar%20API/Introduction"},{"title":"Methods","text":"Methods RESTar accepts eight common HTTP methods in requests to entity resources. GET GET requests returns all entities in the selected resource that match a given set of conditions. If no conditions are given, all entities in the resource are returned. POST POST inserts an entity or a list of entities from a data source into the selected resource. PATCH PATCH updates one or more existing entities in the selected resource, identified by a given set of conditions. If no entity is found by matching against conditions, a 404 response is returned. To update multiple entities with a single request, which is a potentially unsafe operation, include unsafe=true as meta-condition. Matched entities are updated with the content from a provided entity, from a data source. PUT PUT is the duplicate-safe way to insert new entities in a resource. PUT will find any single existing entity in the selected resource matched by a given set of conditions. If no entity is found, a POST will be made to the resource with the entity provided from a data source. If an entity is found, a PATCH will be made on that entity with the content from an entity provided from a data source. If more than one entity is found, a 400 response is returned. DELETE DELETE will find all entities in the selected resource matched by a given set of conditions. If only one entity was found, that entity will be deleted from the resource. If more than one entity was found, a 400 response is returned. To override this behavior and delete all found entities, which is a potentially unsafe operation, include unsafe=true as meta-condition. REPORT REPORT performs a GET request, but instead of returning representations of resource entities selected by the request, the number of entities is returned. REPORT, as implemented in RESTar, is technically a variant of GET, and all resources supporting GET, also supports REPORT. All API keys that have GET access to a resource, also have REPORT access. All REPORT requests have the same response body format: Properties marked in bold are required. Property name | Type | Description\n------------- | --------- | ----------------------------------------------\nCount | integer | The number of entities selected by the request HEAD HEAD performs a GET request, but instead of returning representations of resource entities selected by the request, only the response headers are returned. HEAD is technically a variant of GET, and all resources supporting GET, also supports HEAD. All API keys that have GET access to a resource, also have HEAD access.","excerpt":"Methods RESTar accepts eight common HTTP methods in requests to entity resources. GET GET requests returns all entities in the selected resource that match a given set of conditions. If no conditions are given, all entities in the resource are return","tags":"","url":"/RESTar/Consuming%20a%20RESTar%20API/Methods"},{"title":"Request overview","text":"Request overview Requests to the REST API of a RESTar application are standard HTTP requests. Encoded in a request is all information necessary to perform a certain operation on a given resource. RESTar has [multiple resource kinds](), that have slightly different methods of interaction, but let's stick with [entity resources]() for now, since they are the ones most commonly used. To further explore the components of HTTP requests to a RESTar application, use the links below: Method Methods define the operation to perform on the selected resource URI URIs select the resource to operate on, and contain additional instructions for how the request should be processed. Headers Headers define high-level request parameters like authorization and content types. Body The body of the request is used to communicate content, for example a JSON representation of an entity, to the REST API. Examples The easiest way to familiarize oneself with how to consume a RESTar API, is to make real requests to an actual RESTar API. For this purpose, feel free to use our test API. The URI examples below are written as relative URIs for the sake of brevity, but you can generate an absolute URI from them by pasting them directly after the root URI of the remote test service. The relative uri /superhero would generate the absolute URI https://restarhelp.mopedo-drtb.com:8282/api/superhero. Note that the test service only supports GET, REPORT and HEAD requests. For all requests, the Authorization header has the value apikey restar. Some example URIs:","excerpt":"Request overview Requests to the REST API of a RESTar application are standard HTTP requests. Encoded in a request is all information necessary to perform a certain operation on a given resource. RESTar has [multiple resource kinds](), that have slig","tags":"","url":"/RESTar/Consuming%20a%20RESTar%20API/Request%20overview"},{"title":".NET API reference","text":".NET API reference This part of the documentation lists and details all the public types available in the RESTar .NET API. It's useful when developing RESTar applications. The types of the RESTar .NET API are distributed over the following namespaces: Namespace | Description\n:----------------------------------------------------------- | :-------------------------------------------------------------------------------------------\nRESTar | Common multi-purpose types\nRESTar.Admin | Types for API administration\nRESTar.ContentTypeProviders | Available [content type providers**]() and tools for defining custom content type providers.\nRESTar.Linq | asd\nRESTar.Meta | asd\nRESTar.NetworkProviders | asd\nRESTar.ProtocolProviders | asd\nRESTar.Requests | asd\nRESTar.Resources | asd\nRESTar.Results | asd\nRESTar.WebSockets | asd","excerpt":".NET API reference This part of the documentation lists and details all the public types available in the RESTar .NET API. It's useful when developing RESTar applications. The types of the RESTar .NET API are distributed over the following namespaces","tags":"","url":"/RESTar/Developing%20a%20RESTar%20API/.NET%20API%20reference"},{"title":"Responses","text":"Responses Error responses If something goes wrong while evaluating a request, the REST API will respond with either a 4XX or 5XX status code and a description of the error in the RESTar-info response header. Errors that are not 403: Forbidden are also stored in the RESTar.Error resource. Success responses Code | Status description | Body | Info\n---- | ------------------ | -------- | ---------------------------------------------------\n200 | OK | entities | If entities are found, representations are included\n204 | No content | empty | RESTar has multiple built-in output formats, and the administrator can also add new ones. This makes it easy to conform JSON output to external standards. The administrator can create new output formats and set default formats using the RESTar.Admin.OutputFormat resource. The consumer can switch between output formats on a per-request basis using the format meta-condition. Code | Status description | Body | Notes\n---- | ------------------ | ------- | ----------------------------\n201 | Created | empty |\n200 | OK | empty | If no entities was inserted. Code | Status description | Body | Notes\n---- | ------------------ | ------- | -------------------------------\n200 | OK | empty | Even if no property was changed Code | Status description | Body | Notes\n---- | ------------------ | ------- | ------------------------\n201 | Created | empty |\n200 | OK | empty | If an entity was updated Code | Status description | Body | Notes\n---- | ------------------ | ------- | -----\n200 | OK | empty | Code | Status description | Body | Notes\n---- | ------------------ | ----------- | -----\n200 | OK | report body | All successful responses from REPORT requests share the same body format: Property name | Type | Description\n------------- | --------- | ----------------------------------------------\nCount | integer | The number of entities selected by the request Code | Status description | Body | Info\n---- | ------------------ | ------- | ---------------------\n200 | OK | empty | Only response headers\n204 | No content | empty | Custom response headers RESTar uses the following custom HTTP headers to include meta-data in responses. These do not include standard HTTP headers like Content-Type, Content-Length etc. Information about the result of the request, if any. For POST requests, for example, RESTar-info contains the number of inserted entities. For any error response, a description of the error. For error responses, RESTar-error contains a link to the RESTar.Admin.Error entity describing this particular error. For all other responses, this header is excluded. The number of milliseconds elapsed during the evaluation of the request. For GET and HEAD requests, RESTar-count contains the number of entities encoded in the response body. See pagination below. The version of the RESTar package of the RESTar application that generated the response. Pagination RESTar supports client-side pagination using the and limit and offset meta-conditions in GET requests. To break a list of 1000 employees into ten pages with 100 per page – using client-side pagination – we use these URIs: To simplify this pattern, RESTar will include a header RESTar-pager in paginated GET responses – that is, responses that do not include the last entity from the enumeration of resource entities that was used to generate the response. The value of this header will be whatever the limit and offset meta-conditions need to be set to in the next request in order to return the next equally sized page of entities from the RESTar application. This means that the consumer can paginate a resource's entire content without knowing how many pages there will be. The User resource contains a large number of entities – the consumer does not know how many. The consumer can still get all User entities, 1000 at a time, without first counting users and determining how many requests should be made. First, the consumer gets the first 1000 entities with URI: The response will be: For the next page, the consumer can copy the value of the RESTar-pager header and place in the next request. URI for page 2: And so on until either a 204: No content response is encountered, or there is no RESTar-pager header in the response (which means that the last entity in the enumeration was included in the response).","excerpt":"Responses Error responses If something goes wrong while evaluating a request, the REST API will respond with either a 4XX or 5XX status code and a description of the error in the RESTar-info response header. Errors that are not 403: Forbidden are als","tags":"","url":"/RESTar/Consuming%20a%20RESTar%20API/Responses"},{"title":"Binary resources","text":"Building binary resources Nothing here yet","excerpt":"Building binary resources Nothing here yet","tags":"","url":"/RESTar/Developing%20a%20RESTar%20API/Binary%20resources"},{"title":"URI","text":"URI Request URIs contain three parts that specify three important components of the request. These components are: The grammar section below gives a formal description of the format of request URIs. Before we dive into that, let's look at an informal one. URIs begin with a URL to the API. For our demo service, this is: Now, in order – for each of the three URI parts mentioned above – we add a forward slash /, and either an underscore _ (if the part should be left blank) or the part to include. If we want to include superhero as the resource, and limit=2 as meta-conditions, for example, we can produce the following URI: See the links in the URI part list above for how they are written in URIs. Grammar RESTar request URIs have the following grammar (EBNF): Notes Case sensitivity All components in URIs are case-insensitive, except for value literals. When comparing, for example, the value of a string property in an entity with another value, the REST API makes difference between string values \"steve\" and \"Steve\". It's, however, always safe to treat all URI components as case sensitive. Evaluation order Each request can contain instructions for several operations, triggered by conditions and meta-conditions, that are carried out in a pre-defined order. – Entities are first filtered according to the conditions. search – Search filters are applied. add – Additional properties are added. rename – All rename schemes are applied. select – Properties are filtered according to the select property locator list. distinct – Non-distinct entities are skipped. order_desc / order_asc – The entities are ordered. offset – The offset is applied. limit – The number of entities are limited. This means that if many of select, rename or add are used in the same request – property locators in select cannot make references to properties that have been renamed, but can reference added properties. rename can also reference added properties.","excerpt":"URI Request URIs contain three parts that specify three important components of the request. These components are: The grammar section below gives a formal description of the format of request URIs. Before we dive into that, let's look at an informal","tags":"","url":"/RESTar/Consuming%20a%20RESTar%20API/URI"},{"title":"Event resources","text":"","excerpt":"","tags":"","url":"/RESTar/Developing%20a%20RESTar%20API/Event%20resources"},{"title":"Getting started","text":"Getting started RESTar is distributed as a .NET package on NuGet, and an easy way to install it in an active Visual Studio project is by entering the following into the NuGet Package Manager console: The installation will also download some other packages that are required for RESTar to work. RESTar itself, however, is contained within a single assembly, RESTar.dll. When RESTar is installed, add a call to the RESTar.RESTarConfig.Init() method somewhere in your application logic, preferably so it runs once every time the app starts. This method will set up the RESTar HTTP handlers, and collect all your registered REST resources. Below is a simple RESTar application, picked from the RESTar Tutorial Repository: See this page for details on what can be specified in the call to RESTarConfig.Init().","excerpt":"Getting started RESTar is distributed as a .NET package on NuGet, and an easy way to install it in an active Visual Studio project is by entering the following into the NuGet Package Manager console: The installation will also download some other pac","tags":"","url":"/RESTar/Developing%20a%20RESTar%20API/Getting%20started"},{"title":"Introduction","text":"Introduction The main purpose of RESTar, as a software framework, is to facilitate a unified REST interface between external HTTP clients and the data that the application wants to expose, and to provide fast and powerful implementations for common tasks like request parsing, request authentication, database querying, data filtering and JSON serialization. By letting the RESTar framework deal with these complex (and boring) tasks, we can increase the level of abstraction, letting the application developer worry about less things and instead focus on the content and functionality of their respective apps. RESTar encourages a resource-oriented architecture (ROA) approach to application design, where the software engineering effort is focused around declaring and defining what is exposed to the REST API, i.e. the resources, as opposed to how it's exposed. RESTar is also designed to be easily integrated with new and existing Starcounter applications, but at the same time allow the developer to override some of the functionality to accommodate more advanced use cases. RESTar resources When building RESTar application, developers mainly work with defining resources – i.e. the data that should be available for consumption over the REST API of the RESTar application. There are four kinds of resources that can be defined in RESTar: Sets of data entities, for example rows in a database table. These entities can be filtered and serialized to some content type, for example JSON Read-only binary data streams that are delivered directly to clients Small single-purpose console applications that are consumed using WebSocket connections Events are raised by the RESTar application and can be used to trigger actions, for example webhooks Each of these have their own section of the documentation, focused on how to build them. Common to all resource definitions in RESTar is that they are declarative in nature, much due to the fact that the concept of a resource in RESTar is closely coupled with a declarative component of .NET – class declarations.","excerpt":"Introduction The main purpose of RESTar, as a software framework, is to facilitate a unified REST interface between external HTTP clients and the data that the application wants to expose, and to provide fast and powerful implementations for common t","tags":"","url":"/RESTar/Developing%20a%20RESTar%20API/Introduction"},{"title":"Protocol providers","text":"Protocol providers A protocol provider is an add-on for RESTar that lets protocols other than the built-in protocol be used for defining the formats of API requests and responses. The built-in protocol is what is described in the Consuming a RESTar API section of the documentation. Using a custom protocol provider, however, a developer could decide to use a completely different set of URI conventions or response formats, but still use most of the inner workings of RESTar for declaring, finding, querying and manipulating resources. To create a protocol provider, make a new .NET class and have it implement the RESTar.IProtocolProvider interface. It has the following definition: To use a custom IProtocolProvider instance in a RESTar application, include it in the protocolProviders parameter of the call to RESTarConfig.Init(). See also: Content type providers. For a concrete example, see the RESTar.OData protocol provider.","excerpt":"Protocol providers A protocol provider is an add-on for RESTar that lets protocols other than the built-in protocol be used for defining the formats of API requests and responses. The built-in protocol is what is described in the Consuming a RESTar A","tags":"","url":"/RESTar/Developing%20a%20RESTar%20API/Protocol%20providers"},{"title":"Headers","text":"Headers By including certain parameters as values in request headers, the client can instruct the server to perform some high-level operations while handling a request. Authorization When designing a RESTar application, the developer can choose if to require API keys in REST API requests. If API keys are required, the client is expected to include the key in the Authorization header. If \"mykey\" is a valid API key, a request could look like this: RESTar also supports basic authentication. This is particularly useful when sending requests from clients that have built-in support for basic authentication. Basic authentication needs the client to input a user name and password. When sending requests to a RESTar API with basic authentication, leave the user name blank and use the api key as password. Content-Type The Content-Type header is used to inform the server of what format the data from the data source is encoded in. Tha value should be a MIME type string, for example application/json (JSON) or application/vnd.openxmlformats-officedocument.spreadsheetml.sheet (Excel). The RESTar application developer can define [additional supported input content types](). Accept The Accept header tells the server to encode the response body in a certain format. By default, responses are JSON-formatted, but this can be changed to Excel by setting the content of the Accept header to application/vnd.openxmlformats-officedocument.spreadsheetml.sheet. The server will automatically, as per convention, include information in the Content-Disposition header, that the client can use to automatically give the output file an appropriate name. The RESTar application developer can define [additional supported output content types](). Source If an external data source should be used instead of the contents of the request body, a method and URI to that data source can be included in the Source header. The input content type is still defined by the Content-Type header. Source headers values have the following syntax (EBNF): Destination If the data included in a response from a REST API request should be forwarded to an external destination instead of back to the client, we can specify this destination as a method and URI in the Destination header. And if we want the data to be sent to the external destination in Excel format, we simply set the Accept header to application/vnd.openxmlformats-officedocument.spreadsheetml.sheet. Destination header values have the following syntax (EBNF): When the Destination header is set, the request response will be whatever response the server receives from sending a request with the specified method, URI and data to the destination server. The response body from a GET request, if entities were found, is always an array of JSON objects (or a set of rows in Excel), which means that the destination for a GET request must be able to handle an array of entities as input. This, in turn, means that if a RESTar server is used as destination, the destination method must be POST, as it's the only method that allows an array of entities to be used as input. Sometimes we want to insert entities in a duplicate-safe way, however, which is why we need the Safepost meta-condition – which will trigger a server-side iteration over the list of entities and splitting the request into multiple internal PUT requests.","excerpt":"Headers By including certain parameters as values in request headers, the client can instruct the server to perform some high-level operations while handling a request. Authorization When designing a RESTar application, the developer can choose if to","tags":"","url":"/RESTar/Consuming%20a%20RESTar%20API/Headers"},{"title":"Registering resources","text":"Registering resources","excerpt":"Registering resources","tags":"","url":"/RESTar/Developing%20a%20RESTar%20API/Registering%20resources"},{"title":"RESTarMemberAttribute","text":"RESTarMemberAttribute RESTar has built-in member reflection for resource types, which is how it defines the JSON and Excel templates that are used during serialization and deserialization and how it creates bindings between, for example, JSON representations and instances of the actual .NET classes. We can configure the reflected resource properties by decorating their declarations with the RESTarMemberAttribute attribute and including options in its constructor. The constructor for RESTarMemberAttribute has the following signature: ignore Should this property be completely ignored by RESTar? name A new name for this property that is used instead of the declared name in all representations. order The order at which this property appears when all properties are enumerated. hide Should this property be hidden in serialized output by default? It can still be added using the add meta-condition and queried against. hideIfNull Should this property be hidden in output if the value is null? Only applies to JSON output. readOnly Makes this property read-only over the REST API, even if it has a public setter. skipConditions Sets the Skip property of all conditions matched against this property to true by default, skipping all conditions that are made to this property. allowedOperators These operators will be allowed in conditions targeting this property. excelReducer The name of an optional public ToString-like method, declared in the same scope as the property, that reduces the property to an Excel-compatible string. replaceOnUpdate Should this object be replaced with a new instance on update, or reused? Applicable for types such as Dictionaries and Lists. Non-RESTar attributes that are respected We can also change how RESTar treats certain properties of resources by using the .NET standard IgnoreDataMemberAttribute and DataMemberAttribute attributes (located in the System.Runtime.Serialization namespace). Using these attributes, we can, for example, rename properties and ignore properties when serializing and deserializing from JSON (and Excel). For more information, see the Microsoft documentation. The JSON.net JsonPropertyAttribute is also respected.","excerpt":"RESTarMemberAttribute RESTar has built-in member reflection for resource types, which is how it defines the JSON and Excel templates that are used during serialization and deserialization and how it creates bindings between, for example, JSON represe","tags":"","url":"/RESTar/Developing%20a%20RESTar%20API/RESTarMemberAttribute"},{"title":"Content type providers","text":"Content type providers A content type provider defines serialization and deserialization operations for a content type. Content types are data formats that can be used in RESTar input and output, and using content type providers – we can add additional content types to a RESTar application. Content type providers bind logic to a MIME type, which is defined as a string, for example application/json. When receiving requests, RESTar will pick the appropriate content type provider to use when deserializing input data from the content of the Content-Type header, and the appropriate content type provider to use when serializing output data from the content of the Accept header. Included content type providers These three protocol providers are already included with RESTar. You can also list all available protocols and their content providers by making a GET request to the RESTar.Admin.Protocol resource. The JsonContentProvider is the default JSON content type provider for reading and writing JSON, and handles requests that have the following MIME types defined in their Accept or Content-Type headers: Since custom content type providers can override bindings to MIME types, a special application/restar-json is used to preserve a binding, should the client need to use the JsonContentProvider while application/json is overridden. There is a public static JsonContentProvider instance available at RESTar.Serialization.Serializers.Json, that can be used in RESTar applications to serialize, deserialize and populate RESTar JSON. The ExcelContentProvider is used to read and write Excel files. It has the following MIME type bindings: The XMLWriter can be used to write responses to XML. It can, however – unlike the other two included content type providers – not deserialize entities. It has the following MIME type bindings: Creating custom content type providers To create a custom content type provider, implement the IContentTypeProvider interface. It has the following definition: To use a custom content type provider, include an instance of it in the contentTypeProviders parameter in the call to RESTarConfig.Init().","excerpt":"Content type providers A content type provider defines serialization and deserialization operations for a content type. Content types are data formats that can be used in RESTar input and output, and using content type providers – we can add addition","tags":"","url":"/RESTar/Developing%20a%20RESTar%20API/Content%20type%20providers"},{"title":"Internal requests","text":"Internal requests A RESTar REST API is most commonly consumed by a REST client, that is – an application that speaks HTTP and JSON. Sometimes, however, it's useful to send internal requests from other parts of your Starcounter application, and interact with your entity resources without having to make unnecessary HTTP requests with string parsing and JSON serialization. If all RESTar entity resources were Starcounter database tables, this would not be a problem – since we could just interact with them directly using Db.Transact and Db.SQL. But since RESTar can have a wide variety of different resources, a unified interface for querying and manipulating them is needed. For this, we use the generic RESTar.Request class where T is the entity resource type we want to interact with. Request instances do not work with terminal types. Internal requests have the same main components as HTTP requests, but are much faster since they bypass request parsing, authentication and JSON serialization. They follow the same philosophy of RESTful web services in general – but without the HTTP layer. These are the public members of the Request class: Internal requests best practices For Starcounter database resources, RESTar will automatically execute the provided delegates inside transaction scopes, so there is no need to include transactions in inserter and updater lambdas. Another way to make internal REST requests is by using the Starcounter.Self class, but these are significantly slower, require authentication (if requireApiKey is set to true in the call to RESTarConfig.Init()), and are not as flexible in terms of type safety and error handling. Performance-wise, it's recommended to reuse Request objects whenever possible. When doing repetitive requests internally, it's best to keep a static Request object, and just replace the conditions between usages. RESTar provides a namespace RESTar.Linq, with a static class Conditions which contains useful methods for working with conditions of internal requests. Request objects can be very fast if used properly, especially for Starcounter database resources. When changes are made to their conditions, a Starcounter SQL query will be generated and cached within the Request object, which means that consecutive SQL queries for the same Request object are very fast. Request objects are frequently used internally within RESTar. Examples","excerpt":"Internal requests A RESTar REST API is most commonly consumed by a REST client, that is – an application that speaks HTTP and JSON. Sometimes, however, it's useful to send internal requests from other parts of your Starcounter application, and intera","tags":"","url":"/RESTar/Developing%20a%20RESTar%20API/Internal%20requests"},{"title":"RESTarConfig.Init","text":"RESTarConfig.Init() This is the complete method signature for RESTarConfig.Init(): By changing the values of these parameters, you can configure RESTar to best serve your current application. port The port parameter controls which HTTP port to register the RESTar handlers on. One Starcounter HTTP handler is registered on this port for each of the following HTTP verbs: GET, POST, PATCH, PUT, DELETE, OPTIONS. uri The uri parameter is what is used for the root uri of the REST API. If the application is deployed locally, and the port parameter is set to 8282, the RESTar API will be listening for requests on http://localhost:8282/rest. requireApikey To require authentication and authorization for all requests using API keys, set this parameter to true. If set to true, it's required to include a configuration file path in the configFilePath parameter. allowAllOrigins To require the administrator of the application to whitelist all CORS origins that are allowed to make requests to this application, set the allowAllOrigins parameter to false. If set to false, it's required to include a configuration file path in the configFilePath parameter. configFilePath When either requireApikey is set to true or allowAllOrigins is set to false, RESTar needs a configuration file to read API keys and/or whitelisted CORS origins from. How to administrate API keys and CORS origins is covered in the Administering a RESTar API section, but the path to the file needs to be provided by the developer. prettyPrint The prettyPrint parameter controls whether JSON output from RESTar is \"pretty printed\", that is – indented – to increase human readability. daysToSaveErrors When the REST API aborts operations due to some error, for example a format error in the incoming request, information about the error is stored in the RESTar.Admin.Error resource. The daysToSaveErrors parameter controls after how many days the error should be deleted from the log. lineEndings By default, RESTar will use windows line endings, \\r\\n, in serialized JSON output. To change this to linux line endings, \\n, set the value of lineEndings to LineEndings.Linux. resourceProviders RESTar has support for add-ons in the form of resource providers. They provide a way to standardize RESTar operations for some data storage technology – for example SQLite. To include a resource provider in the RESTar instance, add it to a collection and assign to this parameter. protocolProviders RESTar can also take add-ons in the form of protocol providers, objects that contain the logic for parsing requests and generating responses according to some external protocol, for example OData. To include a protocol provider in the RESTar instance, add it to a collection and assign to this parameter. contentTypeProviders A third type of RESTar addon is content type providers. They add support for additional content types that can be used to read and write data from a RESTar application. Three content type providers (JSON, Excel, and XML) are already included with RESTar, but any additional providers must be added here.","excerpt":"RESTarConfig.Init() This is the complete method signature for RESTarConfig.Init(): By changing the values of these parameters, you can configure RESTar to best serve your current application. port The port parameter controls which HTTP port to regist","tags":"","url":"/RESTar/Developing%20a%20RESTar%20API/RESTarConfig.Init"},{"title":"Troubleshooting","text":"Troubleshooting This article contains some infamous problems that can occur when developing RESTar applications, and how to solve them: SCERR2143 Example: This error is almost always related to the application's weaver.ignore file. The Starcounter Weaver cannot deal with strong-named assemblies, abd we therefore need to include them in the application's weaver.ignore file. Add the following assemblies to the application's weaver.ignore file, or create a new text file called weaver.ignore in your project output folder with the content from the link. SCERR2147 Example: As far as we have found out, this can be caused by three things:","excerpt":"Troubleshooting This article contains some infamous problems that can occur when developing RESTar applications, and how to solve them: SCERR2143 Example: This error is almost always related to the application's weaver.ignore file. The Starcounter We","tags":"","url":"/RESTar/Developing%20a%20RESTar%20API/Troubleshooting"},{"title":"Terminal resources","text":"Building terminal resources RESTar supports custom terminal resources, so developers can create their own interactive WebSocket applications that are published in the REST API.","excerpt":"Building terminal resources RESTar supports custom terminal resources, so developers can create their own interactive WebSocket applications that are published in the REST API.","tags":"","url":"/RESTar/Developing%20a%20RESTar%20API/Terminal%20resources"},{"title":"Currency","text":"Currency The Currency resource contains all currencies currently loaded in the DSP, along with their exchange rates and ISO 4217 currency codes. Exchange rates and currencies are automatically downloaded the first time the DSP instance launches, and are updated regularly. Format Property name | Type | Description\n------------- | ------ | --------------------------------------------------------------------------------------------------\nExchangeRate | string | The exchange rate for this currency, relative the reference currency – SEK\nCurrencyCode | string | The ISO 4217 currency code of this currency","excerpt":"Currency The Currency resource contains all currencies currently loaded in the DSP, along with their exchange rates and ISO 4217 currency codes. Exchange rates and currencies are automatically downloaded the first time the DSP instance launches, and ","tags":"","url":"/Mopedo%20DSP/Developer%20guides/API%20reference/Currency"},{"title":"API reference overview","text":"API reference overview In this section of the documentation, we detail the web resources that are available through the REST API of Mopedo DSP applications. It's by modifying the contents of these resources that we can instruct the DSP application how to make programmatic purchases, as well as handling the user data that is used in these bidding decisions. The web resources of the Mopedo DSP can be ordered into six main classes. You can explore the contents of these resource classes using the menu to the left. 1. Bidding resources These are used to read and manipulate the DSP's bidding behavior, for example the Campaign and Ad entities that are used when responding to bid requests. Contained in the Mopedo.Bidding namespace. 2. Database resources The database namespace include the User and Device resources, which are updated as traffic is received from the Mopedo backend or when user matching. Contained in the Mopedo.Database namespace. 3. Client data resources The four main database resource types, User, Device, Site and App are extendable – i.e. can be associated with arbitrary data, labels and/or segments, by using their respective extension resource. Contained in the Mopedo.ClientData namespace. 4. Reporting resources Create detailed reports of the DSPs current or historical behavior. Contained in the Mopedo.Reporting namespace. 5. Archive resources Set up routines that automatically move entities from in-memory resources to disk-based storage, freeing up system resources on your DSP. 6. Debug resources Debug resources help DSP administrators when troubleshooting and debugging DSP instances Other resources Apart from the four main resource classes, there are also these additional support resources: Currency The currencies available in the DSP Settings The current settings of the DSP application ErrorLog A log resource that contains information about errors encountered by the DSP Operator The operators available for use in bid rules Datetime Information about how dates and times are encoded in the DSP's web resources Price Information about how prices are encoded in the DSP's web resources","excerpt":"API reference overview In this section of the documentation, we detail the web resources that are available through the REST API of Mopedo DSP applications. It's by modifying the contents of these resources that we can instruct the DSP application ho","tags":"","url":"/Mopedo%20DSP/Developer%20guides/API%20reference/API%20reference%20overview"},{"title":"Datetime","text":"Datetime (ISO 8601) An ISO 8601 datetime is a string that encodes a date and time according to the ISO 8601 standard. The date and time: Is encoded into the following ISO 8601 string: ISO 8601 datetimes can include an optional time zone designator. If not present, the DSP will assume that the time is expressed in the UTC time format. The DSP writes UTC datetimes in JSON output, for example: Z is the zone designator for the zero UTC offset according to ISO 8601.","excerpt":"Datetime (ISO 8601) An ISO 8601 datetime is a string that encodes a date and time according to the ISO 8601 standard. The date and time: Is encoded into the following ISO 8601 string: ISO 8601 datetimes can include an optional time zone designator. I","tags":"","url":"/Mopedo%20DSP/Developer%20guides/API%20reference/Datetime"},{"title":"ErrorLog","text":"ErrorLog The ErrorLog resource contains errors that have been encountered during the DSP runtime. It's useful for remote troubleshooting and debugging and when sending bug reports to Mopedo. Format Property name | Type | Description\n------------- | ------------------------- | --------------------------------------------------------\nTime | datetime | The date and time for the error\nLevel | string | The error level, either \"Warn\", \"Error\" or \"Fatal\"\nMessage | string | The error message, including stack trace","excerpt":"ErrorLog The ErrorLog resource contains errors that have been encountered during the DSP runtime. It's useful for remote troubleshooting and debugging and when sending bug reports to Mopedo. Format Property name | Type | Description\n------------- | -","tags":"","url":"/Mopedo%20DSP/Developer%20guides/API%20reference/ErrorLog"},{"title":"Operator","text":"Operator The Operator resource contains all valid operators for use in bid rule Condition entities. Format Property name | Type | Description\n------------- | -------- | -----------------------------------------------\nOp | string | The operator string used in a Condition\nInfo | string | A description of the operator and how to use it Example","excerpt":"Operator The Operator resource contains all valid operators for use in bid rule Condition entities. Format Property name | Type | Description\n------------- | -------- | -----------------------------------------------\nOp | string | The operator string","tags":"","url":"/Mopedo%20DSP/Developer%20guides/API%20reference/Operator"},{"title":"Price","text":"Price To express prices in different currencies, the DSP uses a special Price object. Format Properties marked in bold are required. Property name | Type | Description\n------------- | ----------------- | ---------------------------------------------------------------------------------------------------------------\nAmount | 128-bit decimal | The amount of the currency\nCurrency | string | An ISO 4217 code representing the currency, e.g. \"SEK\"\nCPM | boolean | Whether this Price is encoded as a CPM price or not CPM stands for cost per mille, literally cost per thousand, and is a common way to talk about prices in programmatic advertising, both from a technological perspective and when making marketing decisions. When placing bids on advertising inventory online, bidders express the amount they are willing to pay with a number and a currency, for example 15 USD. When they do so, however, they do not mean 15 US dollars, but instead 0.015 USD, or 1.5 cents. Or in other words, it's common practice to express bid prices not as the price of one impression, but the price of 1000 such impressions. The bid price encodes the cost of 1000 impressions, hence cost per thousand. Because of this, the DSP needs a good way to distinguish these kinds of prices from others, where we by 15 USD mean 15 actual US dollars. For this, Price has the CPM property, that is true if the price expressed is a CPM price and false if not. These two Price objects encode the same value: 15.25 US dollars. For a concept as simple as CPM, it can be suprisingly confusing when working with prices programmatically, for example from an external application that speaks to the DSP over the REST API. The best way to disambiguate prices, so we can know for sure what the Amount values are supposed to encode in a given context, is to have a helper function that converts all prices to a common known format, for example non-CPM, before working with them. This way we know that all prices are in the same format, and converted when necessary.","excerpt":"Price To express prices in different currencies, the DSP uses a special Price object. Format Properties marked in bold are required. Property name | Type | Description\n------------- | ----------------- | ----------------------------------------------","tags":"","url":"/Mopedo%20DSP/Developer%20guides/API%20reference/Price"},{"title":"Settings","text":"Settings The Settings resource contains all settings currently used by the DSP. These are read from the configuration file on start-up. Format Property name | Type | Description\n----------------------------- | --------------------- | ----------------------------------------------------------------------------------------------------------------------------------\nSeatId | string (read-only) | The seat id used by the DSP. Provided by Mopedo\nEmail | string (read-only) | The email address registered for this DSP\nRESTPort | integer (read-only) | The port where the REST API is registered\nRESTUri | string (read-only) | The root uri for the REST API\nRequireApiKey | boolean (read-only) | Are API keys required in the REST API?\nAllowAllOrigins | boolean (read-only) | Are all CORS origins allowed to make requests to the REST API?\nBidRequestIP | string (read-only) | The IP address on which this DSP receives bid requests\nLocalOnly | boolean (read-only) | Is this DSP in local only mode?\nApplicationVersion | string (read-only) | The DSP application version\nBidRequestFilter | string | The current bid request filter\nRoutineUpdateIntervalMinutes | integer (read-only) | The minutes between routine runs. Default is 360\nSpendingSnapshotStoragePeriod | string (read-only) | The period setting for storage of campaign spending snapshots. Default is \"Medium\"\nDomainName | string (read-only) | The domain name of the DSP, if any\nHttpPort | integer (read-only) | The port on which this DSP receives HTTP traffic\nUdpPort | integer (read-only) | The port on which this DSP receives UDP traffic\nDefaultCurrency | string (read-only) | The default currency as defined in the configuration file\nPrivateIp | string (read-only) | The private IP address of the DSP server\nPublicIp | string (read-only) | The public IP address of the DSP server","excerpt":"Settings The Settings resource contains all settings currently used by the DSP. These are read from the configuration file on start-up. Format Property name | Type | Description\n----------------------------- | --------------------- | ----------------","tags":"","url":"/Mopedo%20DSP/Developer%20guides/API%20reference/Settings"},{"title":"Echo","text":"Echo RESTar.Echo is a test and utility resource that simply returns the request URI conditions as an object, where conditions keys are property names, and condition values are property values. Example:","excerpt":"Echo RESTar.Echo is a test and utility resource that simply returns the request URI conditions as an object, where conditions keys are property names, and condition values are property values. Example:","tags":"","url":"/RESTar/Built-in%20resources/RESTar/Echo"},{"title":"JavaScript tag","text":"JavaScript tag The Mopedo JavaScript tag is a piece of JavaScript code that allows buyers to assign unique identifiers to website visitors, and communicate said identifiers with sell-side partners, so that the identities of visitors may be known at a later stage for ad retargeting purposes. It commonly consists of two HTML ","excerpt":"JavaScript tag The Mopedo JavaScript tag is a piece of JavaScript code that allows buyers to assign unique identifiers to website visitors, and communicate said identifiers with sell-side partners, so that the identities of visitors may be known at a","tags":"","url":"/Mopedo%20DSP/Developer%20guides/API%20reference/JavaScript%20tag"},{"title":"Aggregator","text":"Aggregator The Aggregator resource is used to create custom aggregated datasets from potentially multiple requests to the web resources of a RESTar application. It accepts a request template as input – which is included as body of GET requests. It then parses the request template and makes internal API requests for all request literals contained in the template. Then the results from these API requests, which is either an object array (for GET requests) or an integer (for REPORT requests), are substituted for t he request literals in the request template. Finally the populated request template is returned as output and sent back to the client. Simple example For this example, we use the RESTar demo service. generate a dynamic object containing the results of a number of other internal requests. It's useful for generating reports of arbitrary format without sending multiple requests and stitching together the responses. The resource expects an object template to be given in GET requests. Using simple markup, the template can encode internal requests, that are then substituted for the values they return in the object structure. These internal requests are written as internal URI strings starting with (optionally) an HTTP method (if no method is given, GET is used), followed by a forward slash ('/') followed by a resource specifier or macro, conditions and so on. Non-URI values in the template are simply ignored and returned in the output as-is. Example","excerpt":"Aggregator The Aggregator resource is used to create custom aggregated datasets from potentially multiple requests to the web resources of a RESTar application. It accepts a request template as input – which is included as body of GET requests. It th","tags":"","url":"/RESTar/Built-in%20resources/RESTar/Aggregator"},{"title":"AvailableResource","text":"AvailableResource AvailableResource is a meta-resource that contains the available resources for the current consumer. The entities contained in the output from a GET request to AvailableResource, and the values of their Methods properties, are decided by the API key used in the request (if keys are required for the service). It's the default resource for HTTP requests, used if no resource locator is provided in the request URI. Format Property name | Type | Description\n:------------ | :------------------ | :--------------------------------------------------------------------------------------------------------------------\nName | string | The name of the resource\nDescription | string | The description of the resource\nMethods | array of string | The methods available for the resource (for the current API key)\nKind | string | The kind of the resource, for example EntityResource\nViews | array of ViewInfo | The views of the resource (only for entity resources) Example","excerpt":"AvailableResource AvailableResource is a meta-resource that contains the available resources for the current consumer. The entities contained in the output from a GET request to AvailableResource, and the values of their Methods properties, are decid","tags":"","url":"/RESTar/Built-in%20resources/RESTar/AvailableResource"},{"title":"Help","text":"Help The Help resource contains merely a link to the Consuming a RESTar API section of this documentation. Example","excerpt":"Help The Help resource contains merely a link to the Consuming a RESTar API section of this documentation. Example","tags":"","url":"/RESTar/Built-in%20resources/RESTar/Help"},{"title":"Console","text":"Console The Console resource records all network activity to and from the RESTar API of the given RESTar application. The data is transient, and the client can decide the level of detail in the data feed. Use Console when debugging connections from external applications. Properties The Console resource has the following properties: Property name | Type | Default value | Description\n--------------- | --------- | ------------- | ----------------------------------------------------------------------------------------\nFormat | enum | \"Line\" | The format of the output feed. Can be \"Line\" or \"JSON\"\nIncludeClient | boolean | true | Should the client be included in the output feed? Default is true\nIncludeHeaders | boolean | false | Should response headers be included in the output feed? Default is false\nIncludeContent | boolean | false | Should content (e.g. response bodies) be included in the output feed? Default is false\nStatus | string | \"PAUSED\" | The current status of the console, can be \"PAUSED\" or \"OPEN\"\nShowWelcomeText | boolean | true | Should the terminal print a welcome message on launch?","excerpt":"Console The Console resource records all network activity to and from the RESTar API of the given RESTar application. The data is transient, and the client can decide the level of detail in the data feed. Use Console when debugging connections from e","tags":"","url":"/RESTar/Built-in%20resources/RESTar.Admin/Console"},{"title":"DatabaseIndex","text":"DatabaseIndex The Starcounter in-memory database needs to have proper database indexes set up for queries to work as fast as possible. RESTar uses Starcounter SQL to query database tables, which means that indexes are as important as in other Starcounter applications. Should the administrator need to optimize any queries on large resources for speed – adding and index can greatly improve performance. Format Property name | Type | Description\n------------- | -------------------- | -----------------------------------------------------------\nName | string | A name for the index. Needs to be unique.\nResourceName | string | The name of the resource on which this index is registered.\nProvider | string (read-only) | The resource provider that registered this index.\nColumns | array of Column | The column tuple registered in this index. Column Format: Property name | Type | Description\n------------- | --------- | ------------------------------------------------------------------------\nName | string | The name of the column (property) to include in the index.\nDescending | boolean | Should this index be in decending order? Default is false (ascending). Indexes are registered for a resource on tuple of columns, corresponding with the properties of the resource. For each column, we can decide the direction of the index, which can affect the speed of some query result ordering. For more information about Starcounter database indexes, see the Starcounter documentation. Example This is an example from online advertising. A bid request is a trading opportunity where some online advertising inventory is made available for bidding from e.g. advertisers. These opportunities are pushed to a RESTar application, and made available for API consumers in a resource Mopedo.Database.BidRequest. It's a large resource, containing millions of entities. Now we would like to get the 100 latest bid requests every minute, to generate a live view of the current trading opportunities. In this live view we will, for example, display site domains and device information for recent bid requests. For this we would like to use the following GET request: By making a GET request to /databaseindex we can see that there is no index for the Time column in the Mopedo.Database.BidRequest resource. This means that these GET requests could greatly benefit from having a new index registered for this database column. To register an appropriate index, we use this request:","excerpt":"DatabaseIndex The Starcounter in-memory database needs to have proper database indexes set up for queries to work as fast as possible. RESTar uses Starcounter SQL to query database tables, which means that indexes are as important as in other Starcou","tags":"","url":"/RESTar/Built-in%20resources/RESTar.Admin/DatabaseIndex"},{"title":"Error","text":"Error When the REST API aborts operations due to some error, information about the error is stored in the Error resource. Error entities contain information to help debug requests and resources, and are useful when encountering unknown errors. Erronous responses will contain a link to the corresponding Error entity in the ErrorInfo header for easy traceability. Format Property name | Type | Description\n------------- | ---------------------------- | --------------------------------------------------\nId | string | The ID of the Error\nTime | datetime | The date and time when the Error was encountered\nResourceName | string | The resource that threw the exception\nAction | string | The action that failed (e.g. the method GET)\nErrorCode | ErrorCode | The ErrorCode of the Error\nStackTrace | string | The stack trace of the encountered exception\nMessage | string | The message of the encountered exception\nUri | string | The uri of the request\nHeaders | string | The headers of the request\nBody | string | The body of the request Example Request: Response: Error lookup request: Error lookup response body: The StackTrace is useful to include in bug reports to developers. Also, note that the API key is hidden in the Headers property.","excerpt":"Error When the REST API aborts operations due to some error, information about the error is stored in the Error resource. Error entities contain information to help debug requests and resources, and are useful when encountering unknown errors. Errono","tags":"","url":"/RESTar/Built-in%20resources/RESTar.Admin/Error"},{"title":"ErrorCode","text":"ErrorCode The error codes used by RESTar have their own resource, which is useful for administrators wanting to check some error code that appears in Error entities. Example","excerpt":"ErrorCode The error codes used by RESTar have their own resource, which is useful for administrators wanting to check some error code that appears in Error entities. Example","tags":"","url":"/RESTar/Built-in%20resources/RESTar.Admin/ErrorCode"},{"title":"OutputFormat","text":"OutputFormat The OutputFormat resource contains all available JSON ouput formats used by RESTar when serializing response bodies of GET requests. An output format is essentially a JSON object tree that contains exactly one occurrence of the $data macro (not to be confused with RESTar macros in general). The $data macro is used simply to define where in the JSON tree to insert the entity array generated when serializing the output from the GET request. Format Property name | Type | Description\n------------- | -------------------- | -------------------------------------------------------------\nName | string | The name of the output format\nPattern | string | The output format pattern\nIsDefault | boolean | Is this the default output format?\nExample | object (read-only) | An example of how output would be serialized with this format Output format pattern Formats are written as escaped JSON strings, and need to contain exactly one occurrence of the $data macro – specifying where to insert the JSON array generated by the GET request. Serializing data with the pattern above would result in the following JSON object tree:","excerpt":"OutputFormat The OutputFormat resource contains all available JSON ouput formats used by RESTar when serializing response bodies of GET requests. An output format is essentially a JSON object tree that contains exactly one occurrence of the $data mac","tags":"","url":"/RESTar/Built-in%20resources/RESTar.Admin/OutputFormat"},{"title":"Advertising example","text":"Advertising example For this example, we consider an advertiser running an online shoe store, who wants to create a new advertising campaign that runs during May of 2018. The campaign will target three different customer segments: The advertiser calls these segments Unreg, RC3 and RC0 respectively. Free shipping will be offered to these customers, on items they have shown interest for in the past. The online store backend has a user database and handles the identification of users through login on the website and cookies. In this database, User entities are defined as: Property name | Type | Description\n-------------- | --------------------------------------------------------------- | -------------------------------------------------------------------------\nUUID | string | Unique user ID for the customer\nLatestPurchase | datetime | The date and time of the latest purchase\nSeg | string | The customer segment, for example Unreg\nKeywords | string | A comma separated list of interests, e.g. \"sneakers, slippers, loafers\" Server setup and security The advertiser has set up a Mopedo DSP application on a cloud location, and secured the REST API behind an HTTPS-compatible web server using their own SSL certificate. REST API requests are validated using an API key included in the Authorization header, and the web server routes the requests to the DSP using reverse proxy. In the Mopedo configuration file, the advertiser has assigned an API key, PT5oNGs3Ron9, that will be used in all REST requests. JavaScript tag and cookie syncing The advertiser inserts the Mopedo JavaScript tag on appropriate web sites, updating DSP data by making calls to a backend application that in turns sends requests to the Mopedo REST API. The Mopedo cookie is placed in the visitor's web browser when the JavaScript tag is executed, which makes it possible to identify that same user later, while receiving a bid request from the Mopedo backend. Data updates from the store backend Whenever a customer is identified, a REST API call is made from the store backend to the UserExtension resource on the DSP, updating it with the content of a user database entity – using the UUID as unique identifier. Notice how the advertiser can keep using their existing data model on the DSP, since the UserExtension resource is dynamic. This is how one of these REST requests look: Batch import of existing users The advertiser also has a couple of thousand users that have not yet been assigned a Mopedo UserId (they were added before the Mopedo DSP was set up). All these users can be batch imported to the DSP now and then updated with a UserId (using PUT with UUID as unique ID) later. To do so, the advertiser makes the following POST request to the DSP, with a list of entities as request body. Adding ads The advertiser has decided to include 9 banner ads in the campaign, three different creatives – each scaled to three common banner sizes: 300x250, 728x90 and 160x600. An existing ad server will be used to host the ads, and the AdMarkup property of each ad contains an iframe in which the call to the ad server is specified. Below is one of the uploaded ads, including the REST API call: In this example, the advertiser uses macros to dynamically insert the banner width and height into the AdMarkup. The user's Seg property, included in data updates, is also included in the call to the ad server, which lets the ad server select the appropriate ad for the customer. This logic can be implemented in many ways, depending on how the ad server is set up Setting up the campaign The advertiser has decided on the following logic for deciding which creative to show: Each format is added as a separate Ad, and all ads for a certain shoe category are placed in the same BidTemplate. When evaluating incoming bid requests, the bidder will pick the first Ad in the BidTemplate that matches the banner dimensions. The advertiser wants to focus their marketing on their sneaker collection, hence the bid logic above, and would therefore like to place higher bids for sneaker ads than for other ads. For sneaker ads, the advertiser sets a bid price of 30 USD CPM, and for other ads, the price is 20 USD CPM. Before we upload the campaign, let us focus on the bid rules. The bidding logic above requires us to create three bid rules that will be evaluated in order. The first bid rule will contain one condition – that the string property Keywords of the bid request's User entity's Extension entity contains the string \"sneakers\". This condition would look like this: If this is true for a bid request, a bid containing a sneaker ad of appropriate dimensions should be included in the response. If that is not true, evaluation will continue to the second bid rule. The second bid rule would have two conditions, the first checking if the keywords contain \"slippers\", and the second if the Country property of the Device entity's Geo entity is equal to DE. The second condition would look like this: The third bid rule would contain only one condition checking so that the User has some Seg assignment. The condition would look like this: Without this condition, we could end up bidding on all users with the third creative. Tracking spending Come May, the campaign will go active. The DSP makes sure that the campaign stays within its budget, making it inactive whenever the daily or total spending is reached. The advertiser can manually pause the campaign by setting the Paused flag to true. To make campaigns successful, it's also important to keep track of spending and adjust bid prices if needed – using spending reports to analyze spending at different times, and pushing updates to campaigns to increase or decrease the purchased volume.","excerpt":"Advertising example For this example, we consider an advertiser running an online shoe store, who wants to create a new advertising campaign that runs during May of 2018. The campaign will target three different customer segments: The advertiser call","tags":"","url":"/Mopedo%20DSP/Feature%20guides/Advertising%20example"},{"title":"PropertyCache","text":"PropertyCache The PropertyCache resource contains all the types and properties discovered by RESTar while working with the resources of the current RESTar application. It's useful when debugging RESTar applications. Format Property name | Type | Description\n------------- | ----------------- | --------------------------------------------------------------\nType | string | The name of the type for which the properties have been cached\nProperties | array of object | The properties discovered for this type","excerpt":"PropertyCache The PropertyCache resource contains all the types and properties discovered by RESTar while working with the resources of the current RESTar application. It's useful when debugging RESTar applications. Format Property name | Type | Desc","tags":"","url":"/RESTar/Built-in%20resources/RESTar.Admin/PropertyCache"},{"title":"Protocol","text":"Protocol The Protocol resource lists all protocol providers that have been added to the current RESTar application, as well as their respective available input and output content types. The RESTar protocol is always enabled, but others – such as OData – can be added by the developer. See this section of the documentation for more information on how to add custom protocol providers. Format Property name | Type | Description\n------------- | -------------------------- | --------------------------------------------\nName | string | The name of the protocol\nIdentifier | string | A unique identifier for the protocol\nIsDefault | boolean | Is this the default protocol?\nContentTypes | array of ContentTypeInfo | The content types supported in this protocol ContentTypeInfo ContentTypeInfo objects describe content types that are available for some protocol in a RESTar application. Property name | Type | Description\n------------- | ----------------- | -----------------------------------------------------------------------------------\nName | string | The name of the content type\nMimeType | string | The MIME type string of the content type\nCanRead | boolean | Can the given protocol read from requests using this content type?\nCanWrite | boolean | Can the given protocol write to responses using this content type?\nBindings | array of string | The available header values that can be used to bind a request to this content type Example","excerpt":"Protocol The Protocol resource lists all protocol providers that have been added to the current RESTar application, as well as their respective available input and output content types. The RESTar protocol is always enabled, but others – such as ODat","tags":"","url":"/RESTar/Built-in%20resources/RESTar.Admin/Protocol"},{"title":"Resource","text":"Resource Resource is a meta-resource that contains entities that correspond to the resources currently registered in the REST API. All resources have a Resource entity describing it. Format Property name | Type | Description\n-------------- | ------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------\nName | string (read-only) | The name of the resource\nAlias | string | The alias of the resource, if any\nDescription | string (read-only) | The description of the resource\nEnabledMethods | array of Method (read-only) | The methods that are enabled for the resource\nEditable | boolean (read-only) | Is this resource editable?\nIsInternal | boolean (read-only) | Is this resource only available internally?\nType | string (read-only) | The .NET type registered for this resource\nViews | array of ViewInfo(read-only) | The views registered for this resource\nProvider | string (read-only) | The name of the ResourceProvider that generated this resource\nKind | ResourceKind (read-only) | The kind of the resource, for example EntityResource\nInnerResources | array if Resource (read-only) | Resources declared within the scope of this resource To get all resources currently registered by the server: To list all resource names only: Adding resources Resources can be added during runtime by calling any procedural resource controller, for example the built-in RESTar.Dynamic.Resource resource.","excerpt":"Resource Resource is a meta-resource that contains entities that correspond to the resources currently registered in the REST API. All resources have a Resource entity describing it. Format Property name | Type | Description\n-------------- | --------","tags":"","url":"/RESTar/Built-in%20resources/RESTar.Admin/Resource"},{"title":"Settings","text":"Settings The Settings resource gives access to the settings of the REST API itself. We can, for example, see the URI of the REST API, or change whether output JSON should be serialized with pretty printing or not. Format Property name | Type | Description\n---------------- | ------------- | -----------------------------------------------------------------------------\nPort | integer | The port of the RESTar REST API\nUri | string | The URI of the RESTar REST API\nPrettyPrint | boolean | Will JSON be serialized with pretty print? (indented JSON)\nLineEndings | LineEndings | The line endings to use when writing JSON\nResourcesPath | string | The path where resources are available\nDocumentationURL | string | The URL of the RESTar documentation\nDaysToSaveErrors | integer | The number of days to store errors in the RESTar.Error resource","excerpt":"Settings The Settings resource gives access to the settings of the REST API itself. We can, for example, see the URI of the REST API, or change whether output JSON should be serialized with pretty printing or not. Format Property name | Type | Descri","tags":"","url":"/RESTar/Built-in%20resources/RESTar.Admin/Settings"},{"title":"ResourceAlias","text":"ResourceAlias The ResourceAlias resource includes all the aliases that have been assigned to some resource. To add a new alias to some resource, use the Alias property of the corresponding RESTar.Admin.Resource entity. Only GET and DELETE are available for the ResourceAlias resource. Format Property name | Type | Description\n------------- | -------- | ---------------------------------------------------\nAlias | string | The alias string\nResource | string | The name of the resource for which this is an alias","excerpt":"ResourceAlias The ResourceAlias resource includes all the aliases that have been assigned to some resource. To add a new alias to some resource, use the Alias property of the corresponding RESTar.Admin.Resource entity. Only GET and DELETE are availab","tags":"","url":"/RESTar/Built-in%20resources/RESTar.Admin/ResourceAlias"},{"title":"Schema","text":"Schema The Schema resource lets you print the schema for another resource. The schema contains names for all properties and types (C# namespaces and names) for the types used. Example","excerpt":"Schema The Schema resource lets you print the schema for another resource. The schema contains names for all properties and types (C# namespaces and names) for the types used. Example","tags":"","url":"/RESTar/Built-in%20resources/RESTar.Admin/Schema"},{"title":"ResourceProfile","text":"ResourceProfile The ResourceProfile resource gives support for profiling memory usage and calculating the sizes of Starcounter database tables, and other resources that support profiling. In the case of Starcounter database tables, it uses a simple algorithm for estimating table sizes, and should not be considered a valid absolute size calculation. It's, however, useful for determining the relative sizes of tables. Format Property name | Type | Description\n---------------- | -------------- | -----------------------------------------------------------------------\nResource | string | The name of the profiled resource\nNumberOfEntities | string | The number of entities in the resource\nApproximateSize | ResourceSize | An approximation of the resource size in memory or on disk\nSampleSize | string | The size of the sample used to generate the resource size approximation ResourceSize Property name | Type | Description\n------------- | --------- | ---------------------\nBytes | integer | The size in bytes\nKB | float | The size in kilobytes\nMB | float | The size in megabytes\nGB | float | The size in gigabytes","excerpt":"ResourceProfile The ResourceProfile resource gives support for profiling memory usage and calculating the sizes of Starcounter database tables, and other resources that support profiling. In the case of Starcounter database tables, it uses a simple a","tags":"","url":"/RESTar/Built-in%20resources/RESTar.Admin/ResourceProfile"},{"title":"TermCache","text":"TermCache RESTar caches the terms (parsed property locators) used in conditions and meta-conditions to speed up request handling. As an advanced administration feature, the TermCache can be used to control and debug this cache. Format: Property name | Type | Description\n------------- | ----------------- | -------------------------------------\nType | string | The type on which the terms is cached\nTerms | array of string | The terms cached for the type","excerpt":"TermCache RESTar caches the terms (parsed property locators) used in conditions and meta-conditions to speed up request handling. As an advanced administration feature, the TermCache can be used to control and debug this cache. Format: Property name ","tags":"","url":"/RESTar/Built-in%20resources/RESTar.Admin/TermCache"},{"title":"Utilities","text":"Utilities The Utilities is a terminal resource that can trigger operations useful for administrators. Currently, the only available option in the resource is ReloadConfigFile, which reloads the configuration file and loads API keys and allowed CORS origins.","excerpt":"Utilities The Utilities is a terminal resource that can trigger operations useful for administrators. Currently, the only available option in the resource is ReloadConfigFile, which reloads the configuration file and loads API keys and allowed CORS o","tags":"","url":"/RESTar/Built-in%20resources/RESTar.Admin/Utilities"},{"title":"SetOperations","text":"SetOperations The SetOperations resource gives access to powerful set operations that work with JSON object arrays as sets of objects and objects as sets of property-value pairs. It lets the client specify a JSON tree of operations and data sources, and then returns the output as a set of objects. Use SetOperations for requests that cannot be performed using regular request components like conditions and meta-conditions. There are four operations available: Union Returns the set union (all distinct elements) of two or more input sets. Intersect Returns all entities that are elements in all input sets (two or more). Except Returns all the entities from a first set that are not elements of a second set. Map Runs each entity of an input set through a mapping function, and returns the union of all outputs. SetOperations is designed to only work with GET requests, and operations are specified in the form of a JSON object tree that is included in the body of the request. This request body must conform to the following grammar (EBNF): The syntax of request URIs is defined here. See the examples below, for instances of the above grammar. A set of objects, unlike a list, cannot contain multiple objects with (1) the same number of properties, (2) the same property names and (3) the same values for the respective properties. These objects are considered duplicates and are dropped. All the request examples below work with our demo service, if you want to try things out yourself. Example 1: The request above will find all Superhero entities where the Gender property has the value \"Female\", and perform a set union with all Superhero entities that has the HasSecretIdentity property set to true. See the tutorial repository for the definition of the Superhero resource. Example 2 Set operations calls can be nested in input JSON object trees. Also note that the order of elements in operation argument arrays is important for the non-symmetric functions Except and Map. In this example, we take the output from the previous example, and then run a set except operation on it with all the Superhero entities where the YearIntroduced property is less than 1990. The resulting set is all female superheros together with all superheroes with a secret identity, but excluding all the ones that were introduced prior to 1990. Example 3 What we want to do now is to take all superhero names that begin with the letter D and collect all the years when such a superhero was introduced. We then want to take this list of years and compile a list of all female super heroes that were introduced these years. Lastly, we want to print the names of all those female superheroes in alphabetical order. OK, let's take that again – in steps:","excerpt":"SetOperations The SetOperations resource gives access to powerful set operations that work with JSON object arrays as sets of objects and objects as sets of property-value pairs. It lets the client specify a JSON tree of operations and data sources, ","tags":"","url":"/RESTar/Built-in%20resources/RESTar/SetOperations"},{"title":"WebSocket","text":"WebSocket The WebSocket resource contains all WebSockets currently connected to the RESTar application. The administator can close connected WebSockets by simply running DELETE on their corresponding object in this resource. Format Property name | Type | Description\n------------- | --------- | -----------------------------------------------------------------------------------\nId | string | The unique ID for the connection\nTerminalType | string | The name of the terminal resource type that the WebSocket is currently connected to\nTerminal | object | An object describing the current state of the terminal\nClient | object | An object describing the client connected to the terminal\nIsThis | boolean | Is this WebSocket the same as the one currently requesting the resource?","excerpt":"WebSocket The WebSocket resource contains all WebSockets currently connected to the RESTar application. The administator can close connected WebSockets by simply running DELETE on their corresponding object in this resource. Format Property name | Ty","tags":"","url":"/RESTar/Built-in%20resources/RESTar.Admin/WebSocket"},{"title":"WebhookLog","text":"WebhookLog The WebhookLog resource contains log items for instances when webhooks were triggered by events. Format Property name | Type | Description\n---------------- | --------------------------------------------------------- | -------------------------------------------------------------------------------------\nWebhookId | string | The ID of the webhook of this log item\nMethod | Method | The method of the webhook of this log item\nDestination | string | The destination of the webhook of this log item\nTime | datetime | The time when the log item was created\nIsSuccess | boolean | Does this log item encode a successful operation?\nResponseStatus | string | The response status for the outgoing HTTP request of the webhook\nBodyByteCount | integer | The number of bytes contained in the body of the outgoing HTTP request of the webhook\nWebhook (hidden) | Webhook | The webhook of this log item Hidden properties can be included in response bodies by using the add meta-condition in the request URI.","excerpt":"WebhookLog The WebhookLog resource contains log items for instances when webhooks were triggered by events. Format Property name | Type | Description\n---------------- | --------------------------------------------------------- | ---------------------","tags":"","url":"/RESTar/Built-in%20resources/RESTar.Admin/WebhookLog"},{"title":"WebhookLogSettings","text":"WebhookLogSettings The WebhookLogSettings resource contains settings for how webhook log items are handled in the RESTar application. To return to defaults, delete the single entity in this resource. Format Properties marked in bold are required. Property name | Type | Description\n------------------ | ---------------------------------------- | ----------------------------------------------------------------------\nLastCleared | datetime (read-only) | The date and time when old items was last cleared from the webhook log\nDaysToKeepLogItems | integer | The number of days to keep webhook log items","excerpt":"WebhookLogSettings The WebhookLogSettings resource contains settings for how webhook log items are handled in the RESTar application. To return to defaults, delete the single entity in this resource. Format Properties marked in bold are required. Pro","tags":"","url":"/RESTar/Built-in%20resources/RESTar.Admin/WebhookLogSettings"},{"title":"Resource","text":"RESTar.Dynamic.Resource The RESTar.Dynamic namespace contains all the procedurally generated resources that have been created for the current RESTar application. By default, the namespace contains a single resource, RESTar.Dynamic.Resource, a meta-resource that is used to create additional resources in the namespace. For an overview of dynamic resources, see this section. RESTar.Dynamic.Resource is a meta-resource that contains entities representing all procedurally created resources (runtime resources) for the current RESTar application. Each entity in the resource corresponds with a dynamic Starcounter table created using the Dynamit library. Format The format of RESTar.Dynamic.Resource is the same as for RESTar.Admin.Resource","excerpt":"RESTar.Dynamic.Resource The RESTar.Dynamic namespace contains all the procedurally generated resources that have been created for the current RESTar application. By default, the namespace contains a single resource, RESTar.Dynamic.Resource, a meta-re","tags":"","url":"/RESTar/Built-in%20resources/RESTar.Dynamic/Resource"},{"title":"Conditions","text":"Conditions Conditions are made up of three parts: a property locator, an operator and a value literal. They encode predicates that are either true or false of entities in the selected resource. Property locators A property locator is a string used to locate a property in a resource entity. Dot notation is used to access the contents of inner objects. If entities in a resource User contain ids, names, accounts and email addresses, and accounts contain account numbers, we can imagine using the following property locators in requests. Property locators are case-insensitive. Examples: Operators The REST API supports the following six operators in conditions: Equals: the two values are the same Not equals: the two values are different Less than: the two values are numbers or datetimes and the first is less than the second, or the two values are strings and the first is alphabetically sorted ahead of the second Greater than: the two values are numbers or datetimes and the first is greater than the second, or the two values are strings and the second is alphabetically sorted ahead of the first Less than or equals: the two values are numbers or datetimes, and the first // is less than or equal to the second, or the two values are strings and the // first is aphabetically sorted equally to or ahead of the second Greater than or equals: the two values are numbers or datetimes and the // first is greater than or equal to the second, or the two values are strings // and the second is alphabetically sorted equally to or ahead of the first Value literal The value literal is a string that encodes some value. RESTar will parse value literals and find the correct data type for the value. An error message is then returned if there is a type mismatch against the resource property specified by the property locator. To force the value literal to be handled as a string, when it would otherwise be understood as, for example, a number – wrap it in quotation marks. For example, 123 would be parsed as an integer. If we want to encode the string \"123\" in a value literal, we can surround the literal with \"-characters or '-characters in the URI. Apart from the usual convention regarding URI-safe characters, the following characters are reserved by RESTar, and always need to be escaped if used in value literals: Character | Use instead\n--------- | -----------\n! | %21 Always URI encode value literal that contain special characters Value literals are case-sensitive. Examples","excerpt":"Conditions Conditions are made up of three parts: a property locator, an operator and a value literal. They encode predicates that are either true or false of entities in the selected resource. Property locators A property locator is a string used to","tags":"","url":"/RESTar/Consuming%20a%20RESTar%20API/URI/Conditions"},{"title":"Macro","text":"Macro Macros is a powerful feature of RESTar, that enables great flexibility when making REST requests, particularly when the REST client cannot send certain request components due to technical limitations. Macros are syntactic request templates that add pre-defined properties to incoming requests ahead of evaluation. Macros can syntactically insert the following request components ahead of evalution: Macros do not contain a method definition – the method is always kept in all calls to a macro. The same macro can be used with all methods. Format Properties marked in bold are required. Property name | Type | Description\n---------------- | ----------------------------- | --------------------------------------------------------------\nName | string | The name of the macro. Used in macro calls.\nUri | string | The URI to use in the resulting request\nBody | object or array of object | The body to use in the resulting request\nHeaders | object | The headers to use in the resulting request\nOverwriteBody | boolean | Should the macro overwrite the body of the calling request?\nOverwriteHeaders | boolean | Should the macro overwrite the headers of the calling request? Recursive macro calls It is possible to design macros that generate requests that in turn call macros – for example using the RESTar.Aggregator resource. These recursive requests can sometimes be hard to debug, but RESTar is designed to handle them. Potentially infinite recursive call loops are automatically aborted. Resource All macros have a specified resource that is inserted into the request upon macro call. The calling request will simply specify the macro name in place of the resource specifier, which will result in a call to whatever resource defined in the macro. Macro definition: Macro call: Rewritten request: View Views that are part of the Uri property will be used unless the calling request has some other view defined. Conditions The conditions specified in the macro are concatenated with and placed ahead of whatever conditions are included in the request calling the macro. Macro definition: Macro call: Rewritten request: Meta-conditions Same as for conditions, the meta-conditions specified in the macro are concatenated with and placed ahead of whatever meta-conditions are included in the request calling the macro. Macro definition: Macro call: Rewritten request: Body Macros can, optionally, define a body that is inserted into the request calling the macro. If a body is specified in the macro, it's used in the request calling the macro, unless the calling request already contains a body. If and only if OverwriteBody is set to true, macro bodies overwrite bodies included in caller requests. Bodies are given as objects directly in the macro object structure. Macro definition: Macro call: Rewritten request: Headers The macro can contain headers that are added to whatever request headers included in the request calling the macro. Headers are given as objects in the macro object structure, with the property name being the header name. Header values are always inserted as strings in the request calling the macro - regardless of data type in the macro. The only header not allowed in macros is the Authorization header. All macro requests are expected to contain their own means of authentication. If and only if OverwriteHeaders is set to true, will macro headers overwrite headers included in caller requests. Macro definition: Macro call: Rewritten request:","excerpt":"Macro Macros is a powerful feature of RESTar, that enables great flexibility when making REST requests, particularly when the REST client cannot send certain request components due to technical limitations. Macros are syntactic request templates that","tags":"","url":"/RESTar/Built-in%20resources/RESTar.Admin/Macro"},{"title":"Resource","text":"Resource Resources can be specified in the URI either by the fully qualified name, a part of the full name or by an assignable alias. The full name is always unique for each resource. The resource Mopedo.Bidding.Campaign can be referenced with only \"Campaign\" as long as no other resource name ends with \".Campaign\" or an alias \"Campaign\" is assigned to some other resource. To find all available resources' names for a RESTar appplication, make the following GET request: Views Views are optional components of resources, that lets the consumer access different representations of the same resource. A GET request to an Employee resource will, for example, return representations of all Employee entities in the resource. But if a common use case for the resource is to get the ten employees with the highest sales scores and order them by sales score, the developer can choose to implement this as a separate view, making it easier to do this query. The consumer can see what views are available for some resource by making a GET request to the AvailableResource resource. Views are specified in the URI by adding a dash (\"-\") and the view name directly after the resource specifier, for example: https://my-server.com/rest/employee-best. When writing URIs, all conditions that are available for the resource, is also available for the view. The view may also define new properties that can be used only in conditions for that view. Macros Macros are pre-defined syntactic templates for requests that enable advanced use cases, for example integration with clients that cannot send certain REST requests. To call a macro, place the macro name, preceded by a $-character, in place of the resource specifier in the URI. For more information, see how to administer macros.","excerpt":"Resource Resources can be specified in the URI either by the fully qualified name, a part of the full name or by an assignable alias. The full name is always unique for each resource. The resource Mopedo.Bidding.Campaign can be referenced with only \"","tags":"","url":"/RESTar/Consuming%20a%20RESTar%20API/URI/Resource"},{"title":"Additional operations","text":"Additional operations RESTar has built in mechanisms to handle validation of resource entities and resource-specific authorization, available to the developer by having the resource type implement the IValidatable and IAuthenticatable interfaces respectively. Entity resource validation using IValidatable The IValidatable interface has one method, IsValid(), that RESTar calls for all resources implementing IValidatable before running operations Insert and Update. If the entity resource has some validation logic that needs to be run on all entities before insertion or updating – IValidatable provides a simple way to handle invalid entities and show proper error messages to the client. Unlike the operations interfaces and IAuthenticatable below, IsValid() is not run from a static context, so references can be made to instance members. Resource-specific authentication using IAuthenticatable Sometimes it's useful to have a separate means of authentication and authorization for a given resource. RESTar API keys are appropriate for controlling access to the REST API and different resources, but should not be used for more specific authentication and authorization - for example handling user accounts that control access to some resource. IAuthenticatable is a simple interface that enables the developer to define authentication and authorization logic that is executed whenever an external REST request is made to a resource. The best way to pass authentication information to a resource is by including it in custom headers, that are then read in the Authenticate() method. These custom headers are never logged by RESTar.","excerpt":"Additional operations RESTar has built in mechanisms to handle validation of resource entities and resource-specific authorization, available to the developer by having the resource type implement the IValidatable and IAuthenticatable interfaces resp","tags":"","url":"/RESTar/Developing%20a%20RESTar%20API/Entity%20resources/Additional%20operations"},{"title":"Examples","text":"Examples Regular Starcounter database resource This entity resource is a Starcounter database class, and has all its operations defined by RESTar. All we need to do to register it as a resource is to decorate it with the RESTarAttribute attribute. Then we can make request like these: Custom entity resource This entity resource is not a Starcounter database class, or more generally – it's not decorated by any resource provider attribute. This means that we have to define the operations required by the enabled methods using the operations interfaces. For this example, let's consider an entity resource that works as an interface for MyStarcounterResource. See working with requests and conditions for more about how to design the individual operations.","excerpt":"Examples Regular Starcounter database resource This entity resource is a Starcounter database class, and has all its operations defined by RESTar. All we need to do to register it as a resource is to decorate it with the RESTarAttribute attribute. Th","tags":"","url":"/RESTar/Developing%20a%20RESTar%20API/Entity%20resources/Examples"},{"title":"Notes on Excel","text":"Notes on Excel Excel representations of entity resources differ from JSON representations in one important regard – the inability to encode inner entities in-line with other properties. RESTar has various ways of dealing with this limitation. When clients make GET requests to entity resources that have inner objects, and ask the server to use Excel as the representation format, RESTar will automatically reduce the inner object using their ToString() method, if no other reduce function is supplied in the entity resource definition. You can specify a custom Excel reduce function for an entity resource property by defining a method in the entity resource's definition and providing the name of that method in the excelReducer parameter of the RESTarMemberAttribute constructor for that property. Example using excelReducer: Sample Excel output from MyResource: AString | AnInt | AnObject\n------------------- | ----- | -------------------------------\nA fine string value | 42 | Name: Objecty McObject, Id: ABC","excerpt":"Notes on Excel Excel representations of entity resources differ from JSON representations in one important regard – the inability to encode inner entities in-line with other properties. RESTar has various ways of dealing with this limitation. When cl","tags":"","url":"/RESTar/Developing%20a%20RESTar%20API/Entity%20resources/Notes%20on%20Excel"},{"title":"Working with requests and conditions","text":"Working with requests and conditions This article does not exist yet! Please check back soon","excerpt":"Working with requests and conditions This article does not exist yet! Please check back soon","tags":"","url":"/RESTar/Developing%20a%20RESTar%20API/Entity%20resources/Working%20with%20requests%20and%20conditions"},{"title":"Introduction","text":"Building entity resources Entity resources are resources modelled as sets of entities, where each entity has a set of properties consisting of a key and a value. By using REST and operations like GET, POST and DELETE, we can manipulate the contents of entity resources and get representations of them, for example in JSON. Registering entity resources Entity resources – like all RESTar resources – are .NET classes, and the entities themselves are, not surprisingly, instances of these classes. There are two ways to register a class as an entity resource in RESTar: The easiest way to make an existing class, for example a Starcounter database class, work as a RESTar resource is to simply decorate it with the RESTarAttribute attribute and assign the REST methods we want to make available as parameters to its constructor. The resource is then registered when the application calls [RESTarConfig.Init()]() is called, and made available for REST requests. Sometimes, however, we cannot make code changes in the definition of the class we want to use as a resource, or we do not want a dependency from that assembly to RESTar. In those cases, we can register resources by subclassing the abstract generic ResourceWrapper class. Here the HR_EmployeeContact class is registered as a RESTar resource. It's the HR_EmployeeContact class that will define the members of the resource, for example. The name, namespace and operations of the resource, however, is taken from the wrapper class, in this case Employee. RESTar always require operation definitions for the methods provided in the RESTarAttribute constructor. These operations are used to, for example, select existing entities in the resource and insert new ones. There are two ways to assign operations to a RESTar resource. By assigning a resource provider attribute to its resource declaration, and letting the resource provider assign its default operations. This is what we do in the examples above, since the DatabaseAttribute attribute is a resource provider attribute in RESTar. When we combine the DatabaseAttribute and RESTarAttribute in a resource declaration, we assign the default operation implementations for Starcounter database types to the resource. By creating a custom operation implementation by having the .NET class implement one or more operations interfaces. This is how we override the operations defined by a resource provider, or define operations if the resource has no resource provider attribute. There are five operations that are used by RESTar when evaluating requests. These should not be confused with the REST methods. RESTar use these operations to implement the semantics of REST methods. When executing RESTarConfig.Init(), RESTar will check so that all operations needed for the methods provided in the RESTarAttribute constructor are defined. If not, it will throw a runtime exception. Used in GET, PATCH, PUT and DELETE. Select gets a set of entities from a data storage backend that satisfy certain conditions provided in the request, and returns them. Used in POST and PUT. Takes a set of entities and inserts them into the data storage backend, and returns the number of entities successfully inserted. Used in PATCH and PUT. Takes a set of entities and updates their corresponding entities in the data storage backend, and returns the number of entities successfully updated. Used in DELETE. Takes a set of entities and deletes them from the data storage backend, and returns the number of entities successfully deleted. Used in REPORT requests. Selects and counts entities in the storage backend. If no Count operation is implemented for a resource, RESTar will simply call Select and count the entities in the returned IEnumerable. Note: when implementing Count, we need to take the Distinct meta-condition into account. RESTar references the operation definitions from the interface implementations using delegates, and all calls to them are from a static context – meaning that the this reference technically available from the instance methods defined by the interfaces above will always be null. Always treat operations interface method implementations as static methods when defining operations.","excerpt":"Building entity resources Entity resources are resources modelled as sets of entities, where each entity has a set of properties consisting of a key and a value. By using REST and operations like GET, POST and DELETE, we can manipulate the contents o","tags":"","url":"/RESTar/Developing%20a%20RESTar%20API/Entity%20resources/Introduction"},{"title":"Resource providers","text":"Resource providers As we have seen in these articles, the concept of an entity resource is general enough to encompass all kinds of data structures, as long as they can represent themselves as sets of entities. A MySQL database table, for example, can be used as a RESTar entity resource, and interacted with using the same kinds of requests as native Starcounter tables. All we need to do to make that work is to register a resource like this: This works well, but it puts a lot of responsibility on the developer designing the entity resource. A better way to create a RESTar integration with some data technology, for example MySQL, is to create a resource provider for it, that defines the default operations for interaction with MySQL databases. This way, we can have a simple and organized way for developers to add MySQL database tables to their RESTar applications, without them defining Select, Insert, Update and Delete methods for each of these resources. Instead, developers can declare MySQL resources like this: All resource providers have a resource provider attribute that is used to label the class definitions that should be claimed by the resource provider. In the example above, our MySQL resource provider has a MySQLAttribute attribute type that is used in MySQL resource declarations. This syntax should be familiar to you if you have seen how Starcounter resources are registered. The Starcounter.DatabaseAttribute is, in fact, a RESTar resource provider attribute, that binds a resource to the default operations for Starcounter database classes. By default, RESTar contains the following resource providers: So classes that are not Starcounter database tables need to either define their own operations, or be bound to some custom resource provider. See also: RESTar.SQLite – an SQLite resource provider Building a custom resource provider To implement a custom resource provider, create a new class that inherits from RESTar.ResourceProvider where T is an optional shared base class for all resource types provided by the resource provider. If there is no such base class, simply make your class ResourceProvider. Then define a class inheriting from System.Attribute, to use as resource provider attribute. When executing RESTarConfig.Init(), RESTar will find all entity resource declarations that are decorated with the resource provider attribute, and use your resource provider to register operations for them. You can also specify a DatabaseIndexer sub-class to use when indexing your resources (if indexing is applicable to the technology you are building support for). To use a resource provider in a RESTar application, include an instance of it in the call to RESTarConfig.Init(). See the open-source RESTar.SQLite resource provider for an example. Feel free to contact develop@mopedo.com if you need help creating a resource provider for some technology.","excerpt":"Resource providers As we have seen in these articles, the concept of an entity resource is general enough to encompass all kinds of data structures, as long as they can represent themselves as sets of entities. A MySQL database table, for example, ca","tags":"","url":"/RESTar/Developing%20a%20RESTar%20API/Entity%20resources/Resource%20providers"},{"title":"Consuming terminal resources","text":"Consuming terminal resources Terminal resources are small single-purpose console applications that can be launched and closed by REST clients. We interact with terminal resources using the WebSocket protocol, and to launch a terminal resource, we make a GET request to the given resource, and include a WebSocket handshake – so that the server can initiate a WebSocket connection for the terminal. The easiest way to initiate a WebSocket connection with a RESTar API while testing, is to use a command line tool like wscat, but something like this Chrome extension works fine too if you prefer to work with a web browser. To test things out, let's make a request to the RESTar.Shell terminal resource on our demo service. For this we can use this wscat command: For clients that do not support sending headers with WebSocket requests, which includes the Chrome extension mentioned above, use this URI instead: This will launch the RESTar.Shell terminal resource, which will let you navigate around the available resources of the server. For more information about the RESTar.Shell resource, see this documentation. General features of terminal resources Terminal resources are small, encapsulated command-line applications, that are instantiated for each request that target them. Each such instance can run independently from other instances. Each connected WebSocket has exaxly one terminal resource assigned to it at all times. RESTar will instantiate terminal resources and assign WebSockets to them – a terminal resource can never assign itself to some WebSocket. When a terminal is done with a given WebSocket connection, it must redirect it to a different terminal, for example RESTar.Shell. The Shell is the only terminal resource that can close WebSocket connections. The client can always close the terminal by either using a global command or by simply closing the WebSocket connection from their end. WebSocket headers Each WebSocket connected to RESTar has a set of headers, that are copied from the WebSocket upgrade request. In the case of the RESTar.Shell resource resource, these are also used in all subsequent requests from that resource. We can read or modify the headers of the WebSocket by using the #INFO global command. Terminal resource properties Each terminal resource declares a set of instance properties that define its state. A common use case for these properties is to define settings that determine the behavior of the terminal resource. Just like with properties of entity resources, terminal resource properties can be read-only. Properties of terminal resources should be documented along with the terminal resource. There are two ways to set the values of a terminal resource's properties. The example below will demonstrate both these methods. Let's look at the properties of the RESTar.Shell resource: Property name | Type | Description\n---------------- | --------- | ---------------------------------------------------------------------------------------------------------\nQuery | string | Determines the current location of the shell, and the URI for subsequent requests\nUnsafe | boolean | Is the shell currently in unsafe mode? (see the unsafe meta-condition)\nWriteHeaders | boolean | Should the shell include headers when writing output?\nAutoOptions | boolean | Should the shell automatically send an OPTIONS command after each successful navigation?\nAutoGet | boolean | Should the shell automatically send an GET command after each successful navigation?\nStreamBufferSize | integer | The buffer size (message size) to use with WebSocket streaming Each instance of this terminal resource will contain its own set of values for these properties. They act as the settings of the Shell instance. We can instantiate the Shell resource by making a WebSocket upgrade request with /shell as URI, and we can optionally include assignments to the terminal's properties by adding conditions to the URI. To launch a Shell instance with AutoGet and WriteHeaders both set to true, for example, we can use this URI with the WebSocket upgrade request: We can also use the #TERMINAL global command to set the properties of the current terminal once it's launched. As argument we use a JSON object describing the changes to make. To set AutoGet and WriteHeaders to true for a running Shell instance, we can run the following global command: For more information on global commands, see the next section. Global commands Global commands are text commands available in all terminal resources, that lets the client perform high-level operations such as setting terminal properties, switching terminals and get metadata about the WebSocket connection. Returns the properties of the current terminal. An optional JSON object can be used as argument to update the properties of the terminal. See this section for an example. Returns an object describing the current WebSocket connection. An optional JSON object can be used as argument to update the contents of the object. The returned object has the following properties: Property name | Type | Default value | Description\n--------------- | -------------------- | ----------------------- | --------------------------------------------------------------------------------------------------------------------------------------------\nHost | string (read-only) | \"\" | The host of the WebSocket connection\nWebSocketId | string (read-only) | \"\" | The unique ID of the WebSocket connection\nIsSSLEncrypted | boolean(read-only) | false | Is the WebSocket connection secure?\nClientIP | string (read-only) | \"0.0.0.0\" | The IP of the connected client\nConnectedAt | string (read-only) | \"0001-01-01 00:00:00\" | The date and time when the connection was established\nCurrentTerminal | string (read-only) | \"\" | The type name of the current terminal resource attached to this WebSocket\nCustomHeaders | object | {} | The custom headers for this WebSocket. Other headers, such as Authorization, cannot be viewed or modified here The content of CustomHeaders can be changed. To add a header X-MyHeader with value \"MyValue\", we can use the following global command: Running this command redirects the WebSocket to the RESTar.Shell resource. Running this command closes the WebSocket connection and disposes all attached resources. Streaming WebSocket streaming is a useful feature in RESTar, that allows any terminal resource to send an arbitrarily large dataset over a WebSocket connection. The dataset is split into multiple WebSocket messages, which are made available to the client for download. The RESTar.Shell resource, for example, uses streaming whenever the response body is larger than 16 megabytes. The streaming consists of three steps: While a response is streaming to a WebSocket client, all other activity is suspended to and from the terminal resource. When the streaming is concluded, messages from the terminal that was sent during the streaming are sent to the client. The stream manifest is represented as a JSON object that describes the process of streaming a response from the server to the client, and the current state within that process. It has the following format: Property name | Type | Description\n----------------- | ------------------ | ----------------------------------------------------------------------------------\nTotalLength | integer | The total length of the streaming response body in bytes\nBytesRemaining | integer | The number of bytes remaining to stream\nBytesStreamed | integer | The nuymber of bytes already streamed\nNrOfMessages | integer | The number of messages in the streaming job\nMessagesRemaining | integer | The number of messages left to stream\nMessagesStreamed | integer | The nymber of messages already streamed\nContentType | string | The MIME type string of the content type that the response body is encoded in\nEntityType | string | The name of the type of the entities contained in the response body\nEntityCount | integer | The number of entities contained in the response body\nMessages | array of Message | The messages of the streaming job\nCommands | array of Command | The available commands that can be used by the client to control the streaming job When streaming is initiated, the stream manifest is automatically sent back to the client. The client can then control the streaming process using the commands contained in the Commands array of the stream manifest. Property name | Type | Description\n------------- | --------- | -----------------------------------------------------------------------------\nStartIndex | integer | The start index of this message, as a location within the total response body\nLength | integer | The length of the message\nIsSent | boolean | Has this message been sent? Property name | Type | Description\n------------- | -------- | ---------------------------------\nCommand | string | The text command\nDescription | string | A description of the text command For this example, let's stream the content of the Superhero resource available the demo service. For the purpose of the demo, let's use a small buffer size of 8 KB. First, we connect, set the StreamBufferSize property of Shell and use the STREAM text command to create a stream manifest. For more information on how to use the RESTar.Shell resource, see this documentation As we can see, the current stream job has five messages, and a total length of 35116 bytes. We can also see that five commands – GET, NEXT, NEXT , MANIFEST and CLOSE – are available from here. Let's get the first message. The response above is abbreviated. When we request a message to be streamed, the stream manifest is updated accordingly. We can always get the current state of the streaming job by reprinting the manifest using the MANIFEST command.","excerpt":"Consuming terminal resources Terminal resources are small single-purpose console applications that can be launched and closed by REST clients. We interact with terminal resources using the WebSocket protocol, and to launch a terminal resource, we mak","tags":"","url":"/RESTar/Consuming%20a%20RESTar%20API/Consuming%20terminal%20resources"},{"title":"Binary resources","text":"Building binary resources Nothing here yet","excerpt":"Building binary resources Nothing here yet","tags":"","url":"/_site/RESTar/Developing%20a%20RESTar%20API/Binary%20resources"},{"title":"Content type providers","text":"Content type providers A content type provider defines serialization and deserialization operations for a content type. Content types are data formats that can be used in RESTar input and output, and using content type providers – we can add additional content types to a RESTar application. Content type providers bind logic to a MIME type, which is defined as a string, for example application/json. When receiving requests, RESTar will pick the appropriate content type provider to use when deserializing input data from the content of the Content-Type header, and the appropriate content type provider to use when serializing output data from the content of the Accept header. Included content type providers These three protocol providers are already included with RESTar. You can also list all available protocols and their content providers by making a GET request to the RESTar.Admin.Protocol resource. The JsonContentProvider is the default JSON content type provider for reading and writing JSON, and handles requests that have the following MIME types defined in their Accept or Content-Type headers: Since custom content type providers can override bindings to MIME types, a special application/restar-json is used to preserve a binding, should the client need to use the JsonContentProvider while application/json is overridden. There is a public static JsonContentProvider instance available at RESTar.Serialization.Serializers.Json, that can be used in RESTar applications to serialize, deserialize and populate RESTar JSON. The ExcelContentProvider is used to read and write Excel files. It has the following MIME type bindings: The XMLWriter can be used to write responses to XML. It can, however – unlike the other two included content type providers – not deserialize entities. It has the following MIME type bindings: Creating custom content type providers To create a custom content type provider, implement the IContentTypeProvider interface. It has the following definition: To use a custom content type provider, include an instance of it in the contentTypeProviders parameter in the call to RESTarConfig.Init().","excerpt":"Content type providers A content type provider defines serialization and deserialization operations for a content type. Content types are data formats that can be used in RESTar input and output, and using content type providers – we can add addition","tags":"","url":"/_site/RESTar/Developing%20a%20RESTar%20API/Content%20type%20providers"},{"title":"Event resources","text":"","excerpt":"","tags":"","url":"/_site/RESTar/Developing%20a%20RESTar%20API/Event%20resources"},{"title":"Introduction","text":"Introduction The main purpose of RESTar, as a software framework, is to facilitate a unified REST interface between external HTTP clients and the data that the application wants to expose, and to provide fast and powerful implementations for common tasks like request parsing, request authentication, database querying, data filtering and JSON serialization. By letting the RESTar framework deal with these complex (and boring) tasks, we can increase the level of abstraction, letting the application developer worry about less things and instead focus on the content and functionality of their respective apps. RESTar encourages a resource-oriented architecture (ROA) approach to application design, where the software engineering effort is focused around declaring and defining what is exposed to the REST API, i.e. the resources, as opposed to how it's exposed. RESTar is also designed to be easily integrated with new and existing Starcounter applications, but at the same time allow the developer to override some of the functionality to accommodate more advanced use cases. RESTar resources When building RESTar application, developers mainly work with defining resources – i.e. the data that should be available for consumption over the REST API of the RESTar application. There are four kinds of resources that can be defined in RESTar: Sets of data entities, for example rows in a database table. These entities can be filtered and serialized to some content type, for example JSON Read-only binary data streams that are delivered directly to clients Small single-purpose console applications that are consumed using WebSocket connections Events are raised by the RESTar application and can be used to trigger actions, for example webhooks Each of these have their own section of the documentation, focused on how to build them. Common to all resource definitions in RESTar is that they are declarative in nature, much due to the fact that the concept of a resource in RESTar is closely coupled with a declarative component of .NET – class declarations.","excerpt":"Introduction The main purpose of RESTar, as a software framework, is to facilitate a unified REST interface between external HTTP clients and the data that the application wants to expose, and to provide fast and powerful implementations for common t","tags":"","url":"/_site/RESTar/Developing%20a%20RESTar%20API/Introduction"},{"title":"Internal requests","text":"Internal requests A RESTar REST API is most commonly consumed by a REST client, that is – an application that speaks HTTP and JSON. Sometimes, however, it's useful to send internal requests from other parts of your Starcounter application, and interact with your entity resources without having to make unnecessary HTTP requests with string parsing and JSON serialization. If all RESTar entity resources were Starcounter database tables, this would not be a problem – since we could just interact with them directly using Db.Transact and Db.SQL. But since RESTar can have a wide variety of different resources, a unified interface for querying and manipulating them is needed. For this, we use the generic RESTar.Request class where T is the entity resource type we want to interact with. Request instances do not work with terminal types. Internal requests have the same main components as HTTP requests, but are much faster since they bypass request parsing, authentication and JSON serialization. They follow the same philosophy of RESTful web services in general – but without the HTTP layer. These are the public members of the Request class: Internal requests best practices For Starcounter database resources, RESTar will automatically execute the provided delegates inside transaction scopes, so there is no need to include transactions in inserter and updater lambdas. Another way to make internal REST requests is by using the Starcounter.Self class, but these are significantly slower, require authentication (if requireApiKey is set to true in the call to RESTarConfig.Init()), and are not as flexible in terms of type safety and error handling. Performance-wise, it's recommended to reuse Request objects whenever possible. When doing repetitive requests internally, it's best to keep a static Request object, and just replace the conditions between usages. RESTar provides a namespace RESTar.Linq, with a static class Conditions which contains useful methods for working with conditions of internal requests. Request objects can be very fast if used properly, especially for Starcounter database resources. When changes are made to their conditions, a Starcounter SQL query will be generated and cached within the Request object, which means that consecutive SQL queries for the same Request object are very fast. Request objects are frequently used internally within RESTar. Examples","excerpt":"Internal requests A RESTar REST API is most commonly consumed by a REST client, that is – an application that speaks HTTP and JSON. Sometimes, however, it's useful to send internal requests from other parts of your Starcounter application, and intera","tags":"","url":"/_site/RESTar/Developing%20a%20RESTar%20API/Internal%20requests"},{"title":"Getting started","text":"Getting started RESTar is distributed as a .NET package on NuGet, and an easy way to install it in an active Visual Studio project is by entering the following into the NuGet Package Manager console: The installation will also download some other packages that are required for RESTar to work. RESTar itself, however, is contained within a single assembly, RESTar.dll. When RESTar is installed, add a call to the RESTar.RESTarConfig.Init() method somewhere in your application logic, preferably so it runs once every time the app starts. This method will set up the RESTar HTTP handlers, and collect all your registered REST resources. Below is a simple RESTar application, picked from the RESTar Tutorial Repository: See this page for details on what can be specified in the call to RESTarConfig.Init().","excerpt":"Getting started RESTar is distributed as a .NET package on NuGet, and an easy way to install it in an active Visual Studio project is by entering the following into the NuGet Package Manager console: The installation will also download some other pac","tags":"","url":"/_site/RESTar/Developing%20a%20RESTar%20API/Getting%20started"},{"title":"Protocol providers","text":"Protocol providers A protocol provider is an add-on for RESTar that lets protocols other than the built-in protocol be used for defining the formats of API requests and responses. The built-in protocol is what is described in the Consuming a RESTar API section of the documentation. Using a custom protocol provider, however, a developer could decide to use a completely different set of URI conventions or response formats, but still use most of the inner workings of RESTar for declaring, finding, querying and manipulating resources. To create a protocol provider, make a new .NET class and have it implement the RESTar.IProtocolProvider interface. It has the following definition: To use a custom IProtocolProvider instance in a RESTar application, include it in the protocolProviders parameter of the call to RESTarConfig.Init(). See also: Content type providers. For a concrete example, see the RESTar.OData protocol provider.","excerpt":"Protocol providers A protocol provider is an add-on for RESTar that lets protocols other than the built-in protocol be used for defining the formats of API requests and responses. The built-in protocol is what is described in the Consuming a RESTar A","tags":"","url":"/_site/RESTar/Developing%20a%20RESTar%20API/Protocol%20providers"},{"title":"Terminal resources","text":"Building terminal resources RESTar supports custom terminal resources, so developers can create their own interactive WebSocket applications that are published in the REST API.","excerpt":"Building terminal resources RESTar supports custom terminal resources, so developers can create their own interactive WebSocket applications that are published in the REST API.","tags":"","url":"/_site/RESTar/Developing%20a%20RESTar%20API/Terminal%20resources"},{"title":"RESTarConfig.Init","text":"RESTarConfig.Init() This is the complete method signature for RESTarConfig.Init(): By changing the values of these parameters, you can configure RESTar to best serve your current application. port The port parameter controls which HTTP port to register the RESTar handlers on. One Starcounter HTTP handler is registered on this port for each of the following HTTP verbs: GET, POST, PATCH, PUT, DELETE, OPTIONS. uri The uri parameter is what is used for the root uri of the REST API. If the application is deployed locally, and the port parameter is set to 8282, the RESTar API will be listening for requests on http://localhost:8282/rest. requireApikey To require authentication and authorization for all requests using API keys, set this parameter to true. If set to true, it's required to include a configuration file path in the configFilePath parameter. allowAllOrigins To require the administrator of the application to whitelist all CORS origins that are allowed to make requests to this application, set the allowAllOrigins parameter to false. If set to false, it's required to include a configuration file path in the configFilePath parameter. configFilePath When either requireApikey is set to true or allowAllOrigins is set to false, RESTar needs a configuration file to read API keys and/or whitelisted CORS origins from. How to administrate API keys and CORS origins is covered in the Administering a RESTar API section, but the path to the file needs to be provided by the developer. prettyPrint The prettyPrint parameter controls whether JSON output from RESTar is \"pretty printed\", that is – indented – to increase human readability. daysToSaveErrors When the REST API aborts operations due to some error, for example a format error in the incoming request, information about the error is stored in the RESTar.Admin.Error resource. The daysToSaveErrors parameter controls after how many days the error should be deleted from the log. lineEndings By default, RESTar will use windows line endings, \\r\\n, in serialized JSON output. To change this to linux line endings, \\n, set the value of lineEndings to LineEndings.Linux. resourceProviders RESTar has support for add-ons in the form of resource providers. They provide a way to standardize RESTar operations for some data storage technology – for example SQLite. To include a resource provider in the RESTar instance, add it to a collection and assign to this parameter. protocolProviders RESTar can also take add-ons in the form of protocol providers, objects that contain the logic for parsing requests and generating responses according to some external protocol, for example OData. To include a protocol provider in the RESTar instance, add it to a collection and assign to this parameter. contentTypeProviders A third type of RESTar addon is content type providers. They add support for additional content types that can be used to read and write data from a RESTar application. Three content type providers (JSON, Excel, and XML) are already included with RESTar, but any additional providers must be added here.","excerpt":"RESTarConfig.Init() This is the complete method signature for RESTarConfig.Init(): By changing the values of these parameters, you can configure RESTar to best serve your current application. port The port parameter controls which HTTP port to regist","tags":"","url":"/_site/RESTar/Developing%20a%20RESTar%20API/RESTarConfig.Init"},{"title":"RESTarMemberAttribute","text":"RESTarMemberAttribute RESTar has built-in member reflection for resource types, which is how it defines the JSON and Excel templates that are used during serialization and deserialization and how it creates bindings between, for example, JSON representations and instances of the actual .NET classes. We can configure the reflected resource properties by decorating their declarations with the RESTarMemberAttribute attribute and including options in its constructor. The constructor for RESTarMemberAttribute has the following signature: ignore Should this property be completely ignored by RESTar? name A new name for this property that is used instead of the declared name in all representations. order The order at which this property appears when all properties are enumerated. hide Should this property be hidden in serialized output by default? It can still be added using the add meta-condition and queried against. hideIfNull Should this property be hidden in output if the value is null? Only applies to JSON output. readOnly Makes this property read-only over the REST API, even if it has a public setter. skipConditions Sets the Skip property of all conditions matched against this property to true by default, skipping all conditions that are made to this property. allowedOperators These operators will be allowed in conditions targeting this property. excelReducer The name of an optional public ToString-like method, declared in the same scope as the property, that reduces the property to an Excel-compatible string. replaceOnUpdate Should this object be replaced with a new instance on update, or reused? Applicable for types such as Dictionaries and Lists. Non-RESTar attributes that are respected We can also change how RESTar treats certain properties of resources by using the .NET standard IgnoreDataMemberAttribute and DataMemberAttribute attributes (located in the System.Runtime.Serialization namespace). Using these attributes, we can, for example, rename properties and ignore properties when serializing and deserializing from JSON (and Excel). For more information, see the Microsoft documentation. The JSON.net JsonPropertyAttribute is also respected.","excerpt":"RESTarMemberAttribute RESTar has built-in member reflection for resource types, which is how it defines the JSON and Excel templates that are used during serialization and deserialization and how it creates bindings between, for example, JSON represe","tags":"","url":"/_site/RESTar/Developing%20a%20RESTar%20API/RESTarMemberAttribute"},{"title":"Registering resources","text":"Registering resources","excerpt":"Registering resources","tags":"","url":"/_site/RESTar/Developing%20a%20RESTar%20API/Registering%20resources"},{"title":"Troubleshooting","text":"Troubleshooting This article contains some infamous problems that can occur when developing RESTar applications, and how to solve them: SCERR2143 Example: This error is almost always related to the application's weaver.ignore file. The Starcounter Weaver cannot deal with strong-named assemblies, abd we therefore need to include them in the application's weaver.ignore file. Add the following assemblies to the application's weaver.ignore file, or create a new text file called weaver.ignore in your project output folder with the content from the link. SCERR2147 Example: As far as we have found out, this can be caused by three things:","excerpt":"Troubleshooting This article contains some infamous problems that can occur when developing RESTar applications, and how to solve them: SCERR2143 Example: This error is almost always related to the application's weaver.ignore file. The Starcounter We","tags":"","url":"/_site/RESTar/Developing%20a%20RESTar%20API/Troubleshooting"},{"title":"Banner","text":"Banner Banner is not strictly a resource since it's not persistent, and not accessible directly in the API. It can still be used like a read-only data source in path expressions. It's a reference to the banner ad slot contained within the bid request, in which an Ad can be placed. If the bid request does not contain a banner ad slot, Banner will simply be null for that bid request. Format Property name | Type | Description\n------------- | --------- | --------------------------------------------------\nWidth | integer | The width of the banner ad slot\nHeight | integer | The height of the banner ad slot\nAboveTheFold | bool | Is this banner ad slot located above the fold?\nPositionRank | integer | The position rank of this banner Position ranking The PositionRank property of a Banner is used to determine the location of the banner ad slot on the web page on which it's located. The PositionRank property will have the value null if its position cannot be determined, and otherwise any of these numeric values – as defined by OpenRTB: Value | Description\n----- | -------------------------------------------------------------------------------------\n1 | Above the Fold\n2 | DEPRECATED - May or may not be initially visible depending on screen size/resolution.\n3 | Below the Fold\n4 | Header\n5 | Footer\n6 | Sidebar\n7 | Full Screen","excerpt":"Banner Banner is not strictly a resource since it's not persistent, and not accessible directly in the API. It can still be used like a read-only data source in path expressions. It's a reference to the banner ad slot contained within the bid request","tags":"","url":"/Mopedo%20DSP/Developer%20guides/API%20reference/Mopedo.Bidding/Banner"},{"title":"Ad","text":"Ad The Ad resource contains all the ads that have been added to the DSP, and is where we upload ads for use in campaigns. Ad entities can exist in the DSP without there being a campaign where they're used, and the same Ad can be used in multiple campaigns and/or be contained in many different bids, at different bid prices. Format Properties marked in bold are required. Property name | Type | Description\n---------------------------- | ---------------------------------------- | -----------------------------------------------------------------------------------------------\nAdId | string | A unique id for the ad\nBuyerId | string | An optional ID of the buyer using this ad, for reference in reports etc.\nAdType | enum | Allowed: \"banner\", \"video\" or \"native\"\nLabel | string | A describing label for the ad\nMinWidth | integer | The minimum impression width for this ad\nMaxWidth | integer | The maximum impression width for this ad\nMinHeight | integer | The minimum impression height for this ad\nMaxHeight | integer | The maximum impression height for this ad\nAdMarkup | string | The markup of the ad. Can include macros\nCategories | array of string | IAB codes for the creative\nIsValid | boolean (read-only) | True if and only if all fields have valid values\nErrors | array of Error (read-only) | The reason(s) for the ad not being valid, or empty if valid\nAutoClickTrackingEnabled | boolean | Is auto click tracking enabled?\nLandingPage | string | The landing page for click tracking. Can include macros\nDimensions | string (read-only) | A string representation of the ad dimensions\nImplementsClickTrackingMacro | boolean (read-only) | Does this ad implement click tracking? Views The Ad resource has two views: FromIds takes a comma-separated list of ad IDs, and returns their corresponding ads. Example URI: /ad-fromids/adids=ad01,ad01,ad03. Property name | Type | Description\n------------- | -------- | --------------------------------\nAdIds | string | A comma-separated list of ad IDs ForCampaign takes a campaign ID, and returns all ads currently assigned to that campaign. Example URI: /ad-forcampaign/campaignId=MyCampaign. Property name | Type | Description\n------------- | -------- | ---------------------------------------\nCampaignId | string | The ID of the campaign to fetch ads for Example We insert a new Ad with AdId \"ad01\", or update any already existing Ad with that ID. As data source we use data.json, a text file located on my desktop with the following JSON-formatted content: The Ad above is a banner ad about adventure travels in Africa, that we only want to allow banner impressions with a width of between 720 and 735 pixels and a height of between 80 and 100 pixels to be matched against. The actual dimensions of the creative, as well as the creative source itself, is described in the AdMarkup field, in this case by use of macros – see for example \"$(Banner.Width)\". By using macros, we can insert information from the impression or any other valid data source right into your markup string - which is useful for dynamically adapting the markup for a certain impression or customer. Remember to always include accurate IAB content categories for your ads! For a list of available categories, see the Mopedo.Database.IABCode resource.","excerpt":"Ad The Ad resource contains all the ads that have been added to the DSP, and is where we upload ads for use in campaigns. Ad entities can exist in the DSP without there being a campaign where they're used, and the same Ad can be used in multiple camp","tags":"","url":"/Mopedo%20DSP/Developer%20guides/API%20reference/Mopedo.Bidding/Ad"},{"title":"Broadcaster","text":"Broadcaster The Broadcaster resource represents broadcasters – servers in the Mopedo backend that provide traffic for the DSPs on the Mopedo platform. Using the Broadcaster resource, DSP administrators can inspect, connect and disconnect broadcasters. Connected broadcasters will send bid requests to the DSP, which are matched against active campaigns. If no active campaigns exist on the DSP, the bid requests are simply stored in the database and ignored by the bidder. There are two ways to connect to a broadcaster to a Mopedo DSP: All broadcasters are disconnected when the DSP application is stopped. Format Property name | Type | Description\n----------------- | ---------------------------------------- | --------------------------------------------------\nId | string (read-only) | A unique id for the broadcaster\nServiceProvider | string (read-only) | The cloud service provider hosting the broadcaster\nZone | integer (read-only) | The cloud service zone, defined by the provider\nLocation | string (read-only) | The physical location of the broadcaster server\nSSPs | array of string (read-only) | Names of the SSPs connected to this broadcaster\nLatestBroadcastAt | datetime (read-only) | Time of the latest broadcast from this broadcaster\nConnected | boolean | Is this broadcaster currently connected?","excerpt":"Broadcaster The Broadcaster resource represents broadcasters – servers in the Mopedo backend that provide traffic for the DSPs on the Mopedo platform. Using the Broadcaster resource, DSP administrators can inspect, connect and disconnect broadcasters","tags":"","url":"/Mopedo%20DSP/Developer%20guides/API%20reference/Mopedo.Bidding/Broadcaster"},{"title":"AdSpendingSnapshot","text":"AdSpendingSnapshot The DSP keeps track of bidding campaign spending using campaign spending snapshots. Each such snapshot holds data about the spending of a campaign during a given time period. The actual spending data is stored in AdSpendingSnapshot entities, that are connected to the campaign spending snapshot – one for each ad active for the given campaign during given time period. The bidding statistics of the campaign spending snapshot is calculated from each connected AdSpendingSnapshot entity. This resource exists to allow clients to consume the ad spending snapshots directly, should they – for example – want to download them to an external system for statistical analysis. For more information about how the DSP stores spending data, and how reports can be built from it, see the reporting overview. Format Properties marked in bold are required. Property name | Type | Description\n--------------------------------- | --------------------------------------------------------- | -----------------------------------------------------------------------------------------------\nCampaignSpendingSnapshot (hidden) | CampaignSpendingSnapshot | The campaign spending snapshot connected to this ad spending snapshot\nAdId (hidden) | string | The ID of the ad that this ad spending snapshot encodes spending for\nBuyerId (hidden) | string | The buyer id of the campaign that this ad spending snapshot encodes spending for\nPeriod (hidden) | string | The period of the campaign spending snapshot\nFrom (hidden) | datetime | The value of From of the campaign spending snapshot\nTo (hidden) | datetime | The value of To of the campaign spending snapshot\nCurrency (hidden) | string | The currency that this ad spending snapshot is encoded in\nNrOfBids | integer | The number of bids during the period\nNrOfWins | integer | The number of wins during the period\nNrOfClicks | integer | The number of clicks during the period\nTotalBidPrice | Price | The total bid price during the period\nAverageBidPrice | Price | The average bid price during the period\nTotalWinPrice | Price | The total win price during the period\nAverageWinPrice | Price | The average win price during the period\nWinRate | float | NrOfWins divided by NrOfBids (or 0 if there are no bids)\nClickRate | float | NrOfClicks divided by NrOfWins (or 0 if there are no wins)\nIsZero | boolean | Was there no bidding events during the period? Hidden properties can be included in response bodies by using the add meta-condition in the request URI.","excerpt":"AdSpendingSnapshot The DSP keeps track of bidding campaign spending using campaign spending snapshots. Each such snapshot holds data about the spending of a campaign during a given time period. The actual spending data is stored in AdSpendingSnapshot","tags":"","url":"/Mopedo%20DSP/Developer%20guides/API%20reference/Mopedo.Bidding/AdSpendingSnapshot"},{"title":"CampaignSpendingSnapshot","text":"CampaignSpendingSnapshot The DSP keeps track of bidding campaign spending using campaign spending snapshots. Each such snapshot holds data about the spending of a campaign during a given time period. The actual spending data is stored in AdSpendingSnapshot entities, that are connected to the campaign spending snapshot – one for each ad active for the given campaign during given time period. The bidding statistics of the campaign spending snapshot is calculated from each connected AdSpendingSnapshot entity. This resource exists to allow clients to consume the campaign spending snapshots directly, should they – for example – want to download them to an external system for statistical analysis. For more information about how the DSP stores spending data, and how reports can be built from it, see the reporting overview. Format Property name | Type | Description\n------------------- | ------------------------------------------------------ | -------------------------------------------------------------------------------------------------\nCampaignId | string | The ID of the campaign that this snapshot was created for\nBuyerId | string | The buyer ID of the campaign that this snapshot was created for\nCampaign (hidden) | Campaign | The campaign that this snapshot was created for\nCurrency (hidden) | string | The currency that the prices in this snapshot is stored using\nPeriod | string | The period of this snapshot\nFrom | datetime | The date and time of the start of the period of this snapshot\nTo | datetime | The date and time of the end of the period of this snapshot\nTotal | Statistics | The total statistics for the given period and campaign\nIsZero | boolean | Did this campaign not produce any bidding events during the given time period?\nAdSpendingSnapshots | array of AdSpendingSnapshot | The ad spending snapshot entities that hold the spending data for this campaign spending snapshot Hidden properties can be included in response bodies by using the add meta-condition in the request URI. Periods The data model for campaign spending snapshots and ad spending snapshots is nested into multiple levels of granularity, with more granular snapshots being created more often, for example every 20 minutes, and more general snapshots being created with wider time intervals, for example 14 days. The value of the Period property determines the length of the time interval during which the snapshot contains recorded spending information. Spending snapshots are automatically aggregated to more general periods over time, to enable more fine-grained spending information for recent time periods, as well as to make it fast to create reports for long-term spending. For details on how spending snapshots are aggregated over time, see the reporting overview. There are four snapshot periods: Encodes the spending of a campaign during a 20 minute period. These snapshots are created for all active campaigns at most three times an hour, at minutes 00, 20 and 40, whenever the DSP places a bid. If there, for example, is no bidding for a given campaign between 12 and 3 PM, there will be no _20min snapshots for that campaign within that timeframe. _20min snapshots provide the most granular bidding data of all snapshots, and are also the ones that are deleted first. For more information about snapshot deletion, see the reporting overview. Encodes the spending of a campaign during a 3 hour period. These snapshots are created automatically eight times a day, at hours 00:00, 03:00, 06:00, 09:00, 12:00, 15:00, 18:00 and 21:00, with data summed from all _20min snapshots within that 3 hour period. Encodes the spending of a campaign during a 24 hour period. These snapshots are created automatically every day, at 00:00 with data summed from all _3h snapshots from the previous day. Encodes the spending of a campaign during a 14 day period. These snapshots are created automatically every 14 days, at 00:00 with data summed from all _24h snapshots from the previous 14 days. The spending snapshot creation and aggregation logic is idempotent and retroactive, which means it keeps track of all snapshots that have been created, never creating duplicate snapshots, and creates snapshots retroactively for old bids and time campaigns. Since snapshots hold only IDs of ads and campaigns, they are not affected by the deletion of campaigns or ads. The debug resource Mopedo.Debug.SnapshotControls can be used to debug, recreate and reload spending snapshots from the underlying bid and win objects. The DSP will automatically create and manage spending snapshots, to make sure that all periods with bidding are accounted for. Long periods with no bidding, for a given campaign, are simply kept empty to reduce the number of created snapshots. There is, however, a decision to be made regarding how long to keep the shortest snapshots, for example _20min and _3h, given that they have already been aggregated by some more more general snapshot. Trimming these snapshots would not result in data corruption, but we would no longer be able to create granular reports for old 20 minute and 3 hour periods. To deal with this, the DSP has a SpendingSnapshotStoragePeriod setting in Mopedo.Settings that allows the administrator to control when old snapshots are trimmed. If the DSP runs many campaigns and snapshots are filling up the RAM memory, use \"Short\". If you want to be able to make granular reports, for example targeting individual 20 minute periods, on historic spending data older than 60 days, use \"Long\" or \"NoTrimming\". There are 4 possible values for SpendingSnapshotStoragePeriod, where \"Medium\" is the default value.","excerpt":"CampaignSpendingSnapshot The DSP keeps track of bidding campaign spending using campaign spending snapshots. Each such snapshot holds data about the spending of a campaign during a given time period. The actual spending data is stored in AdSpendingSn","tags":"","url":"/Mopedo%20DSP/Developer%20guides/API%20reference/Mopedo.Bidding/CampaignSpendingSnapshot"},{"title":"Now","text":"Now The Now resource can be used to print time and time zone information for the Mopedo DSP, and is also useful when setting up conditions for time-dependent bid rules. Format Property name | Type | Description\n--------------------- | ---------------------------- | --------------------------------------------------\nDate | datetime | The current date\nDay | integer | The current day (of month)\nDayOfWeek | string | The name of the current week day in lower case\nDayOfWeekNr | integer | The current week day number, 1-7. Monday = 1\nDayOfYear | integer | The current day of year, 1-365\nHour | integer | The current hour of day, 1-24\nMinute | integer | The current minute of hour, 1-60\nMonth | integer | The current month number of year, 1-12\nSecond | integer | The current second of minute, 1-60\nYear | integer | The year, e.g. 2017\nTimeOfDay | string | Time as sortable string, e.g. \"12:17:21.6553277\"\nTimeZone | string | The name of the time zone where the DSP is located\nUTCOffset | string | The UTC offset of the server's current time zone\nIsDayLightSavingsTime | boolean | Is the server's time zone currently in DST?","excerpt":"Now The Now resource can be used to print time and time zone information for the Mopedo DSP, and is also useful when setting up conditions for time-dependent bid rules. Format Property name | Type | Description\n--------------------- | ---------------","tags":"","url":"/Mopedo%20DSP/Developer%20guides/API%20reference/Mopedo.Bidding/Now"},{"title":"Click tracking","text":"Click tracking Click tracking is used by advertisers and ad exchanges to track whether ad impressions are clicked. This is a helpful measure when evaluating how well a campaign is performing. There are two ways to implement click tracking on a Mopedo DSP: Automatic click tracking Automatic click tracking makes the process easy for the advertiser – all you need to do to activate is to set AutoClickTrackingEnabled to true for a given Ad and provide a URL to the corresponding landing page in the LandingPage property. The DSP will then automatically modify the AdMarkup to notify both the DSP and the ad exchange when the ad contained in a winning bid is clicked. If the ad is clicked, the properties Clicked, ClickedAt and ClickLandingPage of the corresponding Win will provide additional information about the clicked impression – for example the time of the click and what landing page the user was forwarded to. Custom click tracking macro To manually implement click tracking, the advertiser needs to insert a click tracking macro inside the AdMarkup string of an Ad. This is standard procedure for click tracking, and allows the ad exchange to insert a dynamically generated callback URL in the markup, that allows the advertiser to redirect the user to the ad exchange – which will then redirect the user to the landing page. For more information about click tracking macros in ad markup, see this link.","excerpt":"Click tracking Click tracking is used by advertisers and ad exchanges to track whether ad impressions are clicked. This is a helpful measure when evaluating how well a campaign is performing. There are two ways to implement click tracking on a Mopedo","tags":"","url":"/Mopedo%20DSP/Developer%20guides/API%20reference/Mopedo.Bidding/Click%20tracking"},{"title":"Error","text":"Error Whenever Ad or Campaign entities contain semantic errors, for example a missing property, they will be populated with Error entities in their corresponding Errors array. Whenever IsValid is false for an Ad or Campaign, you can find the reason for it being invalid by reading the Errors list. Error is also an independent resource, so you can enumerate all errors by making a GET request directly to it. Format Property name | Type | Description\n------------- | -------- | --------------------------------------------------------------\nCode | string | The unique code for this error\nInfo | string | A description of the error\nAt | string | The location of the error within the Ad or Campaign entity","excerpt":"Error Whenever Ad or Campaign entities contain semantic errors, for example a missing property, they will be populated with Error entities in their corresponding Errors array. Whenever IsValid is false for an Ad or Campaign, you can find the reason f","tags":"","url":"/Mopedo%20DSP/Developer%20guides/API%20reference/Mopedo.Bidding/Error"},{"title":"NoBidReason","text":"NoBidReason The NoBidReason resource, and its child resources - InvalidBid, UnsupportedBanner and ClickTrackingNotSupported, are used to track and give feedback on why some bid requests are not responded to with bids. Every time the bidder finds some issue while evaluating bid requests, that the advertiser should be made aware of, entities will be created in the above-mentioned resources. Format: Property name | Type | Description\n------------- | ------------------------------------------------ | -------------------------------------------------------\nBidRequest | BidRequest | The bid request that was matched by a bid rule\nInfo | string | Information about the missed bid opportunity\nTime | datetime | The time when the missed bid opportunity was registered InvalidBid Entities are created in the InvalidBid resource whenever a bid generated by a bid template failed validation. Excluding the properties inherited from NoBidReason. Property name | Type | Description\n------------- | -------- | ----------------------------------------------\nError | string | The error code describing the validation error UnsupportedBanner The UnsupportedBanner resource keeps track of all instances where a bid request was matched by a bid rule, but there was no Ad of matching dimensions to place in the available ad slot. Finding these instances and calculating the number of missed ad placement opportunities can be useful for optimizing campaigns. To get an aggregated view of unsupported banners, use the UnsupportedBannerReport resource. Excluding the properties inherited from NoBidReason. Property name | Type | Description\n------------- | --------- | ------------------------------------------------------\nWidth | integer | The width of the unsupported ad slot\nHeight | integer | The height of the unsupported ad slot\nDimensions | string | The dimensions expressed as a string, e.g. \"250x300\" ClickTrackingNotSupported If the bid request requires bids to contain support for click tracking, but the matched Ad has no click tracking support – a new entity will be created in the ClickTrackingNotSupported resource. ClickTrackingNotSupported has the same format as the parent resource NoBidReason.","excerpt":"NoBidReason The NoBidReason resource, and its child resources - InvalidBid, UnsupportedBanner and ClickTrackingNotSupported, are used to track and give feedback on why some bid requests are not responded to with bids. Every time the bidder finds some","tags":"","url":"/Mopedo%20DSP/Developer%20guides/API%20reference/Mopedo.Bidding/NoBidReason"},{"title":"Path expressions and macros","text":"Path expressions and macros There are some resource properties in the Mopedo DSP, where it's possible to make reference to other data sources by using path expression strings. The best example is bid rule conditions, where we use path expressions as the values of the Key property. Here is the complete list of places where path expression strings can be used: Path expressions Path expressions are used to reference a property of some data source, and consist of the name of a data source, followed by names of properties divided by dots. Used to denote the User contained in a bid request Used to denote the Device contained in a bid request Used to denote the Site contained in a bid request Used to denote the User contained in a bid request Used to denote the static Now resource Path expressions are case sensitive. For more information about the properties of the above data sources, see their respective documentation. For more examples, see the advertising example section of the documentation. Macros Sometimes it's useful to insert values from path expressions straight into the AdMarkup and LandingPage strings of Ad entities. This allows us to, for example, include banner ad slot dimensions in the call to an ad server, or insert user information in the URL that is called when a banner ad is clicked. To allow this, there is support for macros in the AdMarkup and LandingPage strings. All the data sources detailed above can be used for this. Macros have the following syntax: Where is a path expression. Using macros, we can insert the banner dimensions into an iframe in AdMarkup. In the example, we also include a UID from the UserExtension object belonging to the User of the bid request in the call to the ad server.a","excerpt":"Path expressions and macros There are some resource properties in the Mopedo DSP, where it's possible to make reference to other data sources by using path expression strings. The best example is bid rule conditions, where we use path expressions as ","tags":"","url":"/Mopedo%20DSP/Developer%20guides/API%20reference/Mopedo.Bidding/Path%20expressions%20and%20macros"},{"title":"Statistics","text":"Statistics Statistics is an object that is present as property value in multiple bidding resources. It encodes bidding statistics, most commonly used to describe campaign performance during some time period. Format Property name | Type | Description\n--------------- | ---------------------- | ----------------------------------------------------------------------\nNrOfBids | integer | The number of bids encoded in this object\nNrOfWins | integer | The number of wins encoded in this object\nNrOfClicks | integer | The number of clicks encoded in this object\nWinRate | float | NrOfWins divided by NrOfBids (or 0 if there are no bids)\nClickRate | float | NrOfClicks divided by NrOfWins (or 0 if there are no wins)\nAverageBidPrice | Price | The average bid price\nTotalWinPrice | Price | The total win price\nAverageWinPrice | Price | The average win price Example Statistics are used in the Total property of CampaignSpendingSnapshot entities to encode the total spending information for a given period.","excerpt":"Statistics Statistics is an object that is present as property value in multiple bidding resources. It encodes bidding statistics, most commonly used to describe campaign performance during some time period. Format Property name | Type | Description\n","tags":"","url":"/Mopedo%20DSP/Developer%20guides/API%20reference/Mopedo.Bidding/Statistics"},{"title":"Archive overview","text":"Archive overview The DSP stores its main persistent resources in-memory in the Starcounter database, which has great performance benefits when working with short-term data. It's, for example, extremely fast to add new database rows and query the in-memory database. It's, however, not optimal for storing huge amounts of seldom accessed data over time, as this often requires more RAM memory than can be justified for this type of data. For this, a disk-based archive database is what we want, where we can offload data entities in order to free up memory. For example, every time a bid request is received from the Mopedo backend and evaluated by the DSP, a new row is added to a table in the Starcounter database that the DSP is connected to. This means that the web activity generated by the client's customers is recorded over time, but can also make the in-memory database table holding bid requests too large to manage reliably. To deal with the potentially hundreds of millions of bid requests accumulating in the database, the Mopedo DSP can move old bid requests to a SQLite based bid request archive resource called Mopedo.Archive.BidRequestArchive. Since the SQLite database is not kept in-memory, it can contain a very large number of rows without affecting the overall performance of the DSP. Archive resources The Mopedo.Archive namespace contains the following five archive resources: Routines The archiving process, which includes copying entities to archive resources and optionally deleting entities from the in-memory resources, is controlled by means of routines. Routines are scheduled operations that can archive and/or delete entities when there are either too many of them, or when they are older than a certain time. Routines are managed using the Mopedo.Archive.Routine resource.","excerpt":"Archive overview The DSP stores its main persistent resources in-memory in the Starcounter database, which has great performance benefits when working with short-term data. It's, for example, extremely fast to add new database rows and query the in-m","tags":"","url":"/Mopedo%20DSP/Developer%20guides/API%20reference/Mopedo.Archive/Archive%20overview"},{"title":"BidRequestArchive","text":"Mopedo.Archive.BidRequestArchive BidRequestArchive is the SQLite based archive resource for Mopedo.Database.BidRequest entities. To set up an archiving routine that moves bid requests to this archive, use Mopedo.Database.BidRequest as the value for the Resource property of the routine. Important: Only bid request entities themselves are archived, not the User, Device,Site, App or other entities that are referenced from BidRequest entities. These remain in the Starcounter in-memory database. Format Property name | Type | Description\n------------- | ---------------------------- | -------------------------------------------------------------------------------------\nBidRequestId | string | The ID of the bid request\nUserId | string | The UserId of the User contained in the bid request\nIP | string | The IP of the Device contained in the bid request\nSiteDomain | string | The Domain of the Site contained in the bid request\nAppDomain | string | The Domain of the App contained in the bid request\nTime | datetime | The date and time when the bid request was received","excerpt":"Mopedo.Archive.BidRequestArchive BidRequestArchive is the SQLite based archive resource for Mopedo.Database.BidRequest entities. To set up an archiving routine that moves bid requests to this archive, use Mopedo.Database.BidRequest as the value for t","tags":"","url":"/Mopedo%20DSP/Developer%20guides/API%20reference/Mopedo.Archive/BidRequestArchive"},{"title":"BidArchive","text":"Mopedo.Archive.BidArchive BidArchive is the SQLite based archive resource for Mopedo.Database.Bid entities. To set up an archiving routine that moves bids to this archive, use Mopedo.Database.Bid as the value for the Resource property of the routine. Format Property name | Type | Description\n--------------------- | ---------------------------- | -------------------------------------------------------------------------------------\nId | string | A unique ID given to this bid by the DSP\nReceiverBidResponseId | string | A unique ID given to the bid response of this bid by the DSP\nBidRequestId | string | The ID of the bid request of this bid\nUserId | string | The UserId of the User contained in the bid request\nIP | string | The IP of the Device contained in the bid request\nSiteDomain | string | The Domain of the Site contained in the bid request\nAppDomain | string | The Domain of the App contained in the bid request\nTime | datetime | The time when the bid was placed\nCampaignId | string | The id of the Campaign that generated this bid\nBuyerId | string | The buyer id of the campaign that placed this bid\nAdId | string | The id of the Ad used for this bid\nClickLandingPage | string | The landing page of the ad included in this bid (if any)\nBidPriceAmountCPM | decimal | The bid price amount, as CPM\nBidPriceCurrency | string | The currency that the bid price is expressed in","excerpt":"Mopedo.Archive.BidArchive BidArchive is the SQLite based archive resource for Mopedo.Database.Bid entities. To set up an archiving routine that moves bids to this archive, use Mopedo.Database.Bid as the value for the Resource property of the routine.","tags":"","url":"/Mopedo%20DSP/Developer%20guides/API%20reference/Mopedo.Archive/BidArchive"},{"title":"BidResponseArchive","text":"Mopedo.Archive.BidResponseArchive BidResponseArchive is the SQLite based archive resource for Mopedo.Database.BidResponse entities. To set up an archiving routine that moves bid responses to this archive, use Mopedo.Database.BidResponse as the value for the Resource property of the routine. Format Property name | Type | Description\n--------------------- | ---------------------------- | -------------------------------------------------------------------------------------\nReceiverBidResponseId | string | A unique ID given to this bid response by the DSP\nBidRequestId | string | The ID of the bid request\nUserId | string | The UserId of the User contained in the bid request\nIP | string | The IP of the Device contained in the bid request\nSiteDomain | string | The Domain of the Site contained in the bid request\nAppDomain | string | The Domain of the App contained in the bid request\nTime | datetime | The date and time when the bid request was received\nHasWin | bool | Is there a win registered for this bid response?","excerpt":"Mopedo.Archive.BidResponseArchive BidResponseArchive is the SQLite based archive resource for Mopedo.Database.BidResponse entities. To set up an archiving routine that moves bid responses to this archive, use Mopedo.Database.BidResponse as the value ","tags":"","url":"/Mopedo%20DSP/Developer%20guides/API%20reference/Mopedo.Archive/BidResponseArchive"},{"title":"BidderConsole","text":"BidderConsole BidderConsole is a terminal resource used for debugging bid rules. It posts bid rule evaluations in real-time as they happen, along with metadata such as the evaluated values for bid rule conditions. For performance reasons, it's recommended to only use BidderConsole terminals while debugging bid rules, since building the debug information will otherwise consume unnecessary system resources. Properties Property name | Type | Default value | Description\n--------------- | --------- | ------------- | ----------------------------------------------------------------\nStatus | string | \"PAUSED\" | The current status of the console, can be \"PAUSED\" or \"OPEN\"\nShowWelcomeText | boolean | true | Should the terminal print a welcome message on launch?","excerpt":"BidderConsole BidderConsole is a terminal resource used for debugging bid rules. It posts bid rule evaluations in real-time as they happen, along with metadata such as the evaluated values for bid rule conditions. For performance reasons, it's recomm","tags":"","url":"/Mopedo%20DSP/Developer%20guides/API%20reference/Mopedo.Archive/BidderConsole"},{"title":"NoBidReasonArchive","text":"Mopedo.Archive.NoBidReasonArchive NoBidReasonArchive is the SQLite based archive resource for Mopedo.Bidding.NoBidReason entities. To set up an archiving routine that moves NoBidReason entities to this archive, use Mopedo.Bidding.NoBidReason as the value for the Resource property of the routine. Format Property name | Type | Description\n------------- | ---------------------------- | ------------------------------------------------------\nType | string | The type of this NoBidReason entity\nDomain | string | The domain of the missing bid opportunity\nInfo | string | Information about the missing bid opportunity\nTime | datetime | The date and time of the missing bid opportunity\nCampaignId | string | The ID of the campaign that generated this NoBidReason\nBuyerId | string | The buyer id of the campaign\nAdId | string | The ID of the ad that generated this NoBidReason","excerpt":"Mopedo.Archive.NoBidReasonArchive NoBidReasonArchive is the SQLite based archive resource for Mopedo.Bidding.NoBidReason entities. To set up an archiving routine that moves NoBidReason entities to this archive, use Mopedo.Bidding.NoBidReason as the v","tags":"","url":"/Mopedo%20DSP/Developer%20guides/API%20reference/Mopedo.Archive/NoBidReasonArchive"},{"title":"WinArchive","text":"Mopedo.Archive.WinArchive WinArchive is the SQLite based archive resource for Mopedo.Database.Win entities. To set up an archiving routine that moves wins to this archive, use Mopedo.Database.Win as the value for the Resource property of the routine. Format Property name | Type | Description\n--------------------- | ---------------------------- | -------------------------------------------------------------------------------------\nBidId | string | A unique ID given to this bid by the DSP\nReceiverBidResponseId | string | A unique ID given to the bid response of this bid by the DSP\nBidRequestId | string | The ID of the bid request of this bid\nUserId | string | The UserId of the User contained in the bid request\nIP | string | The IP of the Device contained in the bid request\nSiteDomain | string | The Domain of the Site contained in the bid request\nAppDomain | string | The Domain of the App contained in the bid request\nTime | datetime | The time when the bid was placed\nCampaignId | string | The id of the Campaign that generated this bid\nBuyerId | string | The buyer id of the campaign that placed this bid\nAdId | string | The id of the Ad used for this bid\nClickLandingPage | string | The landing page of the ad included in this bid (if any)\nClicked | boolean | Was the ad clicked?\nWinPriceAmountCPM | decimal | The win price amount, as CPM\nWinPriceCurrency | string | The currency that the win price is expressed in","excerpt":"Mopedo.Archive.WinArchive WinArchive is the SQLite based archive resource for Mopedo.Database.Win entities. To set up an archiving routine that moves wins to this archive, use Mopedo.Database.Win as the value for the Resource property of the routine.","tags":"","url":"/Mopedo%20DSP/Developer%20guides/API%20reference/Mopedo.Archive/WinArchive"},{"title":"AppExtension","text":"AppExtension The AppExtension resource works just like SiteExtension, but for User entities instead of Site entities. It indivuduates its App entity by means of the Domain property and is also useful for creating whitelists and blacklists. Domain and all case variations of it, are reserved property names and cannot be used for client-defined data points.","excerpt":"AppExtension The AppExtension resource works just like SiteExtension, but for User entities instead of Site entities. It indivuduates its App entity by means of the Domain property and is also useful for creating whitelists and blacklists. Domain and","tags":"","url":"/Mopedo%20DSP/Developer%20guides/API%20reference/Mopedo.ClientData/AppExtension"},{"title":"DeviceExtension","text":"DeviceExtension The DeviceExtension resource relates a set of client-defined data points with the Device database resource. There is one reserved property name, IP, that may not be used as a client-defined data point. All case variations of IP, for example Ip and ip are also reserved. In many cases an actual device will have different IP addresses at different times. For example, a mobile phone will have different IP addresses when used via a cellular connection and while connected to a home Wi-Fi network. But since devices, unlike users, are not uniquely identified by the SSPs by means of cookies, IPs are the best we can get. It is recommended that the advertiser provide a unique identifier to each DeviceExtension entity, so that duplicates can easily be identified and existing entities updated properly. DeviceExtension works just like UserExtension, but connects to a Device via IP, instead of to a User via UserId. Data update example For this example, we consider an advertiser who wants to upload a couple of thousand IP addresses for ad targeting. The advertiser can do this with a POST request to the DeviceExtension resource using the REST API: By setting bid rules in an active campaign that matches against the DeviceGroup property of DeviceExtension entities, the advertiser can make sure to respond with a certain marketing message to these IP addresses as they appear in bid requests. Example condition:","excerpt":"DeviceExtension The DeviceExtension resource relates a set of client-defined data points with the Device database resource. There is one reserved property name, IP, that may not be used as a client-defined data point. All case variations of IP, for e","tags":"","url":"/Mopedo%20DSP/Developer%20guides/API%20reference/Mopedo.ClientData/DeviceExtension"},{"title":"SiteExtension","text":"SiteExtension The purpose SiteExtension entities is to bind additional information to a Site entity, individuated by its Domain property. This is particularly useful when setting up lists of whitelisted or blacklisted sites for use in bid rules. We can, for example, mark all sites we would like to advertise on with a boolean property Whitelisted, and then use a reference to Site.Extension.Whitelisted in a condition inside a bid rule. Similarly, we can mark all sites we do not want to advertise on with a boolean property Blacklisted, for example, and use that property to make sure bidding opportunities on those sites are skipped. Of course, since SiteExtension is a dynamic resource, these properties can be called something else. Domain and all case variations of it, are reserved property names and cannot be used for client-defined data points. Example Say we want to restrict which sites we bid on, and only send bids for ad inventory on the following whitelisted sites: To achieve this, we send the following REST request to the DSP: We can then use the following Condition in a bid rule to skip all non-whitelisted sites:","excerpt":"SiteExtension The purpose SiteExtension entities is to bind additional information to a Site entity, individuated by its Domain property. This is particularly useful when setting up lists of whitelisted or blacklisted sites for use in bid rules. We c","tags":"","url":"/Mopedo%20DSP/Developer%20guides/API%20reference/Mopedo.ClientData/SiteExtension"},{"title":"UserExtension","text":"UserExtension The UserExtension resource relates a set of client-defined data points with the User database resource. There is one reserved property name, UserId, that may not be used as a client-defined data point. All case variations of UserId, for example userId and Userid are also reserved. It is recommended that the advertiser provide a unique identifier to each UserExtension entity, so that duplicates can easily be identified and existing entities updated properly. In examples, this identifier will be a string property cuid (customer user ID), but it can of course be called whatever and be of any data type. Data update example On an advertiser web site, we embed the Mopedo JavaScript tag. When the site loads, the tag will trigger cookie syncing that assigns a unique Mopedo UserId to the visitor of the website, and in the tag, there is a callback function with that ID as argument so that we may use it when sending data updates to the DSP. In this simple example, we will send a simple cross-origin REST call to the DSP REST API. Let's consider an advertiser who wants to add an ID and some customer data to a visitor on their website. By using PUT, the advertiser can avoid duplicates with the same cuid. This will insert a UserExtension entity, and bind it to a corresponding User holding the given UserId. If the UserId is ABC123, The UserExtension object will look like this:","excerpt":"UserExtension The UserExtension resource relates a set of client-defined data points with the User database resource. There is one reserved property name, UserId, that may not be used as a client-defined data point. All case variations of UserId, for","tags":"","url":"/Mopedo%20DSP/Developer%20guides/API%20reference/Mopedo.ClientData/UserExtension"},{"title":"Routines","text":"Routines Routines are operations that archive and/or delete entities from in-memory resources such as Mopedo.Database.BidRequest, and that can be scheduled to run on the DSP in a given time interval. The purpose of routines is to enable automatic trimming of in-memory resources, freeing up memory space in RAM, as well as populating the archive resources, where the archived entities can be queried. The following five in-memory resources can be used with routunes: A common characteristic for all these is that they can contain a large number of entities under normal circumstances, and that they grow steadily over time. Using routines, we can make sure that they do not grow past a certain number of entities, which could have an impact on DSP performance. To manage routines for a DSP, use the Mopedo.Archive.Routine resource. Routine The Routine resource contains all the routines currently added to the DSP, and allows clients to insert new and modify existing routines. Added routines (that are not paused) are run at a time interval that can be set using the RoutineUpdateIntervalMinutes property in the configuration. Property name | Type | Description\n----------------- | ---------------------------------------- | ------------------------------------------------------------------------------------------------------------------------\nId | string (read-only) | A unique ID for the routine, given by the DSP\nDescription | string | A description of the routine\nResource | string | The name of the in-memory resource to target with the routine (see above for a list of available resources)\nIsPaused | boolean | Is this routine currently paused? Paused routines are skipped\nObjective | string | The objective of the routine, can be \"Archive\", \"Delete\" or \"ArchiveAndDelete\"\nNrOfDaysLimit | integer | The maximum age of entities in days before this routine is applied (minimum is 1)\nNrOfEntitiesLimit | integer | The maximum number of entities allowed in the resource before this routine is applied to old entities (minimum is 500)\nLastRunAt | datetime (read-only) | The date and time when this routine was last run\nNextRunAt | datetime (read-only) | The date and time of the next routine run Each Routine entity is required to include either a NrOfDaysLimit or a NrOfEntitiesLimit. There are three possible values for the Objective property of Routines entities: The Archive objective instructs the routine to copy all matched items from the in-memory resource to the SQLite based archive resource belonging to that resource. No items are deleted from the in-memory resource. The Delete objective simply deletes the matched entities from the in-memory resource. The ArchiveAndDelete objective first copies the matched entities from the in-memory resource to the SQLite based archive resource belonging to that resource, and then deletes the matched entities from the in-memory resource. Each routine matches entities from the in-memory resource to perform the objective on, either by having a limit on the maximum allowed age of entities, or by having a limit of the maximum number of entitites allowed before old are removed. These limits are controlled by the NrOfDaysLimit and NrOfEntitiesLimit properties respectively. With a NumberOfDaysLimit of 30, for example, the objective is applied to all entities in the in-memory resource that are older than 30 days. With a NumberOfEntitiesLimit of 5000, old entities are trimmed so that there is always at most 5000 entities in the in-memory resource. Default routines The DSP comes shipped with four default routines, that are added to the Routine resource automatically. It's recommended to keep these routines in order to keep the DSP running properly, but the DSP administrator is free to make any changes to them. These are their definitions: Debugging routines For debugging purposes, there is a resource Mopedo.Debug.RoutineControls that can be used to manually trigger the run of all routines.","excerpt":"Routines Routines are operations that archive and/or delete entities from in-memory resources such as Mopedo.Database.BidRequest, and that can be scheduled to run on the DSP in a given time interval. The purpose of routines is to enable automatic tri","tags":"","url":"/Mopedo%20DSP/Developer%20guides/API%20reference/Mopedo.Archive/Routines"},{"title":"BidRequest","text":"BidRequest The BidRequest resource represents incoming bid requests to the DSP. Queries to this resource can be useful when tracking activity on the Mopedo platform. The BidRequest resource can become very large on certain DSP setups, so there is a default routine to automatically archive old bid requests once 5 million entities have been saved. This can be changed using the Mopedo.Archiving.Routine resource. Format Property name | Type | Description\n----------------------------------- | ------------------------------------------------- | ---------------------------------------------------------------------------\nUser | User | The user associated with the bid request\nDevice | Device | The device associated with the bid request\nSite | Site | The site where the ad slot is located (if web ad)\nApp | App | The app where the ad slot is located (if in-app ad)\nBidRequestId | string | The unique ID of the bid request\nSsp | string | The name of the SSP that generated this bid request\nHasBidResponse | boolean | True if and only if this bid request was responded to\nHasWin | boolean | Did this DSP respond with a winning bid to this bid request?\nTime | datetime | The date and time when the bid request was received\nRequiresClickTrackingMacro (hidden) | boolean | Did this bid request require a click tracking macro in bids?\nTmaxi (hidden) | integer | The bid timeout as defined by the Mopedo backend\nBroadcaster (hidden) | Broadcaster | The broadcaster that broadcasted this bid request\nBidResponse (hidden) | BidResponse | The bid response (if any) generated by this bid request\nWin (hidden) | Win | The win (if any) generated by the bid response (if any) to this bid request Hidden properties can be included in response bodies by using the add meta-condition in the request URI. BidRequest.Feed The BidRequest.Feed resource is a terminal resource that posts representations of BidRequest entities in real time as they are received by the DSP application. The application posts entities to this feed with a slight delay, to pick up any Win associated with it. Property name | Type | Default value | Description\n--------------- | --------- | ------------- | ----------------------------------------------------------------------------------------\nIncludeUser | boolean | false | Should the User property be included in entities in the feed?\nIncludeDevice | boolean | false | Should the Device property be included in entities in the feed?\nIncludeSite | boolean | false | Should the Site property be included in entities in the feed?\nIncludeApp | boolean | false | Should the App property be included in entities in the feed?\nIncludeWin | boolean | false | Should the Win of the bid request (if any) be added to entities in the feed?\nStatus | string | \"PAUSED\" | The current status of the console, can be \"PAUSED\" or \"OPEN\"\nShowWelcomeText | boolean | true | Should the terminal print a welcome message on launch? The format of entities that are sent over the feed is different from the format of the entity resource. Property name | Type | Description\n-------------- | ---------------------------- | -----------------------------------------------------------------------\nBidRequestId | string | The ID of the bid request\nUserId | string | The UserId of the User of the bid request\nUser | User | The User entity of the bid request\nDeviceIP | string | The IP of the Device of the bid request\nDevice | Device | The Device entity of the bid request\nSiteDomain | string | The domain of the Site of the bid request\nSite | Site | The Site entity of the bid request\nAppDomain | string | The domain of the App of the bid request\nApp | App | The App entity of the bid request\nHasBidResponse | boolean | Was this bid request responded to?\nHasWin | boolean | Did the bid response (if any) generate a Win?\nWin | Win | The win (if any) generated by the bid response to this bid request\nTime | datetime | The date and time when the bid request was received\nObjectNo | ulong | The object number of the entity, for fast lookup in the entity resource","excerpt":"BidRequest The BidRequest resource represents incoming bid requests to the DSP. Queries to this resource can be useful when tracking activity on the Mopedo platform. The BidRequest resource can become very large on certain DSP setups, so there is a d","tags":"","url":"/Mopedo%20DSP/Developer%20guides/API%20reference/Mopedo.Database/BidRequest"},{"title":"ClickFeed","text":"ClickFeed The ClickFeed resource is a terminal resource that posts entities that represent clicked ads, in real time as clicks are recorded by the DSP application. Terminal properties Property name | Type | Default value | Description\n--------------- | --------- | ------------- | -----------------------------------------------------------------\nIncludeUser | boolean | false | Should the User property be included in entities in the feed?\nIncludeDevice | boolean | false | Should the Device property be included in entities in the feed?\nIncludeSite | boolean | false | Should the Site property be included in entities in the feed?\nIncludeApp | boolean | false | Should the App property be included in entities in the feed?\nStatus | string | \"PAUSED\" | The current status of the console, can be \"PAUSED\" or \"OPEN\"\nShowWelcomeText | boolean | true | Should the terminal print a welcome message on launch? Entity format The following format is used for entities in the feed: Property name | Type | Description\n------------- | ---------------------------- | -------------------------------------------------------------------------------------------------------------------------------------\nBidRequestId | string | The ID of the bid request of this bid response\nUserId | string | The UserId of the User of the bid request\nUser | User | The User entity of the bid request\nDeviceIP | string | The IP of the Device of the bid request\nDevice | Device | The Device entity of the bid request\nSiteDomain | string | The domain of the Site of the bid request\nSite | Site | The Site entity of the bid request\nAppDomain | string | The domain of the App of the bid request\nApp | App | The App entity of the bid request\nLandingPage | string | The landing page of this click\nTime | datetime | The date and time when the click was recorded\nWinObjectNo | ulong | The object number of the Win entity belonging to this click, for fast lookup in the Mopedo.Database.Win entity resource","excerpt":"ClickFeed The ClickFeed resource is a terminal resource that posts entities that represent clicked ads, in real time as clicks are recorded by the DSP application. Terminal properties Property name | Type | Default value | Description\n---------------","tags":"","url":"/Mopedo%20DSP/Developer%20guides/API%20reference/Mopedo.Database/ClickFeed"},{"title":"Bid","text":"Bid Every time the DSP bidder places a bid on an available ad slot, that bid is saved in the Bid resource. Format Property name | Type | Description\n------------------------ | ------------------------------------------- | -------------------------------------------------------------------------------------\nId | string | A unique ID given to this bid by the DSP\nAdMarkup | string | The HTML markup contained in the bid\nSampleImageUrl | string | The sample image URL from Campaign\nCreativeId | string | The id of the creative contained in the bid\nAdvertiserDomain | string | The advertiser domain from Campaign\nCreativeAttributes | string | Creative attributes as defined in OpenRTB\nError | string | Error code if this bid was invalid\nErrorInfo | string | Information about an invalid bid\nAutoClickTrackingEnabled | boolean | Is auto click tracking enabled for the Ad?\nLandingPage | string | The landing page as defined in Ad\nSupportsClickTracking | boolean | Is click tracking implemented for this bid?\nBidderType | string | The type of bidder used to generate this bid\nBidRequest | BidRequest | The bid request on which this bid was placed\nUser | User | The user associated with this bid\nDevice | Device | The device associated with this bid\nSite | Site | The site associated with this bid\nApp | User | The app associated with this bid\nAdId | string | The id of the Ad used for this bid\nCampaignId | string | The id of the Campaign that generated this bid\nTime | datetime | The time when the bid was placed\nHasWin | boolean | Did this bid win at its auction?\nCategories | array of string | The content categories of the Ad\nBidPrice | Price | The price for the bid, used in the auction\nWin (hidden) | Win | The win (if any) that this bid generated\nAd (hidden) | Ad | The ad used in the bid\nCampaign (hidden) | Campaign | The campaign that placed the bid\nBidResponse (hidden) | BidResponse | The bid response that this bid belongs to Hidden properties can be included in response bodies by using the add meta-condition in the request URI. Bid.Feed The Bid.Feed resource is a terminal resource that posts representations of Bid entities in real time as they are placed by the DSP application. Property name | Type | Default value | Description\n--------------- | --------- | ------------- | -----------------------------------------------------------------\nIncludeUser | boolean | false | Should the User property be included in entities in the feed?\nIncludeDevice | boolean | false | Should the Device property be included in entities in the feed?\nIncludeSite | boolean | false | Should the Site property be included in entities in the feed?\nIncludeApp | boolean | false | Should the App property be included in entities in the feed?\nStatus | string | \"PAUSED\" | The current status of the console, can be \"PAUSED\" or \"OPEN\"\nShowWelcomeText | boolean | true | Should the terminal print a welcome message on launch? The format of entities that are sent over the feed is different from the format of the entity resource. Property name | Type | Description\n------------------------ | ---------------------------- | -------------------------------------------------------------------------------------\nBidRequestId | string | The ID of the bid request on which this bid was placed\nUserId | string | The UserId of the User of the bid request\nUser | User | The User entity of the bid request\nDeviceIP | string | The IP of the Device of the bid request\nDevice | Device | The Device entity of the bid request\nSiteDomain | string | The domain of the Site of the bid request\nSite | Site | The Site entity of the bid request\nAppDomain | string | The domain of the App of the bid request\nApp | App | The App entity of the bid request\nBidPrice | Price | The price for the bid, used in the auction\nAdId | string | The id of the Ad used for this bid\nCampaignId | string | The id of the Campaign that generated this bid\nClickLandingPage | string | The landing page as defined in Ad\nTime | datetime | The time when the bid was placed\nAdMarkup | string | The HTML markup contained in the bid\nSampleImageUrl | string | The sample image URL from Campaign\nAdvertiserDomain | string | The advertiser domain from Campaign\nAutoClickTrackingEnabled | boolean | Is auto click tracking enabled for the Ad?\nCategories | array of string | The content categories of the Ad\nObjectNo | ulong | The object number of the entity, for fast lookup in the entity resource","excerpt":"Bid Every time the DSP bidder places a bid on an available ad slot, that bid is saved in the Bid resource. Format Property name | Type | Description\n------------------------ | ------------------------------------------- | ----------------------------","tags":"","url":"/Mopedo%20DSP/Developer%20guides/API%20reference/Mopedo.Database/Bid"},{"title":"App","text":"App App entities are added whenever the DSP receives bid requests for impressions inside mobile applications. Format: Properties marked in bold are required. Property name | Type | Description\n------------------ | ------------------------------------------------------ | ---------------------------------------------------------------------\nDomain | string | The domain of the app (e.g., \"mygame.foo.com\")\nId | string | The exchange-specific app ID\nName | string | The name of the app\nCategories | string | Comma-separated list of standard IAB codes for the app\nBundle | string | A platform-specific application identifier\nPaid | boolean | Is this a paid app?\nStoreUrl | string | App store URL for an installed app\nVersion | string | App version\nExtension | AppExtension | Additional client-defined data associated with the App\nPublisher | Publisher | The publisher of the app\nCreatedAt | datetime | See CreatedAt\nUsedAt | datetime | See UsedAt\nMatched | bool | See Matched\nMatchedAt | datetime | See MatchedAt\nUsedCount | integer | See UsedCount\nUsedRank | integer | See UsedRank\nAdWinCount | integer | See AdWinCount\nAdClickCount | integer | See AdClickCount\nCampaignWinCount | integer | See CampaignWinCount\nCampaignClickCount | integer | See CampaignClickCount\n~~WinCount~~ | ~~integer~~ | Obsolete: Use AdWinCount instead\n~~ClickCount~~ | ~~integer~~ | Obsolete: Use AdWinCount instead App.Feed The App.Feed resource is a terminal resource that posts representations of App entities in real time as they are added to the DSP application. Property name | Type | Default value | Description\n---------------- | --------- | ------------- | --------------------------------------------------------------------\nIncludeExtension | boolean | false | Should the Extension property be included in entities in the feed?\nStatus | string | \"PAUSED\" | The current status of the console, can be \"PAUSED\" or \"OPEN\"\nShowWelcomeText | boolean | true | Should the terminal print a welcome message on launch? The format of entities that are sent over the feed is different from the format of the entity resource. Property name | Type | Description\n------------- | ------------------------------------------------------ | --------------------------------------------------------\nDomain | string | The domain of the app (e.g., \"mygame.foo.com\")\nCreatedAt | datetime | See CreatedAt\nMatched | bool | See Matched\nExtension | AppExtension | Additional client-defined data associated with the App","excerpt":"App App entities are added whenever the DSP receives bid requests for impressions inside mobile applications. Format: Properties marked in bold are required. Property name | Type | Description\n------------------ | ------------------------------------","tags":"","url":"/Mopedo%20DSP/Developer%20guides/API%20reference/Mopedo.Database/App"},{"title":"IabCode","text":"IabCode The IabCode resource gives access to all valid IAB content category codes used in the Ad resource. You can also view the content category codes here. Format Property name | Type | Description\n------------- | -------- | --------------------------------------------------------------------------\nCode | enum | The IAB content category code. Use this in the Categories array of Ad.\nDescription | string | A description of the IAB category","excerpt":"IabCode The IabCode resource gives access to all valid IAB content category codes used in the Ad resource. You can also view the content category codes here. Format Property name | Type | Description\n------------- | -------- | -----------------------","tags":"","url":"/Mopedo%20DSP/Developer%20guides/API%20reference/Mopedo.Database/IabCode"},{"title":"Publisher","text":"Publisher Publisher entities represent publishers of sites and apps on the supply side, and are contained in Site and App entities in the DSP database. Format Property name | Type | Description\n------------- | -------- | -----------------------------------------------------------\nId | string | Exchange-specific publisher id\nName | string | Publisher name\nCategories | string | Array of IAB content categories that describe the publisher\nDomain | string | The highest-level domain of the publisher","excerpt":"Publisher Publisher entities represent publishers of sites and apps on the supply side, and are contained in Site and App entities in the DSP database. Format Property name | Type | Description\n------------- | -------- | -----------------------------","tags":"","url":"/Mopedo%20DSP/Developer%20guides/API%20reference/Mopedo.Database/Publisher"},{"title":"BidResponse","text":"BidResponse The BidResponse resource contains all responses made to incoming bid requests, including their bids. Format Property name | Type | Description\n--------------------- | ----------------------------- | -----------------------------------------------------------------------------------------------------------------------------------\nUser | User | The User of the bid request\nDevice | Device | The Device of the bid request\nSite | Site | The Site of the bid request\nApp | App | The App of the bid request\nBidRequestId | string | The ID of the bid request of this bid response\nReceiverBidResponseId | string | The ID of the bid response, as defined by the DSP\nSentAt | datetime | The date and time when this bid response was sent\nSent | boolean | Has this bid response been sent?\nCurrency | enum | An ISO 4217 code representing the currency of the bid response, e.g. \"SEK\"\nCurrencyString | string | A string representation of the currency used in the bid prices\nBids | array of Bid | The bids contained in the bid response\nHasWin | boolean | Did this bid response win?\nWin | Win | The win of the bid response, if any\nBidRequest (hidden) | BidRequest | The bid request that this bid response was a response to Hidden properties can be included in response bodies by using the add meta-condition in the request URI. BidResponse.Feed The BidResponse.Feed resource is a terminal resource that posts BidResponse entities in real time as they are generated by the DSP application. The application posts entities to this feed with a slight delay, to pick up any Win associated with it. Property name | Type | Default value | Description\n--------------- | --------- | ------------- | -----------------------------------------------------------------\nIncludeUser | boolean | false | Should the User property be included in entities in the feed?\nIncludeDevice | boolean | false | Should the Device property be included in entities in the feed?\nIncludeSite | boolean | false | Should the Site property be included in entities in the feed?\nIncludeApp | boolean | false | Should the App property be included in entities in the feed?\nIncludeBids | boolean | false | Should the Bids property be included in entities in the feed?\nIncludeWin | boolean | false | Should the Win property be included in entities in the feed?\nStatus | string | \"PAUSED\" | The current status of the console, can be \"PAUSED\" or \"OPEN\"\nShowWelcomeText | boolean | true | Should the terminal print a welcome message on launch? The format of entities that are sent over the feed is different from the format of the entity resource. Property name | Type | Description\n------------- | ---------------------------- | -----------------------------------------------------------------------------------------------------------------------------------\nBidRequestId | string | The ID of the bid request of this bid response\nUserId | string | The UserId of the User of the bid request\nUser | User | The User entity of the bid request\nDeviceIP | string | The IP of the Device of the bid request\nDevice | Device | The Device entity of the bid request\nSiteDomain | string | The domain of the Site of the bid request\nSite | Site | The Site entity of the bid request\nAppDomain | string | The domain of the App of the bid request\nApp | App | The App entity of the bid request\nHasWin | boolean | Did this bid response generate a Win?\nWin | Win | The win (if any) generated by this bid response\nTime | datetime | The date and time when the bid response was generated\nCurrency | enum | An ISO 4217 code representing the currency of the bid response, e.g. \"SEK\"\nBids | array of Bid | The bids contained in this bid response\nObjectNo | ulong | The object number of the entity, for fast lookup in the entity resource","excerpt":"BidResponse The BidResponse resource contains all responses made to incoming bid requests, including their bids. Format Property name | Type | Description\n--------------------- | ----------------------------- | ---------------------------------------","tags":"","url":"/Mopedo%20DSP/Developer%20guides/API%20reference/Mopedo.Database/BidResponse"},{"title":"Common properties","text":"Common members Database resources share a set of common members: CreatedAt CreatedAt is a datetime defining the date and time when the database resource entity was created. UsedAt UsedAt is a datetime defining the date and time when the database resource entity was last included in a bid request. Matched Matched is true for a database resource entity if and only if it has been associated with some client data, for example during user matching. All database resource entities can be assigned client data by setting their respective Extension properties. MatchedAt MatchedAt is a datetime defining the date and time when the Matched property was last changed to true. UsedCount All database resource entities have a UsedCount property – an integer that is incremented each time the database resource entity is contained in a bid request. UsedRank UsedRank is a relative ranking of entities' UsedCount properties. Entities with higher values for UsedCount will have a higher UsedRank (lower number). That way you can keep track of the database resource entities that is most frequently used, and easier target them with bid rules. AdWinCount The AdWinCount method is used to calculate the number of times a certain Ad has been used to generate a winning bid on a given database resource entity. AdWinCount is available for all database resources. The method takes an AdId as argument, and is useful when setting up bid rules, so that the same ad is only showed a definite number of times for a certain user, for example. It can only be used when defining bid rule conditions. To print equivalent data using the REST API, use the WinReport resource instead. Adding the condition above to a bid rule will make it exclude all bid requests containing users that have had the ad ad001 shown 10 times or more. Formally, the condition above is true and only true for all users U such that the Ad with AdId \"ad001\" was used at most 10 times in winning bids on bid requests where U was the User. AdClickCount The AdClickCount method is used to get the number of times a certain ad has been clicked, for a given database resource entity. ClickCount is available for all database resources, but for it to work, Ad entities need to be set up to use automatic click tracking. The method takes an AdId as argument, and is useful when setting up bid rules that trigger a change in behavior based on the number of time an ad is clicked. To print equivalent data using the REST API, use the WinReport resource instead. Adding the condition above to a bid rule will make it exclude all bid requests containing a site on which the ad ad001 has been clicked less than 1001 times. Formally, the condition above is true and only true of sites S such that the Ad with AdId \"ad002\" has been clicked at least 1000 times on S. CampaignWinCount The CampaignWinCount property is used to get the number of times the current campaign has been used to generate a Win for a given database entity. CampaignWinCount is available for all database resources. It's useful in bid rules that should limit the number of purchased impressions for, for example, a given User. The above condition will only be true of bid requests containing users that the current campaign has purchased at most 9 ad impressions for. CampaignClickCount The CampaignClickCount property is used to get the number of times the current campaign has been used to generate a Win for a given database entity, that was also clicked. CampaignClickCount is available for all database resources. It's useful in bid rules that should limit the number of purchased impressions for, for example, a given User, based on the number of clicks registered. The above condition will only be true of bid requests containing users that the current campaign has purchased at most 9 clicked ad impressions for.","excerpt":"Common members Database resources share a set of common members: CreatedAt CreatedAt is a datetime defining the date and time when the database resource entity was created. UsedAt UsedAt is a datetime defining the date and time when the database reso","tags":"","url":"/Mopedo%20DSP/Developer%20guides/API%20reference/Mopedo.Database/Common%20properties"},{"title":"BidderConsole","text":"BidderConsole BidderConsole is a terminal resource used for debugging bid rules. It posts bid rule evaluations in real-time as they happen, along with metadata such as the evaluated values for bid rule conditions. For performance reasons, it's recommended to only use BidderConsole terminals while debugging bid rules, since building the debug information will otherwise consume unnecessary system resources. Properties Property name | Type | Default value | Description\n--------------- | --------- | ------------- | ----------------------------------------------------------------\nStatus | string | \"PAUSED\" | The current status of the console, can be \"PAUSED\" or \"OPEN\"\nShowWelcomeText | boolean | true | Should the terminal print a welcome message on launch?","excerpt":"BidderConsole BidderConsole is a terminal resource used for debugging bid rules. It posts bid rule evaluations in real-time as they happen, along with metadata such as the evaluated values for bid rule conditions. For performance reasons, it's recomm","tags":"","url":"/Mopedo%20DSP/Developer%20guides/API%20reference/Mopedo.Debug/BidderConsole"},{"title":"RoutineControls","text":"RoutineControls The RoutineControls resource is a terminal resource that allows the client to manually trigger the run of all archiving routines. Options","excerpt":"RoutineControls The RoutineControls resource is a terminal resource that allows the client to manually trigger the run of all archiving routines. Options","tags":"","url":"/Mopedo%20DSP/Developer%20guides/API%20reference/Mopedo.Debug/RoutineControls"},{"title":"Site","text":"Site Site entities are added when the DSP receives bid requests for impressions on web sites, for example a media site with banner ad slots. Format Properties marked in bold are required. Property name | Type | Description\n------------------ | -------------------------------------------------------- | ---------------------------------------------------------------------\nDomain | string | The domain of the site (e.g., \"nytimes.com\")Id | string | Exchange-specific site ID\nName | string | The name of the site\nCategories | string | A comma-separated list of standard IAB codes for the site\nPage | string | The URL of the page where the impression will be shown\nReferrer | string | The referrer URL that caused navigation to the current page\nMobileOptimized | boolean | Does the site have a special layout for mobile devices?\nExtension | SiteExtension | Additional client-defined data associated with the Site\nPublisher | Publisher | The publisher of the site\nCreatedAt | datetime | See CreatedAt\nUsedAt | datetime | See UsedAt\nMatched | bool | See Matched\nMatchedAt | datetime | See MatchedAt\nUsedCount | integer | See UsedCount\nUsedRank | integer | See UsedRank\nAdWinCount | integer | See AdWinCount\nAdClickCount | integer | See AdClickCount\nCampaignWinCount | integer | See CampaignWinCount\nCampaignClickCount | integer | See CampaignClickCount\n~~WinCount~~ | ~~integer~~ | Obsolete: Use AdWinCount instead\n~~ClickCount~~ | ~~integer~~ | Obsolete: Use AdWinCount instead Site.Feed The Site.Feed resource is a terminal resource that posts representations of Site entities in real time as they are added to the DSP application. Property name | Type | Default value | Description\n---------------- | --------- | ------------- | --------------------------------------------------------------------\nIncludeExtension | boolean | false | Should the Extension property be included in entities in the feed?\nStatus | string | \"PAUSED\" | The current status of the console, can be \"PAUSED\" or \"OPEN\"\nShowWelcomeText | boolean | true | Should the terminal print a welcome message on launch? The format of entities that are sent over the feed is different from the format of the entity resource. Property name | Type | Description\n------------- | ------------------------------------------------------- | ---------------------------------------------------------\nDomain | string | The domain of the site (e.g., \"nytimes.com\")\nCreatedAt | datetime | See CreatedAt\nMatched | bool | See Matched\nExtension | AppExtension | Additional client-defined data associated with the Site","excerpt":"Site Site entities are added when the DSP receives bid requests for impressions on web sites, for example a media site with banner ad slots. Format Properties marked in bold are required. Property name | Type | Description\n------------------ | ------","tags":"","url":"/Mopedo%20DSP/Developer%20guides/API%20reference/Mopedo.Database/Site"},{"title":"​SnapshotControls","text":"SnapshotControls The SnapshotControls resource is a terminal resource that allows the client to create, reset and print settings for CampaignSpendingSnapshot entities and their corresponding AdSpendingSnapshot entities. Options These are the options available from this terminal resource:","excerpt":"SnapshotControls The SnapshotControls resource is a terminal resource that allows the client to create, reset and print settings for CampaignSpendingSnapshot entities and their corresponding AdSpendingSnapshot entities. Options These are the options ","tags":"","url":"/Mopedo%20DSP/Developer%20guides/API%20reference/Mopedo.Debug/%E2%80%8BSnapshotControls"},{"title":"User","text":"User A User entity represents a person, in the form of a matched or unmatched web browser. Users are created in the DSP whenever a new user id is introduced via a bid request or when user matching. Whenever a UserExtension entity is created containing a UserId property with the same value as an existing User's UserId, the UserExtension entity will be assigned to the Extension property of that User. Users can be matched by means of user matching. Format Properties marked in bold are required. Property name | Type | Description\n------------------ | -------------------------------------------------------- | ---------------------------------------------------------------------\nUserId | string | Mopedo-assigned unique user id\nExtension | UserExtension | Additional client-defined data associated with the User\nCreatedAt | datetime | See CreatedAt\nUsedAt | datetime | See UsedAt\nMatched | bool | See Matched\nMatchedAt | datetime | See MatchedAt\nUsedCount | integer | See UsedCount\nUsedRank | integer | See UsedRank\nAdWinCount | integer | See AdWinCount\nAdClickCount | integer | See AdClickCount\nCampaignWinCount | integer | See CampaignWinCount\nCampaignClickCount | integer | See CampaignClickCount\n~~WinCount~~ | ~~integer~~ | Obsolete: Use AdWinCount instead\n~~ClickCount~~ | ~~integer~~ | Obsolete: Use AdWinCount instead User.Feed The User.Feed resource is a terminal resource that posts representations of User entities in real time as they are added to the DSP application. Property name | Type | Default value | Description\n---------------- | --------- | ------------- | --------------------------------------------------------------------\nIncludeExtension | boolean | false | Should the Extension property be included in entities in the feed?\nStatus | string | \"PAUSED\" | The current status of the console, can be \"PAUSED\" or \"OPEN\"\nShowWelcomeText | boolean | true | Should the terminal print a welcome message on launch? The format of entities that are sent over the feed is different from the format of the entity resource. Property name | Type | Description\n------------- | -------------------------------------------------------- | ---------------------------------------------------------\nUserId | string | Mopedo-assigned unique user id\nCreatedAt | datetime | See CreatedAt\nMatched | bool | See Matched\nExtension | UserExtension | Additional client-defined data associated with the User","excerpt":"User A User entity represents a person, in the form of a matched or unmatched web browser. Users are created in the DSP whenever a new user id is introduced via a bid request or when user matching. Whenever a UserExtension entity is created containin","tags":"","url":"/Mopedo%20DSP/Developer%20guides/API%20reference/Mopedo.Database/User"},{"title":"Win","text":"Win The Win resource gives access to all individual instances where a bid won an auction at an ad exchange. For an aggregated report of wins and total spending, use the WinReport resource instead. Format Property name | Type | Description\n-------------------- | ------------------------------- | ------------------------------------------------\nUser | User | The user associated with this win\nDevice | Device | The device associated with this win\nSite | Site | The site associated with this win\nApp | User | The app associated with this win\nTime | datetime | The date and time when the win was registered\nWinPrice | Price | The price paid to show the ad\nClicked | boolean | Was the ad clicked?\nClickedAt | datetime | The date and time when the ad was clicked\nClickLandingPage | string | The landing page where clicks were forwarded\nCampaignId | string | The id of the Campaign that generated this win\nBidRequest (hidden) | BidRequest | The bid request associated with this win\nBidResponse (hidden) | BidResponse | The bid response associated with this win\nBid (hidden) | Bid | The bid that generated this win Hidden properties can be included in response bodies by using the add meta-condition in the request URI. Win.Feed The Win.Feed resource is a terminal resource that posts representations of Win entities in real time as they are recorded by the DSP application. Property name | Type | Default value | Description\n--------------- | --------- | ------------- | -----------------------------------------------------------------\nIncludeUser | boolean | false | Should the User property be included in entities in the feed?\nIncludeDevice | boolean | false | Should the Device property be included in entities in the feed?\nIncludeSite | boolean | false | Should the Site property be included in entities in the feed?\nIncludeApp | boolean | false | Should the App property be included in entities in the feed?\nStatus | string | \"PAUSED\" | The current status of the console, can be \"PAUSED\" or \"OPEN\"\nShowWelcomeText | boolean | true | Should the terminal print a welcome message on launch? The format of entities that are sent over the feed is different from the format of the entity resource. Property name | Type | Description\n---------------- | ---------------------------- | ---------------------------------------------------------------------------\nBidRequestId | string | The ID of the bid request on which this win was made\nUserId | string | The UserId of the User of the bid request\nUser | User | The User entity of the bid request\nDeviceIP | string | The IP of the Device of the bid request\nDevice | Device | The Device entity of the bid request\nSiteDomain | string | The domain of the Site of the bid request\nSite | Site | The Site entity of the bid request\nAppDomain | string | The domain of the App of the bid request\nApp | App | The App entity of the bid request\nWinPrice | Price | The price paid in the winning bid\nAdId | string | The id of the Ad used for the bid\nCampaignId | string | The id of the Campaign that generated the bid\nClickLandingPage | string | The landing page used, as defined in Ad\nTime | datetime | The time when the win was recorded\nObjectNo | ulong | The object number of the entity, for fast lookup in the entity resource","excerpt":"Win The Win resource gives access to all individual instances where a bid won an auction at an ad exchange. For an aggregated report of wins and total spending, use the WinReport resource instead. Format Property name | Type | Description\n-----------","tags":"","url":"/Mopedo%20DSP/Developer%20guides/API%20reference/Mopedo.Database/Win"},{"title":"BiddingStatistics","text":"BiddingStatistics BiddingStatistics is the best way to generate simple short-term and long-term spending reports for campaigns and ads. These statistics are generated for campaigns and ads, or groups of campaigns and ads based on their buyer ids, and for a given time period. Statistics can also be grouped into periods, much like PeriodReport reports. Unlike the other reporting resources, BiddingStatistics uses CampaignSpendingSnapshot and AdSpendingSnapshot entities to generate statistics, which is much faster than working with individual bids and wins over time. It's also indifferent to whether bids and wins are kept in the database, which makes it ideal for long-term reports. It does not, however, support the creation of more fine-grained reports, like calculating win rates for bidding on a given site or user. For these kinds of reports, use one of the dedicated short-term report resources. For a general overview of DSP reporting, see the reporting overview. Report parameters The following properties can be used in request URIs to specify the report parameters: Property name | Type | Description\n------------- | ---------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\nFrom | datetime | The date and time to start reporting from\nTo | datetime | The date and time when the report should end\nCampaignId | string | An optional campaign ID to limit the report to\nBuyerId | string | An optional buyer ID (of campaigns) to limit the report to\nAdId | string | An optional ad ID to limit the report to\nGroupBy | string | An optional grouping parameter\nCurrency | string | A currency to use in the generated report(s). If omitted, the default currency (as set in the configuration) is used Format The response is a list of reports with the following format: Property name | Type | Description\n------------- | ----------------------------------------------- | ---------------------------------------------------\nFrom | datetime | The date and time of the start of the report period\nTo | datetime | The date and time of the end of the report period\nStatistics | Statistics | The statistics for the given time period Grouping BiddingStatistics supports grouping bidding statistics by a time period given in the GroupBy parameter. Using GroupBy we can, for example, order a day's spending into 8 \"chunks\", each representing a 3 hour periods of the day. Each allowed value of GroupBy has a certain spending snapshot period that it uses for generating the report(s). If we want to group spending by 20 minute periods, for example, we set GroupBy to \"20min\", which would also mean we're using [_20min]() campaign spending snapshots for the report. Some GroupBy values, like \"12h\" for example, does not have a dedicated snapshot period, and instead uses 4 _3h snapshots to generate each report. For each period P, where P is any of the values listed below, GroupBy groups the ouput into periods with P as length, starting with the P period that the From parameter is included in. If no From parameter is included, the first ever P period where there were bidding events is the first period included in the report. If the To time parameter does not refer to an even P period end, the P period to which it belongs will be included. If the To parameter is omitted, the current date and time is used as the end for the report period. GroupBy conditions may have any of the following seven values: The DSP does not store spending snapshots of all periods indefinetely. _20min snapshots, for example, are usually trimmed after 60 days. For more information, see the section on snapshot trimming.","excerpt":"BiddingStatistics BiddingStatistics is the best way to generate simple short-term and long-term spending reports for campaigns and ads. These statistics are generated for campaigns and ads, or groups of campaigns and ads based on their buyer ids, and","tags":"","url":"/Mopedo%20DSP/Developer%20guides/API%20reference/Mopedo.Reporting/BiddingStatistics"},{"title":"UnsupportedBannerReport","text":"UnsupportedBannerReport Use the UnsupportedBannerReport resource to create an aggregated view over all the instances where a bid template was matched for a bid request, but did not contain any Ad of proper dimensions. Keeping track of this resource and identifying missing banner dimensions can give you great insight on how to improve your campaigns. The following properties can be used to specify the report parameters: Property name | Type | Description\n------------- | ---------------------------- | -------------------------------------------------------\nDomain | string | The domain on which the banner ad slot was placed\nInfo | string | Information about the missed bid opportunity\nTime | datetime | The time when the missed bid opportunity was registered\nWidth | integer | The width of the unsupported ad slot\nHeight | integer | The height of the unsupported ad slot\nDimensions | string | The dimensions expressed as a string, e.g. \"250x300\"\nCampaignId | string | An optional campaign id to filter against\nBuyerId | string | An optional buyer id (of campaigns) to filter against\nAdId | string | An optional ad id to filter against The response contains a list of missing banner dimensions, with the following format: Property name | Type | Description\n-------------- | ---------------------------- | ---------------------------------------------------------\nWidth | integer | The width of the missing banner\nHeight | integer | The height of the missing banner\nCount | integer | The total number of requests for this banner dimensions\nTimeOfEarliest | datetime | The time of the first request for this banner dimensions\nTimeOfLatest | datetime | The time of the latest request for this banner dimensions\nDomains | array of string | The domains that have requested this banner dimension Example To get the most often requested unsupported banner dimensions:","excerpt":"UnsupportedBannerReport Use the UnsupportedBannerReport resource to create an aggregated view over all the instances where a bid template was matched for a bid request, but did not contain any Ad of proper dimensions. Keeping track of this resource a","tags":"","url":"/Mopedo%20DSP/Developer%20guides/API%20reference/Mopedo.Reporting/UnsupportedBannerReport"},{"title":"BidReport","text":"BidReport BidReport is a short-term reporting resource that works like the WinReport resource, but for Bid entities instead of Win entities. Report parameters The following properties can be used in request URIs to specify the report parameters: Property name | Type | Description\n------------------------ | ---------------------------------------- | -----------------------------------------------------\nUser | User | The user on which the bid(s) was placed\nDevice | Device | The device on which the bid(s) was placed\nSite | Site | The site on which the bid(s) was placed\nApp | User | The app on which the bid(s) was placed\nId | string | The unique ID for the bid\nAdMarkup | string | The HTML markup contained in the bid\nSampleImageUrl | string | The sample image URL from the Campaign\nCreativeId | string | The id of the creative contained in the bid\nAdvertiserDomain | string | The advertiser domain from the Campaign\nCreativeAttributes | string | Creative attributes as defined in OpenRTB\nError | string | Error code if this bid was invalid\nErrorInfo | string | Information about an invalid bid\nTest | string | Is this a test bid?\nAutoClickTrackingEnabled | boolean | Is auto click tracking enabled for this ad?\nLandingPage | string | The landing page as defined in Ad\nSupportsClickTracking | boolean | Is click tracking implemented for this bid?\nBidderType | string | The type of bidder used to generate this bid\nCampaignId | string | The id of the Campaign used for this bid\nBuyerId | string | An optional buyer id (of campaigns) to filter against\nAdId | string | The id of the Ad used for this bid\nTime | datetime | The time when the bid was placed\nPrice | Price | The price for the bid Format The response then has the following format: Property name | Type | Description\n--------------- | ---------------------------- | ---------------------------------------------------------\nFrom | datetime | The report start time\nTo | datetime | The report end time\nNrOfBids | integer | The total number of bids in the report\nTotalBidPrice | Price | The total price sum for all bids in the report\nHighestBidPrice | Price | The highest bid price for all bids in the report\nLowestBidPrice | Price | The lowest bid price for all bids in the report\nAverageBidPrice | Price | The average bid price for all bids in the report\nMedianBidPrice | Price | The median bid price for all bids in the report\nFirstBidAt | datetime | The date and time of the first bid included in the report\nLastBidAt | datetime | The date and time of the last bid included in the report\n~~BidCount~~ | ~~integer~~ | Obsolete: use NrOfBids instead","excerpt":"BidReport BidReport is a short-term reporting resource that works like the WinReport resource, but for Bid entities instead of Win entities. Report parameters The following properties can be used in request URIs to specify the report parameters: Prop","tags":"","url":"/Mopedo%20DSP/Developer%20guides/API%20reference/Mopedo.Reporting/BidReport"},{"title":"PeriodReport","text":"PeriodReport PeriodReport is a short-term reporting resource that enables flexible aggregated spending reports, grouped by some given time period. Say, for example, that we want to get the daily spending for some campaign's spending during the last 60 days. This could be done with 60 separate requests to the DailySpendingReport resource – but with the PeriodReport resource we can do it with just one. The following properties can be used to specify the report parameters: Report parameters The following properties can be used in request URIs to specify the report parameters: Properties marked in bold are required Property name | Type | Description\n------------- | ---------------------------- | ----------------------------------------------------------------\nPeriod | enum | The period to group reports by. Can be: Day, Month or Year\nFrom | datetime | The time of the earliest period report contained in the response\nTo | datetime | The time of the latest period report contained in the response\nCampaignId | string | An optional campaign id to filter against\nBuyerId | string | An optional buyer id (of campaigns) to filter against\nAdId | string | An optional buyer id to filter against Format The response is a list of reports with the following format: Property name | Type | Description\n------------- | ---------------------------- | -------------------------------------------------------------\nPeriod | datetime | Name is e.g. Day. Value is a datetime describing the period\nCampaigns | array of strings | The IDs of all campaigns contributing to the report\nNrOfBids | integer | The number of bids generated during the period\nNrOfWins | integer | The number of wins generated during the period\nNrOfClicks | integer | The number of clicks generated during the period\nWinRate | float | The number of wins divided by the number of bids\nClickRate | float | The number of clicks divided by the number of wins\nTotalBidPrice | Price | The total amount bidded for during the period\nTotalWinPrice | Price | The total amount spent during the period Example To get montly reports for October and November of 2017 using PeriodReport, we make this GET request to the REST API:","excerpt":"PeriodReport PeriodReport is a short-term reporting resource that enables flexible aggregated spending reports, grouped by some given time period. Say, for example, that we want to get the daily spending for some campaign's spending during the last 6","tags":"","url":"/Mopedo%20DSP/Developer%20guides/API%20reference/Mopedo.Reporting/PeriodReport"},{"title":"WinReport","text":"WinReport WinReport is a short-term reporting resource that finds all wins with certain properties, and creates an aggregated report for them, including the number of wins, total price paid and more. By providing conditions that describe the properties of the wins we want to match against, we can, for example, get all winning bids that resulted in an ad showing on a certain website, for a certain user or on a certain device. Report parameters The following properties can be used in request URIs to specify the report parameters: Property name | Type | Description\n---------------- | ---------------------------------------- | -----------------------------------------------------\nUser | User | The user associated with this win\nDevice | Device | The device associated with this win\nSite | Site | The site associated with this win\nApp | User | The app associated with this win\nWinningBid | Bid | The bid associated with this win\nTime | datetime | The date and time when the win was registered\nWinPrice | Price | The price paid to show the ad\nClicked | Boolean | Was the ad clicked?\nClickedAt | datetime | The date and time when the ad was clicked\nClickLandingPage | string | The LandingPage of the winning bid\nCampaignId | string | The id of the Campaign that generated this win\nBuyerId | string | An optional buyer id (of campaigns) to filter against\nAdId | string | The id of the Ad that generated this win\nTime | datetime | The time when the bid was placed Format The response then has the following format: Property name | Type | Description\n--------------------- | ---------------------------- | ---------------------------------------------------------\nFrom | datetime | The report start time\nTo | datetime | The report end time\nNumberOfWins | integer | The total number of winning bids in the report\nNumberOfClicks | integer | The total number of clicks for the selected wins\nTotalWinPrice | Price | The total price sum for all winning bids in the report\nHighestWinPrice | Price | The highest win price for all wins in the report\nLowestWinPrice | Price | The lowest win price for all wins in the report\nAverageWinPrice | Price | The average win price for all wins in the report\nMedianWinPrice | Price | The median win price for all wins in the report\nUniqueIdentifiedUsers | integer | The total number of unique users for the wins\nFirstWinAt | datetime | The date and time of the first win included in the report\nLastWinAt | datetime | The date and time of the last win included in the report\n~~WinCount~~ | ~~integer~~ | Obsolete: use NumberOfWins instead\n~~TotalNrOfClicks~~ | ~~integer~~ | Obsolete: use NumberOfClicks instead Examples 1. Make a win report for a certain user segment Let's get a win report for all wins where the User that the ad was shown to (same as the User of the bid request on which the winning bid was placed) had a UserExtension object with a Group property set to \"Group1\". This type of win report is useful if we want to summarize the spendings for a given user segment. 2. Make a win report for the trading on a certain site 3. Make a win report for all trading in February of 2018","excerpt":"WinReport WinReport is a short-term reporting resource that finds all wins with certain properties, and creates an aggregated report for them, including the number of wins, total price paid and more. By providing conditions that describe the properti","tags":"","url":"/Mopedo%20DSP/Developer%20guides/API%20reference/Mopedo.Reporting/WinReport"},{"title":"Reporting overview","text":"Reporting overview The purpose of the resources in the Mopedo.Reporting namespace is to give access to a set of useful reports that are generated from other DSP resources, for example bid requests, bids and wins. The DSP report resources also provide a distinction between short-term and long-term reports, and some guidelines on when to use them. Short-term reports Short-term reports refer to reports that are calculated from a data source of relatively recent data, for example the bidding of the last couple of days. Given that the data source is accurate, calculating fast and accurate short-term reports can be done by simply aggregating the content of the data source. Working with the data source directly also allows for flexible reports with no loss in detail. A good example of a short-term report is Mopedo.Database.WinReport, that is used to calculate win metrics directly from the Mopedo.Database.Bid and Mopedo.Database.Win data sources. Since we're working with these data sources directly, we can use their properties, and the properties of their properties, in our report parameters for increased flexibility and level of detail. We can, for example, create a WinReport for all wins from the third of May 2018, for sites with a domain longer than five characters, and with a device that was located in Sweden. As we can see from the example above, short-term reports can be very granular and flexible. Since we're working directly with bids and wins, we can use all their properties and relations in report parameters. This is both the strength and the weakness of short-term reports – we need to keep bids and wins for as long as we want to be able to generate reports. And calculating reports will take longer for each bid and win that is included. If a campaign, for example, places thousands of bids each hour for 60 days, we can easily get millions of bids and wins in our database for that period. Calculating the win rate (the number of wins divided by the number of bids) for the campaign would require iterating over them all, which is a huge operation compared with the kind of calculation we saw in the example above. Also, keeping millions of bids and wins in the in-memory database is another problem in and of itself, as discussed here. In short, we cannot expect bids and wins to remain in the in-memory database indefinitely, and to delete old bids and wins will also mean that we cannot create reports from them, which is a big problem when calculating campaign performance over time. To solve this, the DSP has a separate long-term reporting system. Long-term reports Long-term reports differ from short-term reports in that they are not calculated from wins and bids, but from spending snapshots. Spending snapshots are data entities that hold spending data for a campaigns and ads during a given snapshot period. If there is a spending snapshot for a campaign for the 24 hour period 2018-01-01 – 2018-01-02, for example, that means that we can calculate a spending report from this snapshot, without having to find bids and wins for this period. The bids and wins need not even be kept in the database, as long as the spending snapshot exists. BiddingStatistics is the go-to resource for long-term reports that are calculated from spending snapshots. And since spending snapshots are automatically created for current time periods as well, it's great for creating simple short-term reports as well. Creating BiddingStatistics reports is very fast for any time period, due to the fact that spending snapshots are aggregated over time. Note, however, that we cannot be as granular as we could in the short-term reports.","excerpt":"Reporting overview The purpose of the resources in the Mopedo.Reporting namespace is to give access to a set of useful reports that are generated from other DSP resources, for example bid requests, bids and wins. The DSP report resources also provide","tags":"","url":"/Mopedo%20DSP/Developer%20guides/API%20reference/Mopedo.Reporting/Reporting%20overview"},{"title":"Shell","text":"Shell The Shell resource is a terminal resource that makes it possible to work with a RESTar API over a command-line interface. When launched, the shell acts as a command-line interpreter for text commands sent as WebSocket text messages, and responds with data and status information. Using shell text commands, the client can navigate around the resources of the API, read, insert, update and/or delete entities, or enter other terminals. Properties Property name | Type | Default | Description\n---------------- | --------- | ---------- | --------------------------------------------------------------------------------------------------------------------------------------------------\nQuery | string | \"\" | Determines the current location of the shell, and the URI for subsequent requests\nUnsafe | boolean | false | Is the shell currently in unsafe mode? (see the unsafe meta-condition)\nWriteHeaders | boolean | false | Should the shell include headers when writing output?\nAutoOptions | boolean | false | Should the shell automatically send an OPTIONS command after each successful navigation?\nAutoGet | boolean | false | Should the shell automatically send an GET command after each successful navigation?\nStreamBufferSize | integer | 16000000 | The buffer size (message size) to use with WebSocket streaming\nProtocol | string | \"restar\" | The protocol to use in requests Shell text commands Shell text commands are strings of characters sent as text messages to the Shell terminal resource over a WebSocket connection, that trigger certain server-side operations. Each command invocation consists of the name of a command, for example GET or VAR, and – optionally – a space followed by a command argument. The semantics for the given argument differs between commands. When receiving text commands, the shell evaluates the command and returns a result. Finally, after each command evaluation, a message is sent back over the WebSocket with the current value of the Query property, e.g. ? /superhero. If a potentially unsafe operation is about to be performed, e.g. deletion of multiple entities, the client will be asked to confirm before the execution continues. The following text commands are available in the Shell resource: GO GET POST PATCH PUT DELETE REPORT HEAD STREAM OPTIONS NEXT HEADER VAR HELP CLOSE The GO command sets the Query property to argument text (excluding any whitespace), and validates the query as a RESTar URI. This is the primary way to navigate between resources using the shell. If the navigation was unsuccessful, e.g. due to some syntax error in the input text string, an error message is returned. Otherwise, if AutoOptions is set to true, an OPTIONS command is made for the new query. Otherwise, if AutoGet is set to true, a GET command is made for the new query. Executes a GET request with the value of the Query property as URI along with the headers defined for the shell. Any argument given is used as the body of the request (UTF8). On success, the content of the body is sent back to the client along with the status code and description. On fail, an error message is returned. If the body is larger than 16 megabytes, the client will be required to stream the result over multiple WebSocket messages. Executes a POST request with the value of the Query property as URI along with the headers defined for the shell. Any argument given is used as the body of the request (UTF8). On success, the content of the RESTar-info header is sent back to the client along with the status code and description. On fail, an error message is returned. Executes a PATCH request with the value of the Query property as URI along with the headers defined for the shell. Any argument given is used as the body of the request (UTF8). On success, the content of the RESTar-info header is sent back to the client along with the status code and description. On fail, an error message is returned. Executes a PUT request with the value of the Query property as URI along with the headers defined for the shell. Any argument given is used as the body of the request (UTF8). On success, the content of the RESTar-info header is sent back to the client along with the status code and description. On fail, an error message is returned. Executes a DELETE request with the value of the Query property as URI along with the headers defined for the shell. Any argument given is used as the body of the request (UTF8). On success, the content of the RESTar-info header is sent back to the client along with the status code and description. On fail, an error message is returned. Executes a REPORT request with the value of the Query property as URI along with the headers defined for the shell. Any argument given is used as the body of the request (UTF8). On success, the content of the body is sent back to the client along with the status code and description. On fail, an error message is returned. Executes a HEAD request with the value of the Query property as URI along with the headers defined for the shell. Any argument given is used as the body of the request (UTF8). On success, the status code and description of the response is sent back to the client. On fail, an error message is returned. Performs WebSocket streaming of the results of a GET command. The value of the StreamBufferSize property decides how many bytes are included in each WebSocket message. Returns the RESTar.AvailableResource entity corresponding to the resource selected by the current Query. Returns the next page in a paginated enumeration of entities. Note how the current Query is updated with an offset meta-condition after the completion of the NEXT command evaluation. If an integer is included as argument to NEXT, it's used to determine how many pages to return. Sets the value of a header to an assignent that is given as argument. Headers are included in all subsequent requests from the shell. Use this to, for example, change the value of the Accept header. After writing to the given header, all custom headers are returned. Sets the value of a property to an assignment that is given as argument. Use this as shorthand for the standard #TERMINAL global command. After writing to the given property, all properties are returned. Simply prints a link to this documentation. Closes the terminal, and the associated WebSocket. Command shorthands Use these command shorthands when you see fit: Binary data When receiving binary data from the WebSocket client, the shell executes a POST request with the value of the Query property as URI, the headers defined for the shell as headers and the binary data as body.","excerpt":"Shell The Shell resource is a terminal resource that makes it possible to work with a RESTar API over a command-line interface. When launched, the shell acts as a command-line interpreter for text commands sent as WebSocket text messages, and respond","tags":"","url":"/RESTar/Built-in%20resources/RESTar/Shell"},{"title":"Webhook","text":"Webhook Webhooks are custom HTTP callback operations that are triggered by events that are raised by the RESTar application, and that generate HTTP requests with data that can be directed to either a local resource or a remote server on the internet. An introduction to webhooks is provided here. The Webhook resource contains all webhooks currently added to the RESTar application. Webhooks consist of the following components: Webhook request bodies When triggered by an event, the webhook will by default use the event payload as body for the outgoing HTTP request. How the payload is converted to a request body depends on the data type of the event payload, as well as the configuration of the webhook. If the event payload is a binary data stream, it's used directly as body of th outgoing HTTP request, with the content type defined by the event as value of the Content-Type request header. Since the data is already serialized, the webhook cannot change the content type. If the payload consists of entities, they are serialized to binary data streams before used in the request body, and here the webhook can define the content type to use by setting the Content-Type header in Headers of the webhook. If no content type is set, JSON is used for entity payload serialization. When serializing entity payloads to JSON, note that RESTar always writes entity payloads to JSON arrays, regardless of the number of entities contained in the event payload. This behavior mirrors how responses from GET requests always contain arrays, even if there is just one entity in the response. Remote servers accepting calls from RESTar webhooks using JSON as content type should therefore always expect arrays when deserializing the bodies of incoming requests. Format Entities in the Webhook resource have the following format: Properties marked in bold are required. Property name | Type | Description\n-------------------- | ------------------------------------------------------ | --------------------------------------------------------------------------------------------------------\nId | string (read-only) | A unique ID for this webhook\nLabel | string | A descriptive label for this webhook\nMethod | Method | The method to use in the triggered request. Default is POST\nDestination | string | The destination URI for this webhook. Can be relative or absolute\nEventSelector | string | The event selector to use for selecting the events that should trigger this webhook\nHeaders | object | The headers to include in the triggered request\nIsPaused | boolean | Is this webhook currently paused? Paused webhooks are skipped\nCustomPayloadRequest | CustomPayloadRequest | An optional local request to use when fetching event data to include as payload in the triggered request Event selectors Event selectors are URI strings that select event resources. Their syntax is identical to regular request URI strings, but cannot contain meta-conditions. Just like request URIs, they contain a resource and conditions, and the conditions are used to filter out events based on the properties of their payloads. Imagine we have an event resource PersonCreated that has Person entities as payload. Events of this event resource type are raised every time a Person entity is created. Person entities, let's say, have string properties Name and Email. For a webhook listening on PersonCreated events, we can use the following event selectors: Custom payload requests Custom payload requests are local GET requests, selecting entities from a local entity or binary resource. If a CustomPayloadRequest instance is included in a Webhook definition, the resulting entities from evaluating the custom request is used instead of the data passed along with the event when defining the body of the outgoing HTTP request. Custom webhook requests are useful when we want to use an Event as simply a webhook trigger, but define the webhook request body from a separate data source. Just as with webhooks, we need to define an Authorization header if the current RESTar application is set up to require API keys. Properties marked in bold are required. Property name | Type | Description\n---------------- | ----------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------\nMethod | Method (read-only) | The method to use. Is always set to GET\nURI | string | The URI to use\nHeaders | object | The headers to include in the request. Make sure to include Authorization if the current RESTar application requires API keys\nBody | object or array of object | The body to use in the request\nBreakOnError | boolean | Should the outgoing webhook request be aborted if this custom request generates an error response? If false, the error message is sent.\nBreakOnNoContent | boolean | Should the outgoing webhook request be aborted if this custom request generates a 204: No content? If false, an empty request is sent. Example For this example, we have an entity resource Person. Entities of this resource can look like this: We also have an event resource PersonCreated that has Person entities as payload. These events are raised whenever a new Person entity is inserted. We can list all available event resources using a GET request to RESTar.AvailableResource, and in the result we see PersonCreated: To create a webhook listening for all occurances when a Person entity was inserted, has a name longer than 10 characters and the Email property is not null or empty, we can use the following event selector: Next, we want our webhook configured to send a POST request with the Person to a remote web service with URL https://example.com/person. We include apikey ABC123 in the Authorization header to authenticate our requests with the remote server. The complete webhook would be defined as:","excerpt":"Webhook Webhooks are custom HTTP callback operations that are triggered by events that are raised by the RESTar application, and that generate HTTP requests with data that can be directed to either a local resource or a remote server on the internet.","tags":"","url":"/RESTar/Built-in%20resources/RESTar.Admin/Webhook"},{"title":"Meta-conditions","text":"Meta-conditions With meta-conditions, we can include meta-information about the request in the URI, and instruct the server to perform certain operations when handling the request. Meta-conditions consist of three parts: a meta-condition name, an equals sign (\"=\"), and a meta-condition value of a predefined type. Meta-condition value literals, like all value literals, are case-sensitive, except when they are property locators – then they are case-insensitive. These are the meta-condition keys: The subsections below go through each of these in more detail: unsafe Type: boolean By default, the REST API protects against unsafe requests that could result in performance issues or serious accidental data loss or corruption if triggered by mistake. Example of such requests could be: This was previously considered an unsafe operation, but is no longer since the WebSocket shell, which has its own streaming mechanism to guard against this, is the new preferred way to debug and test RESTar applications. PATCH requests that modify multiple entities. If the wrong conditions are used when trying to update a single entity, and the server instead changes many entities, unwanted data loss or corruption could occur. DELETE requests that delete many entities, when just one entity was supposed to be deleted. To prevent this, the API uses a meta-condition unsafe to let the consumer confirm all such potentially dangerous requests. For update and delete requests, RESTar will send a 400: Bad request response whenever multiple entities would be affected by a request and unsafe was not set to true. limit Type: integer limit puts an upper limit on the number of entities selected by a request. offset Type: integer Offsets are used to offset the enumeration of the output entities from a GET request. RESTar pagination is defined in terms of limit and offset. order_asc Type: string order_asc orders the output entities in ascending order based on the value of some given property. The value is a property locator that selects the property to order by. order_desc Type: string order_desc works like order_asc but applies a descending ordering. select Type: string select takes a comma-separated list of property locators as arguments, and filters the output so that only the specified properties are included. add Type: string The add meta-condition takes a list of property locators as argument, and adds the denoted properties to the output. rename Type: string The rename meta-condition instructs the server to give certain properties of entities in output new names. rename takes a comma-separated list of strings, where each string has the following syntax (EBNF): property-locator refers to the property in the resource that should be renamed. new-name is simply a case sensitive string – the new name for the property. select and rename can be used in the same request, in which case rename is always evaluated before select. See the request evaluation order for more information. distinct Type: boolean If distinct is set to true in a request, only distinct objects will be included in the output. This operation is performed after add, rename and select, so object properties added or renamed will be taken into account. search Type: string search applies a search filter on a representation of the output, and returns only entities that included the search pattern. There are two search settings that can be included along with the search pattern, to control case sensitivity as well as to limit the search scope to the values of a given entity property. The syntax for this is the following (EBNF): Search settings are optional. If no property scope is included, the whole entity is searched. If no case sensitivity setting is included, the search is case insensitive. search_regex Type: string search_regex applies a regular expression string search filter on a representation of the output, and returns only entities that matched the search pattern. In the example below, we match only against customers with a name beginning with s and ending with l (case insensitive). Before URI encoding, the regex pattern looked like this: ^s.*l$. See this section for how to include search settings. safepost Type: string safepost is used to trigger a special type of POST request, where the input is matched against existing entities to avoid duplicates. Think of a safepost request as a series of repeated PUT requests, where all entities in the data source are matched against existing entities, and inserted only if there is no existing entity to update. As parameter, safepost takes a comma-separated list of property locators, and returns an aggregated response containing the number of inserted and updated entities. The data source can, just as in regular POST requests, be contained in the request body or specified as an external source using the Source header. safepost is also an important feature when using the Destination header. The above request is equivalent to running both of the two requests below: format Type: string The administrator will enable a set of output formats that should be enabled when serializing JSON output. The format meta-condition is used to set the output format for JSON serialization of GET response bodies on a per-request basis. The value should be a name of an output format (case insensitive).","excerpt":"Meta-conditions With meta-conditions, we can include meta-information about the request in the URI, and instruct the server to perform certain operations when handling the request. Meta-conditions consist of three parts: a meta-condition name, an equ","tags":"","url":"/RESTar/Consuming%20a%20RESTar%20API/URI/Meta-conditions"},{"title":"Resource","text":"Resource Resources can be specified in the URI either by the fully qualified name, a part of the full name or by an assignable alias. The full name is always unique for each resource. The resource Mopedo.Bidding.Campaign can be referenced with only \"Campaign\" as long as no other resource name ends with \".Campaign\" or an alias \"Campaign\" is assigned to some other resource. To find all available resources' names for a RESTar appplication, make the following GET request: Views Views are optional components of resources, that lets the consumer access different representations of the same resource. A GET request to an Employee resource will, for example, return representations of all Employee entities in the resource. But if a common use case for the resource is to get the ten employees with the highest sales scores and order them by sales score, the developer can choose to implement this as a separate view, making it easier to do this query. The consumer can see what views are available for some resource by making a GET request to the AvailableResource resource. Views are specified in the URI by adding a dash (\"-\") and the view name directly after the resource specifier, for example: https://my-server.com/rest/employee-best. When writing URIs, all conditions that are available for the resource, is also available for the view. The view may also define new properties that can be used only in conditions for that view. Macros Macros are pre-defined syntactic templates for requests that enable advanced use cases, for example integration with clients that cannot send certain REST requests. To call a macro, place the macro name, preceded by a $-character, in place of the resource specifier in the URI. For more information, see how to administer macros.","excerpt":"Resource Resources can be specified in the URI either by the fully qualified name, a part of the full name or by an assignable alias. The full name is always unique for each resource. The resource Mopedo.Bidding.Campaign can be referenced with only \"","tags":"","url":"/_site/RESTar/Consuming%20a%20RESTar%20API/URI/Resource"},{"title":"Conditions","text":"Conditions Conditions are made up of three parts: a property locator, an operator and a value literal. They encode predicates that are either true or false of entities in the selected resource. Property locators A property locator is a string used to locate a property in a resource entity. Dot notation is used to access the contents of inner objects. If entities in a resource User contain ids, names, accounts and email addresses, and accounts contain account numbers, we can imagine using the following property locators in requests. Property locators are case-insensitive. Examples: Operators The REST API supports the following six operators in conditions: Equals: the two values are the same Not equals: the two values are different Less than: the two values are numbers or datetimes and the first is less than the second, or the two values are strings and the first is alphabetically sorted ahead of the second Greater than: the two values are numbers or datetimes and the first is greater than the second, or the two values are strings and the second is alphabetically sorted ahead of the first Less than or equals: the two values are numbers or datetimes, and the first // is less than or equal to the second, or the two values are strings and the // first is aphabetically sorted equally to or ahead of the second Greater than or equals: the two values are numbers or datetimes and the // first is greater than or equal to the second, or the two values are strings // and the second is alphabetically sorted equally to or ahead of the first Value literal The value literal is a string that encodes some value. RESTar will parse value literals and find the correct data type for the value. An error message is then returned if there is a type mismatch against the resource property specified by the property locator. To force the value literal to be handled as a string, when it would otherwise be understood as, for example, a number – wrap it in quotation marks. For example, 123 would be parsed as an integer. If we want to encode the string \"123\" in a value literal, we can surround the literal with \"-characters or '-characters in the URI. Apart from the usual convention regarding URI-safe characters, the following characters are reserved by RESTar, and always need to be escaped if used in value literals: Character | Use instead\n--------- | -----------\n! | %21 Always URI encode value literal that contain special characters Value literals are case-sensitive. Examples","excerpt":"Conditions Conditions are made up of three parts: a property locator, an operator and a value literal. They encode predicates that are either true or false of entities in the selected resource. Property locators A property locator is a string used to","tags":"","url":"/_site/RESTar/Consuming%20a%20RESTar%20API/URI/Conditions"},{"title":"Additional operations","text":"Additional operations RESTar has built in mechanisms to handle validation of resource entities and resource-specific authorization, available to the developer by having the resource type implement the IValidatable and IAuthenticatable interfaces respectively. Entity resource validation using IValidatable The IValidatable interface has one method, IsValid(), that RESTar calls for all resources implementing IValidatable before running operations Insert and Update. If the entity resource has some validation logic that needs to be run on all entities before insertion or updating – IValidatable provides a simple way to handle invalid entities and show proper error messages to the client. Unlike the operations interfaces and IAuthenticatable below, IsValid() is not run from a static context, so references can be made to instance members. Resource-specific authentication using IAuthenticatable Sometimes it's useful to have a separate means of authentication and authorization for a given resource. RESTar API keys are appropriate for controlling access to the REST API and different resources, but should not be used for more specific authentication and authorization - for example handling user accounts that control access to some resource. IAuthenticatable is a simple interface that enables the developer to define authentication and authorization logic that is executed whenever an external REST request is made to a resource. The best way to pass authentication information to a resource is by including it in custom headers, that are then read in the Authenticate() method. These custom headers are never logged by RESTar.","excerpt":"Additional operations RESTar has built in mechanisms to handle validation of resource entities and resource-specific authorization, available to the developer by having the resource type implement the IValidatable and IAuthenticatable interfaces resp","tags":"","url":"/_site/RESTar/Developing%20a%20RESTar%20API/Entity%20resources/Additional%20operations"},{"title":"Examples","text":"Examples Regular Starcounter database resource This entity resource is a Starcounter database class, and has all its operations defined by RESTar. All we need to do to register it as a resource is to decorate it with the RESTarAttribute attribute. Then we can make request like these: Custom entity resource This entity resource is not a Starcounter database class, or more generally – it's not decorated by any resource provider attribute. This means that we have to define the operations required by the enabled methods using the operations interfaces. For this example, let's consider an entity resource that works as an interface for MyStarcounterResource. See working with requests and conditions for more about how to design the individual operations.","excerpt":"Examples Regular Starcounter database resource This entity resource is a Starcounter database class, and has all its operations defined by RESTar. All we need to do to register it as a resource is to decorate it with the RESTarAttribute attribute. Th","tags":"","url":"/_site/RESTar/Developing%20a%20RESTar%20API/Entity%20resources/Examples"},{"title":"Notes on Excel","text":"Notes on Excel Excel representations of entity resources differ from JSON representations in one important regard – the inability to encode inner entities in-line with other properties. RESTar has various ways of dealing with this limitation. When clients make GET requests to entity resources that have inner objects, and ask the server to use Excel as the representation format, RESTar will automatically reduce the inner object using their ToString() method, if no other reduce function is supplied in the entity resource definition. You can specify a custom Excel reduce function for an entity resource property by defining a method in the entity resource's definition and providing the name of that method in the excelReducer parameter of the RESTarMemberAttribute constructor for that property. Example using excelReducer: Sample Excel output from MyResource: AString | AnInt | AnObject\n------------------- | ----- | -------------------------------\nA fine string value | 42 | Name: Objecty McObject, Id: ABC","excerpt":"Notes on Excel Excel representations of entity resources differ from JSON representations in one important regard – the inability to encode inner entities in-line with other properties. RESTar has various ways of dealing with this limitation. When cl","tags":"","url":"/_site/RESTar/Developing%20a%20RESTar%20API/Entity%20resources/Notes%20on%20Excel"},{"title":"Introduction","text":"Building entity resources Entity resources are resources modelled as sets of entities, where each entity has a set of properties consisting of a key and a value. By using REST and operations like GET, POST and DELETE, we can manipulate the contents of entity resources and get representations of them, for example in JSON. Registering entity resources Entity resources – like all RESTar resources – are .NET classes, and the entities themselves are, not surprisingly, instances of these classes. There are two ways to register a class as an entity resource in RESTar: The easiest way to make an existing class, for example a Starcounter database class, work as a RESTar resource is to simply decorate it with the RESTarAttribute attribute and assign the REST methods we want to make available as parameters to its constructor. The resource is then registered when the application calls [RESTarConfig.Init()]() is called, and made available for REST requests. Sometimes, however, we cannot make code changes in the definition of the class we want to use as a resource, or we do not want a dependency from that assembly to RESTar. In those cases, we can register resources by subclassing the abstract generic ResourceWrapper class. Here the HR_EmployeeContact class is registered as a RESTar resource. It's the HR_EmployeeContact class that will define the members of the resource, for example. The name, namespace and operations of the resource, however, is taken from the wrapper class, in this case Employee. RESTar always require operation definitions for the methods provided in the RESTarAttribute constructor. These operations are used to, for example, select existing entities in the resource and insert new ones. There are two ways to assign operations to a RESTar resource. By assigning a resource provider attribute to its resource declaration, and letting the resource provider assign its default operations. This is what we do in the examples above, since the DatabaseAttribute attribute is a resource provider attribute in RESTar. When we combine the DatabaseAttribute and RESTarAttribute in a resource declaration, we assign the default operation implementations for Starcounter database types to the resource. By creating a custom operation implementation by having the .NET class implement one or more operations interfaces. This is how we override the operations defined by a resource provider, or define operations if the resource has no resource provider attribute. There are five operations that are used by RESTar when evaluating requests. These should not be confused with the REST methods. RESTar use these operations to implement the semantics of REST methods. When executing RESTarConfig.Init(), RESTar will check so that all operations needed for the methods provided in the RESTarAttribute constructor are defined. If not, it will throw a runtime exception. Used in GET, PATCH, PUT and DELETE. Select gets a set of entities from a data storage backend that satisfy certain conditions provided in the request, and returns them. Used in POST and PUT. Takes a set of entities and inserts them into the data storage backend, and returns the number of entities successfully inserted. Used in PATCH and PUT. Takes a set of entities and updates their corresponding entities in the data storage backend, and returns the number of entities successfully updated. Used in DELETE. Takes a set of entities and deletes them from the data storage backend, and returns the number of entities successfully deleted. Used in REPORT requests. Selects and counts entities in the storage backend. If no Count operation is implemented for a resource, RESTar will simply call Select and count the entities in the returned IEnumerable. Note: when implementing Count, we need to take the Distinct meta-condition into account. RESTar references the operation definitions from the interface implementations using delegates, and all calls to them are from a static context – meaning that the this reference technically available from the instance methods defined by the interfaces above will always be null. Always treat operations interface method implementations as static methods when defining operations.","excerpt":"Building entity resources Entity resources are resources modelled as sets of entities, where each entity has a set of properties consisting of a key and a value. By using REST and operations like GET, POST and DELETE, we can manipulate the contents o","tags":"","url":"/_site/RESTar/Developing%20a%20RESTar%20API/Entity%20resources/Introduction"},{"title":"Resource providers","text":"Resource providers As we have seen in these articles, the concept of an entity resource is general enough to encompass all kinds of data structures, as long as they can represent themselves as sets of entities. A MySQL database table, for example, can be used as a RESTar entity resource, and interacted with using the same kinds of requests as native Starcounter tables. All we need to do to make that work is to register a resource like this: This works well, but it puts a lot of responsibility on the developer designing the entity resource. A better way to create a RESTar integration with some data technology, for example MySQL, is to create a resource provider for it, that defines the default operations for interaction with MySQL databases. This way, we can have a simple and organized way for developers to add MySQL database tables to their RESTar applications, without them defining Select, Insert, Update and Delete methods for each of these resources. Instead, developers can declare MySQL resources like this: All resource providers have a resource provider attribute that is used to label the class definitions that should be claimed by the resource provider. In the example above, our MySQL resource provider has a MySQLAttribute attribute type that is used in MySQL resource declarations. This syntax should be familiar to you if you have seen how Starcounter resources are registered. The Starcounter.DatabaseAttribute is, in fact, a RESTar resource provider attribute, that binds a resource to the default operations for Starcounter database classes. By default, RESTar contains the following resource providers: So classes that are not Starcounter database tables need to either define their own operations, or be bound to some custom resource provider. See also: RESTar.SQLite – an SQLite resource provider Building a custom resource provider To implement a custom resource provider, create a new class that inherits from RESTar.ResourceProvider where T is an optional shared base class for all resource types provided by the resource provider. If there is no such base class, simply make your class ResourceProvider. Then define a class inheriting from System.Attribute, to use as resource provider attribute. When executing RESTarConfig.Init(), RESTar will find all entity resource declarations that are decorated with the resource provider attribute, and use your resource provider to register operations for them. You can also specify a DatabaseIndexer sub-class to use when indexing your resources (if indexing is applicable to the technology you are building support for). To use a resource provider in a RESTar application, include an instance of it in the call to RESTarConfig.Init(). See the open-source RESTar.SQLite resource provider for an example. Feel free to contact develop@mopedo.com if you need help creating a resource provider for some technology.","excerpt":"Resource providers As we have seen in these articles, the concept of an entity resource is general enough to encompass all kinds of data structures, as long as they can represent themselves as sets of entities. A MySQL database table, for example, ca","tags":"","url":"/_site/RESTar/Developing%20a%20RESTar%20API/Entity%20resources/Resource%20providers"}]