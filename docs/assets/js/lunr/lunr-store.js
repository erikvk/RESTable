var store = [{"title":"docs","text":"What is RESTable? RESTable is a .NET REST API framework for Starcounter applications, that is free to use and easy to set up in new or existing applications. Its purpose is to provide a set of high-quality tools for developers to build great REST APIs, without having to deal with the complexities (and sometimes utter boringness) associated with client authentication, request processing, data integrations, performance optimizations, URI conventions and documentation. If the term \"REST API\" is unfamiliar to you, we recommend that you read this excellent tutorial, that covers all you need to know. Using RESTable tools, developers can quickly build powerful REST APIs that, among other things: Terminology A RESTable application is any Starcounter application that uses the tools of RESTable to establish a REST API. We will refer to the REST API as simply the web services provided by a RESTable application. RESTable web service and RESTable API are also used interchangeably in these articles to refer to the web services of a RESTable application. A web resource, or just resource, is – in common terminology – anything that can be named, addressed or interacted with using, for example, a REST API.","excerpt":"What is RESTable? RESTable is a .NET REST API framework for Starcounter applications, that is free to use and easy to set up in new or existing applications. Its purpose is to provide a set of high-quality tools for developers to build great REST API","tags":"","url":"/"},{"title":"Resource kinds","text":"RESTable resource kinds When using a RESTable API, for example our demo service, you may notice that there is are multiple kinds of resources that are available to you. Let's make a request to the demo API and list some available resources for the API key RESTable. For the sake of brevity, let's include only the Name and Kind properties: Response body (abbreviated): As we can see, there are four different values for the Kind properties of the listed resources. Let's go through them in order. Entity resources Entity resources are the kind of web resource we should all be familiar with. They are modelled as sets of entities that can be represented using various content types – for example JSON, and that can be manipulated using common REST methods like POST, PATCH and DELETE. The semantics of entity resource interaction is, to a great extent, defined by the HTTP protocol. Entity resources are the most common resources in RESTable, and a large part of the documentation is specific to working with them. See also: Binary resources Binary resources contain read-only binary data of arbitrary size with a specific pre-defined content type. Just like with entity resources, we use HTTP to interact with binary resources. We can, however, only use the GET method. Unlike entity resources, the Accept request header is ignored when requesting a binary resource – we cannot request the content of a binary resource in any content type other than its native type. Binary resources are useful when we have read-only document data – for example an XML document or a text file – that should be exposed over the REST API. A good example is the RESTable.OData metadata document, which contains XML metadata for all resources in a RESTable application. See also: Terminal resources Terminal resources are small, single-purpose console applications that are hosted by a RESTable application, and that can be launched, controlled and terminated by API consumers. Once launched, they establish a two-way communication socket with the client, over which commands and data can be exchanged. While entity resources and binary resources are closely coupled with the HTTP protocol, which is what we use to interact with them, terminal resources have a similar coupling with another TCP protocol – the WebSocket protocol.​ Terminal resources are useful when we want to provide high reactivity and interactivity between the server and the client – for example to build a real-time log resource that pushes data to multiple clients, or a command line interpreter. They exist to enable effective data interaction between client and server, whereas entity resources and binary resources are commonly used as sources of said data. See also: Event resources Event resources define transient event objects that are raised (triggered) from within the RESTable application itself, and that can be listened for and used as triggers for various actions. To understand why event resources exist, imagine that we want to build an entity resource holding notifications, with entities inserted from within the RESTable application itself, as well as from other computers that send POST requests to our API. It stands to reason that clients would want to be notified once entities are added to the resource, but without event resources the best we can do is to tell the client to make frequent GET requests to check for new entities. We could also implement this using a terminal resource, but that would require the client to have an open websocket to the API in order to receive notifications. None of these solutions are favorable. With entity resources, we can let the application raise a notification event once a notification is created, carrying the notification entity as payload, that can then trigger actions – for example a webhook that sends the notification to a remote server. Unlike the other resource kinds, we do not consume event resources by sending requests for them. Instead we listen for them, and interact with their data once they're raised. See also: Each event carries a payload, the data that is associated with the event. The RESTable application developer defines what the payload is for a given event resource a description of the payload should be included in the resource documentation, so that consumers and administrators know what to expect when working with the event resource.","excerpt":"RESTable resource kinds When using a RESTable API, for example our demo service, you may notice that there is are multiple kinds of resources that are available to you. Let's make a request to the demo API and list some available resources for the AP","tags":"","url":"/"},{"title":"What's new","text":"What's new nothing right now","excerpt":"What's new nothing right now","tags":"","url":"/"},{"title":"Configuration","text":"Configuration The RESTable configuration file is an XML text file that is stored somewhere on the computer that runs the RESTable application. It contains API keys and allowed CORS origins that are used by RESTable to control access to the API. The developer will define where the file is to be stored, and the administrator makes sure that the file contains the correct keys and origins. If the configuration file path is C:\\Mopedo\\Config.xml for example, we create a new text file Config.xml, and place it in the C:\\Mopedo directory. The configuration file contains three main XML node types: Configuration file example The node is an XML node type used in RESTable configuration files to assign access rights to an API key. It has four inner node types: Each node must contain exacly one node, and at least one node. The node contains a character string that is used to be used as an API key in the REST API. It has the following syntactical limitations: Each assigns additional access rights to an API key. Each node must contain at least one node, and exacly one node. The total access scope, defined here as a set of method-resource pairs such that the key can be used with the method for the resource, for a key k is equal to the set union of all method-resource pairs assigned in the nodes for k. This means that we cannot exclude resources or methods from the scope of k by simply adding additional nodes with smaller sets of resources and/or methods. A defines one or more resources that should be included in the scope of a node. It consists either of the full name of a REST resource, or of a resource namespace followed by a dot and the wildcard character *. The wildcard character is used to include multiple resources from a namespace, excluding inner namespaces. If we have the following resources in our REST API… … the following node will select both the Mopedo.Bidding.Ad and Mopedo.Bidding.Campaign resources: The following node… … will select Mopedo.Currency, but not any of the resources from the Mopedo.Bidding namespace. To include all resources, we can use this set of nodes: The node contains all the methods to assign to the set of resources selected by the nodes of the containing node. The content of the node is either a comma-separated list of REST methods, e.g. GET, POST, DELETE, or the * character, that is equivalent to GET, POST, PATCH, PUT, DELETE, REPORT, HEAD. Note that the REPORT and HEAD methods are automatically made available if GET is made available. The last key, 1Rc5TCSJWmB7Mq7X, can make GET, REPORT, HEAD and PUT requests to the Mopedo.Database.User resource, GET, REPORT and HEAD requests to Mopedo.Database.Device as well as GET, POST, PATCH, PUT, DELETE, REPORT and HEAD requests to all the resources in the Mopedo.ClientData namespace. nodes are used in RESTable configuration files to whitelist an origin for use with CORS requests. The value is simply the URL of the origin to whitelist. If the RESTable application is set up to allow requests from all CORS origins, whitelisted origins will be ignored. To allow CORS requests from mysite.com, which can be accessed using the HTTP and HTTPS URL schemes, we add the following the the configuration file:","excerpt":"Configuration The RESTable configuration file is an XML text file that is stored somewhere on the computer that runs the RESTable application. It contains API keys and allowed CORS origins that are used by RESTable to control access to the API. The d","tags":"","url":"/ion"},{"title":"API keys","text":"API keys API keys are character strings that are used for authenticating and authorizing RESTable API consumers in a role-based fashion. Whether API keys are required for a specific RESTable web service or not is decided by the application developer, but for services that require them, the consumer is expected to include a valid key in the Authorization header in HTTP requests. Failure to do so will result in a 403: Forbidden response. The administrator will set up and manage these API keys for web services that require them. It's best practice to set up an admin key with a wide scope and more restricted consumer keys with well-defined roles. For applications that use API keys, the developer will have defined a location for an XML configuration file. To add an API to this file, we insert an node inside the root node.","excerpt":"API keys API keys are character strings that are used for authenticating and authorizing RESTable API consumers in a role-based fashion. Whether API keys are required for a specific RESTable web service or not is decided by the application developer,","tags":"","url":"/"},{"title":"CORS","text":"CORS If you are unfamiliar with CORS (Cross-Origin Resource Sharing), check out this excellent introduction RESTable has built-in support for handling incoming CORS requests, and allows the administrator to set up a pre-defined list of whitelisted origins that should be allowed to make such request. For applications that accept whitelisting of CORS origins, the administrator can add such origins by including nodes inside the root node of the XML configuration file.","excerpt":"CORS If you are unfamiliar with CORS (Cross-Origin Resource Sharing), check out this excellent introduction RESTable has built-in support for handling incoming CORS requests, and allows the administrator to set up a pre-defined list of whitelisted or","tags":"","url":"/"},{"title":"Introduction","text":"Administering a RESTable API Apart from the usual tasks associated with running a web service, the task of administering a RESTable API can be defined as:","excerpt":"Administering a RESTable API Apart from the usual tasks associated with running a web service, the task of administering a RESTable API can be defined as:","tags":"","url":"/on"},{"title":"Datetime","text":"Datetime (ISO 8601) An ISO 8601 datetime is a string that encodes a date and time according to the ISO 8601 standard. The date and time: Is encoded into the following ISO 8601 string: ISO 8601 datetimes can include an optional time zone designator. If not present, the DSP will assume that the time is expressed in the UTC time format. The DSP writes UTC datetimes in JSON output, for example: Z is the zone designator for the zero UTC offset according to ISO 8601.","excerpt":"Datetime (ISO 8601) An ISO 8601 datetime is a string that encodes a date and time according to the ISO 8601 standard. The date and time: Is encoded into the following ISO 8601 string: ISO 8601 datetimes can include an optional time zone designator. I","tags":"","url":"/"},{"title":"Overview","text":"Built-in resources overview RESTable has a number of built-in web resources that provide useful utilities and API metadata for consumers and administrators. The resources are ordered into three namespaces: Utilities for consumers and administrators Utilities for administrators Dynamic resources created at runtime It is recommended that the RESTable.Admin namespace is restricted to only administrators. Use the sidebar menu to explore the namespaces.","excerpt":"Built-in resources overview RESTable has a number of built-in web resources that provide useful utilities and API metadata for consumers and administrators. The resources are ordered into three namespaces: Utilities for consumers and administrators U","tags":"","url":"/"},{"title":"Body and data sources","text":"Body and data sources POST, PATCH and PUT requests require a data source to insert and/or update resources from. There are two ways to associate a data source with a request – either by including the data in the body of the HTTP request, or to include a path to the data in the Source header. The REST API can read and write data in two formats: JSON and Excel. Of these two, JSON is the most flexible and commonly used. Excel works well for human readability and reading and writing large data sets, but cannot handle nested objects – which is a limitation when dealing with resources modeled with inner objects. Technically, the correct MIME type to include in requests when reading or writing Excel (.xlsx) files is application/vnd.openxmlformats-officedocument.spreadsheetml.sheet. For testing and debugging purposes, the REST API also accepts the shorter excel as MIME type string. POST using JSON text POST using an Excel file To upload Excel data, include the file as binary in the body and set the Content-Type header to application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.","excerpt":"Body and data sources POST, PATCH and PUT requests require a data source to insert and/or update resources from. There are two ways to associate a data source with a request – either by including the data in the body of the HTTP request, or to includ","tags":"","url":"/sources"},{"title":"Headers","text":"Headers By including certain parameters as values in request headers, the client can instruct the server to perform some high-level operations while handling a request. Authorization When designing a RESTable application, the developer can choose if to require API keys in REST API requests. If API keys are required, the client is expected to include the key in the Authorization header. If \"mykey\" is a valid API key, a request could look like this: RESTable also supports basic authentication. This is particularly useful when sending requests from clients that have built-in support for basic authentication. Basic authentication needs the client to input a user name and password. When sending requests to a RESTable API with basic authentication, leave the user name blank and use the api key as password. Content-Type The Content-Type header is used to inform the server of what format the data from the data source is encoded in. Tha value should be a MIME type string, for example application/json (JSON) or application/vnd.openxmlformats-officedocument.spreadsheetml.sheet (Excel). The RESTable application developer can define [additional supported input content types](). Accept The Accept header tells the server to encode the response body in a certain format. By default, responses are JSON-formatted, but this can be changed to Excel by setting the content of the Accept header to application/vnd.openxmlformats-officedocument.spreadsheetml.sheet. The server will automatically, as per convention, include information in the Content-Disposition header, that the client can use to automatically give the output file an appropriate name. The RESTable application developer can define [additional supported output content types](). Source If an external data source should be used instead of the contents of the request body, a method and URI to that data source can be included in the Source header. The input content type is still defined by the Content-Type header. Source headers values have the following syntax (EBNF): Destination If the data included in a response from a REST API request should be forwarded to an external destination instead of back to the client, we can specify this destination as a method and URI in the Destination header. And if we want the data to be sent to the external destination in Excel format, we simply set the Accept header to application/vnd.openxmlformats-officedocument.spreadsheetml.sheet. Destination header values have the following syntax (EBNF): When the Destination header is set, the request response will be whatever response the server receives from sending a request with the specified method, URI and data to the destination server. The response body from a GET request, if entities were found, is always an array of JSON objects (or a set of rows in Excel), which means that the destination for a GET request must be able to handle an array of entities as input. This, in turn, means that if a RESTable server is used as destination, the destination method must be POST, as it's the only method that allows an array of entities to be used as input. Sometimes we want to insert entities in a duplicate-safe way, however, which is why we need the Safepost meta-condition – which will trigger a server-side iteration over the list of entities and splitting the request into multiple internal PUT requests.","excerpt":"Headers By including certain parameters as values in request headers, the client can instruct the server to perform some high-level operations while handling a request. Authorization When designing a RESTable application, the developer can choose if ","tags":"","url":"/"},{"title":"Consuming terminal resources","text":"Consuming terminal resources Terminal resources are small single-purpose console applications that can be launched and closed by REST clients. We interact with terminal resources using the WebSocket protocol, and to launch a terminal resource, we make a GET request to the given resource, and include a WebSocket handshake – so that the server can initiate a WebSocket connection for the terminal. The easiest way to initiate a WebSocket connection with a RESTable API while testing, is to use a command line tool like wscat, but something like this Chrome extension works fine too if you prefer to work with a web browser. To test things out, let's make a request to the RESTable.Shell terminal resource on our demo service. For this we can use this wscat command: For clients that do not support sending headers with WebSocket requests, which includes the Chrome extension mentioned above, use this URI instead: This will launch the RESTable.Shell terminal resource, which will let you navigate around the available resources of the server. For more information about the RESTable.Shell resource, see this documentation. General features of terminal resources Terminal resources are small, encapsulated command-line applications, that are instantiated for each request that target them. Each such instance can run independently from other instances. Each connected WebSocket has exaxly one terminal resource assigned to it at all times. RESTable will instantiate terminal resources and assign WebSockets to them – a terminal resource can never assign itself to some WebSocket. When a terminal is done with a given WebSocket connection, it must redirect it to a different terminal, for example RESTable.Shell. The Shell is the only terminal resource that can close WebSocket connections. The client can always close the terminal by either using a global command or by simply closing the WebSocket connection from their end. WebSocket headers Each WebSocket connected to RESTable has a set of headers, that are copied from the WebSocket upgrade request. In the case of the RESTable.Shell resource resource, these are also used in all subsequent requests from that resource. We can read or modify the headers of the WebSocket by using the #INFO global command. Terminal resource properties Each terminal resource declares a set of instance properties that define its state. A common use case for these properties is to define settings that determine the behavior of the terminal resource. Just like with properties of entity resources, terminal resource properties can be read-only. Properties of terminal resources should be documented along with the terminal resource. There are two ways to set the values of a terminal resource's properties. The example below will demonstrate both these methods. Let's look at the properties of the RESTable.Shell resource: Property name | Type | Description\n---------------- | --------- | ---------------------------------------------------------------------------------------------------------\nQuery | string | Determines the current location of the shell, and the URI for subsequent requests\nUnsafe | boolean | Is the shell currently in unsafe mode? (see the unsafe meta-condition)\nWriteHeaders | boolean | Should the shell include headers when writing output?\nAutoOptions | boolean | Should the shell automatically send an OPTIONS command after each successful navigation?\nAutoGet | boolean | Should the shell automatically send an GET command after each successful navigation?\nStreamBufferSize | integer | The buffer size (message size) to use with WebSocket streaming Each instance of this terminal resource will contain its own set of values for these properties. They act as the settings of the Shell instance. We can instantiate the Shell resource by making a WebSocket upgrade request with /shell as URI, and we can optionally include assignments to the terminal's properties by adding conditions to the URI. To launch a Shell instance with AutoGet and WriteHeaders both set to true, for example, we can use this URI with the WebSocket upgrade request: We can also use the #TERMINAL global command to set the properties of the current terminal once it's launched. As argument we use a JSON object describing the changes to make. To set AutoGet and WriteHeaders to true for a running Shell instance, we can run the following global command: For more information on global commands, see the next section. Global commands Global commands are text commands available in all terminal resources, that lets the client perform high-level operations such as setting terminal properties, switching terminals and get metadata about the WebSocket connection. Returns the properties of the current terminal. An optional JSON object can be used as argument to update the properties of the terminal. See this section for an example. Returns an object describing the current WebSocket connection. An optional JSON object can be used as argument to update the contents of the object. The returned object has the following properties: Property name | Type | Default value | Description\n--------------- | -------------------- | ----------------------- | --------------------------------------------------------------------------------------------------------------------------------------------\nHost | string (read-only) | \"\" | The host of the WebSocket connection\nWebSocketId | string (read-only) | \"\" | The unique ID of the WebSocket connection\nIsSSLEncrypted | boolean(read-only) | false | Is the WebSocket connection secure?\nClientIP | string (read-only) | \"0.0.0.0\" | The IP of the connected client\nConnectedAt | string (read-only) | \"0001-01-01 00:00:00\" | The date and time when the connection was established\nCurrentTerminal | string (read-only) | \"\" | The type name of the current terminal resource attached to this WebSocket\nCustomHeaders | object | {} | The custom headers for this WebSocket. Other headers, such as Authorization, cannot be viewed or modified here The content of CustomHeaders can be changed. To add a header X-MyHeader with value \"MyValue\", we can use the following global command: Running this command redirects the WebSocket to the RESTable.Shell resource. Running this command closes the WebSocket connection and disposes all attached resources. Streaming WebSocket streaming is a useful feature in RESTable, that allows any terminal resource to send an arbitrarily large dataset over a WebSocket connection. The dataset is split into multiple WebSocket messages, which are made available to the client for download. The RESTable.Shell resource, for example, uses streaming whenever the response body is larger than 16 megabytes. The streaming consists of three steps: While a response is streaming to a WebSocket client, all other activity is suspended to and from the terminal resource. When the streaming is concluded, messages from the terminal that was sent during the streaming are sent to the client. The stream manifest is represented as a JSON object that describes the process of streaming a response from the server to the client, and the current state within that process. It has the following format: Property name | Type | Description\n----------------- | ------------------ | ----------------------------------------------------------------------------------\nTotalLength | integer | The total length of the streaming response body in bytes\nBytesRemaining | integer | The number of bytes remaining to stream\nBytesStreamed | integer | The number of bytes already streamed\nNrOfMessages | integer | The number of messages in the streaming job\nMessagesRemaining | integer | The number of messages left to stream\nMessagesStreamed | integer | The number of messages already streamed\nContentType | string | The MIME type string of the content type that the response body is encoded in\nEntityType | string | The name of the type of the entities contained in the response body\nEntityCount | integer | The number of entities contained in the response body\nMessages | array of Message | The messages of the streaming job\nCommands | array of Command | The available commands that can be used by the client to control the streaming job When streaming is initiated, the stream manifest is automatically sent back to the client. The client can then control the streaming process using the commands contained in the Commands array of the stream manifest. Property name | Type | Description\n------------- | --------- | -----------------------------------------------------------------------------\nStartIndex | integer | The start index of this message, as a location within the total response body\nLength | integer | The length of the message\nIsSent | boolean | Has this message been sent? Property name | Type | Description\n------------- | -------- | ---------------------------------\nCommand | string | The text command\nDescription | string | A description of the text command For this example, let's stream the content of the Superhero resource available the demo service. For the purpose of the demo, let's use a small buffer size of 8 KB. First, we connect, set the StreamBufferSize property of Shell and use the STREAM text command to create a stream manifest. For more information on how to use the RESTable.Shell resource, see this documentation As we can see, the current stream job has five messages, and a total length of 35116 bytes. We can also see that five commands – GET, NEXT, NEXT , MANIFEST and CLOSE – are available from here. Let's get the first message. The response above is abbreviated. When we request a message to be streamed, the stream manifest is updated accordingly. We can always get the current state of the streaming job by reprinting the manifest using the MANIFEST command.","excerpt":"Consuming terminal resources Terminal resources are small single-purpose console applications that can be launched and closed by REST clients. We interact with terminal resources using the WebSocket protocol, and to launch a terminal resource, we mak","tags":"","url":"/inal%20resources"},{"title":"Introduction","text":"Introduction This part of the documentation provides a technical specification of the RESTable protocol, used to consume the web services provided by a RESTable application, for example a Mopedo DSP. RESTable can be setup to support additional protocols, for example OData, but for now, let's focus on the default protocol. We will only describe the format of REST requests and responses here. For a description of the actual web resources of a specific application – for example the User and Site resources of the Mopedo DSP application, see the documentation provided for that application. As an API consumer, the application administrator will make resources available for you by creating API keys, and binding certain web resources and methods to them. Different API keys can have different access rights, so make sure to keep your API key secure. When you know the location of the web service – that is – its URI, and your assigned API key, you are ready to begin sending requests to the service.","excerpt":"Introduction This part of the documentation provides a technical specification of the RESTable protocol, used to consume the web services provided by a RESTable application, for example a Mopedo DSP. RESTable can be setup to support additional protoc","tags":"","url":"/"},{"title":"URI","text":"URI Request URIs contain three parts that specify three important components of the request. These components are: The grammar section below gives a formal description of the format of request URIs. Before we dive into that, let's look at an informal one. URIs begin with a URL to the API. For our demo service, this is: Now, in order – for each of the three URI parts mentioned above – we add a forward slash /, and either an underscore _ (if the part should be left blank) or the part to include. If we want to include superhero as the resource, and limit=2 as meta-conditions, for example, we can produce the following URI: See the links in the URI part list above for how they are written in URIs. Grammar RESTable request URIs have the following grammar (EBNF): Notes Case sensitivity All components in URIs are case-insensitive, except for value literals. When comparing, for example, the value of a string property in an entity with another value, the REST API makes difference between string values \"steve\" and \"Steve\". It's, however, always safe to treat all URI components as case sensitive. Evaluation order Each request can contain instructions for several operations, triggered by conditions and meta-conditions, that are carried out in a pre-defined order. – Entities are first filtered according to the conditions. search – Search filters are applied. add – Additional properties are added. rename – All rename schemes are applied. select – Properties are filtered according to the select property locator list. distinct – Non-distinct entities are skipped. order_desc / order_asc – The entities are ordered. offset – The offset is applied. limit – The number of entities are limited. This means that if many of select, rename or add are used in the same request – property locators in select cannot make references to properties that have been renamed, but can reference added properties. rename can also reference added properties.","excerpt":"URI Request URIs contain three parts that specify three important components of the request. These components are: The grammar section below gives a formal description of the format of request URIs. Before we dive into that, let's look at an informal","tags":"","url":"/"},{"title":"Methods","text":"Methods RESTable accepts eight common HTTP methods in requests to entity resources. GET GET requests returns all entities in the selected resource that match a given set of conditions. If no conditions are given, all entities in the resource are returned. POST POST inserts an entity or a list of entities from a data source into the selected resource. PATCH PATCH updates one or more existing entities in the selected resource, identified by a given set of conditions. If no entity is found by matching against conditions, a 404 response is returned. To update multiple entities with a single request, which is a potentially unsafe operation, include unsafe=true as meta-condition. Matched entities are updated with the content from a provided entity, from a data source. PUT PUT is the duplicate-safe way to insert new entities in a resource. PUT will find any single existing entity in the selected resource matched by a given set of conditions. If no entity is found, a POST will be made to the resource with the entity provided from a data source. If an entity is found, a PATCH will be made on that entity with the content from an entity provided from a data source. If more than one entity is found, a 400 response is returned. DELETE DELETE will find all entities in the selected resource matched by a given set of conditions. If only one entity was found, that entity will be deleted from the resource. If more than one entity was found, a 400 response is returned. To override this behavior and delete all found entities, which is a potentially unsafe operation, include unsafe=true as meta-condition. REPORT REPORT performs a GET request, but instead of returning representations of resource entities selected by the request, the number of entities is returned. REPORT, as implemented in RESTable, is technically a variant of GET, and all resources supporting GET, also supports REPORT. All API keys that have GET access to a resource, also have REPORT access. All REPORT requests have the same response body format: Properties marked in bold are required. Property name | Type | Description\n------------- | --------- | ----------------------------------------------\nCount | integer | The number of entities selected by the request HEAD HEAD performs a GET request, but instead of returning representations of resource entities selected by the request, only the response headers are returned. HEAD is technically a variant of GET, and all resources supporting GET, also supports HEAD. All API keys that have GET access to a resource, also have HEAD access.","excerpt":"Methods RESTable accepts eight common HTTP methods in requests to entity resources. GET GET requests returns all entities in the selected resource that match a given set of conditions. If no conditions are given, all entities in the resource are retu","tags":"","url":"/"},{"title":"Request overview","text":"Request overview Requests to the REST API of a RESTable application are standard HTTP requests. Encoded in a request is all information necessary to perform a certain operation on a given resource. RESTable has [multiple resource kinds](), that have slightly different methods of interaction, but let's stick with [entity resources]() for now, since they are the ones most commonly used. To further explore the components of HTTP requests to a RESTable application, use the links below: Method Methods define the operation to perform on the selected resource URI URIs select the resource to operate on, and contain additional instructions for how the request should be processed. Headers Headers define high-level request parameters like authorization and content types. Body The body of the request is used to communicate content, for example a JSON representation of an entity, to the REST API. Examples The easiest way to familiarize oneself with how to consume a RESTable API, is to make real requests to an actual RESTable API. For this purpose, feel free to use our test API. The URI examples below are written as relative URIs for the sake of brevity, but you can generate an absolute URI from them by pasting them directly after the root URI of the remote test service. The relative uri /superhero would generate the absolute URI https://RESTablehelp.mopedo-drtb.com:8282/api/superhero. Note that the test service only supports GET, REPORT and HEAD requests. For all requests, the Authorization header has the value apikey RESTable. Some example URIs:","excerpt":"Request overview Requests to the REST API of a RESTable application are standard HTTP requests. Encoded in a request is all information necessary to perform a certain operation on a given resource. RESTable has [multiple resource kinds](), that have ","tags":"","url":"/ew"},{"title":".NET API reference","text":".NET API reference This part of the documentation lists and details all the public types available in the RESTable .NET API. It's useful when developing RESTable applications. The types of the RESTable .NET API are distributed over the following namespaces: Namespace | Description\n:----------------------------------------------------------- | :-------------------------------------------------------------------------------------------\nRESTable | Common multi-purpose types\nRESTable.Admin | Types for API administration\nRESTable.ContentTypeProviders | Available [content type providers**]() and tools for defining custom content type providers.\nRESTable.Linq | asd\nRESTable.Meta | asd\nRESTable.NetworkProviders | asd\nRESTable.ProtocolProviders | asd\nRESTable.Requests | asd\nRESTable.Resources | asd\nRESTable.Results | asd\nRESTable.WebSockets | asd","excerpt":".NET API reference This part of the documentation lists and details all the public types available in the RESTable .NET API. It's useful when developing RESTable applications. The types of the RESTable .NET API are distributed over the following name","tags":"","url":"/rence"},{"title":"Responses","text":"Responses Error responses If something goes wrong while evaluating a request, the REST API will respond with either a 4XX or 5XX status code and a description of the error in the RESTable-info response header. Errors that are not 403: Forbidden are also stored in the RESTable.Error resource. Success responses Code | Status description | Body | Info\n---- | ------------------ | -------- | ---------------------------------------------------\n200 | OK | entities | If entities are found, representations are included\n204 | No content | empty | RESTable has multiple built-in output formats, and the administrator can also add new ones. This makes it easy to conform JSON output to external standards. The administrator can create new output formats and set default formats using the RESTable.Admin.OutputFormat resource. The consumer can switch between output formats on a per-request basis using the format meta-condition. Code | Status description | Body | Notes\n---- | ------------------ | ------- | ----------------------------\n201 | Created | empty |\n200 | OK | empty | If no entities was inserted. Code | Status description | Body | Notes\n---- | ------------------ | ------- | -------------------------------\n200 | OK | empty | Even if no property was changed Code | Status description | Body | Notes\n---- | ------------------ | ------- | ------------------------\n201 | Created | empty |\n200 | OK | empty | If an entity was updated Code | Status description | Body | Notes\n---- | ------------------ | ------- | -----\n200 | OK | empty | Code | Status description | Body | Notes\n---- | ------------------ | ----------- | -----\n200 | OK | report body | All successful responses from REPORT requests share the same body format: Property name | Type | Description\n------------- | --------- | ----------------------------------------------\nCount | integer | The number of entities selected by the request Code | Status description | Body | Info\n---- | ------------------ | ------- | ---------------------\n200 | OK | empty | Only response headers\n204 | No content | empty | Custom response headers RESTable uses the following custom HTTP headers to include meta-data in responses. These do not include standard HTTP headers like Content-Type, Content-Length etc. Information about the result of the request, if any. For POST requests, for example, RESTable-info contains the number of inserted entities. For any error response, a description of the error. For error responses, RESTable-error contains a link to the RESTable.Admin.Error entity describing this particular error. For all other responses, this header is excluded. The number of milliseconds elapsed during the evaluation of the request. For GET and HEAD requests, RESTable-count contains the number of entities encoded in the response body. See pagination below. The version of the RESTable package of the RESTable application that generated the response. Pagination RESTable supports client-side pagination using the and limit and offset meta-conditions in GET requests. To break a list of 1000 employees into ten pages with 100 per page – using client-side pagination – we use these URIs: To simplify this pattern, RESTable will include a header RESTable-pager in paginated GET responses – that is, responses that do not include the last entity from the enumeration of resource entities that was used to generate the response. The value of this header will be whatever the limit and offset meta-conditions need to be set to in the next request in order to return the next equally sized page of entities from the RESTable application. This means that the consumer can paginate a resource's entire content without knowing how many pages there will be. The User resource contains a large number of entities – the consumer does not know how many. The consumer can still get all User entities, 1000 at a time, without first counting users and determining how many requests should be made. First, the consumer gets the first 1000 entities with URI: The response will be: For the next page, the consumer can copy the value of the RESTable-pager header and place in the next request. URI for page 2: And so on until either a 204: No content response is encountered, or there is no RESTable-pager header in the response (which means that the last entity in the enumeration was included in the response).","excerpt":"Responses Error responses If something goes wrong while evaluating a request, the REST API will respond with either a 4XX or 5XX status code and a description of the error in the RESTable-info response header. Errors that are not 403: Forbidden are a","tags":"","url":"/"},{"title":"Content type providers","text":"Content type providers A content type provider defines serialization and deserialization operations for a content type. Content types are data formats that can be used in RESTable input and output, and using content type providers – we can add additional content types to a RESTable application. Content type providers bind logic to a MIME type, which is defined as a string, for example application/json. When receiving requests, RESTable will pick the appropriate content type provider to use when deserializing input data from the content of the Content-Type header, and the appropriate content type provider to use when serializing output data from the content of the Accept header. Included content type providers These three protocol providers are already included with RESTable. You can also list all available protocols and their content providers by making a GET request to the RESTable.Admin.Protocol resource. The JsonContentProvider is the default JSON content type provider for reading and writing JSON, and handles requests that have the following MIME types defined in their Accept or Content-Type headers: Since custom content type providers can override bindings to MIME types, a special application/RESTable-json is used to preserve a binding, should the client need to use the JsonContentProvider while application/json is overridden. There is a public static JsonContentProvider instance available at RESTable.Serialization.Serializers.Json, that can be used in RESTable applications to serialize, deserialize and populate RESTable JSON. The ExcelContentProvider is used to read and write Excel files. It has the following MIME type bindings: The XMLWriter can be used to write responses to XML. It can, however – unlike the other two included content type providers – not deserialize entities. It has the following MIME type bindings: Creating custom content type providers To create a custom content type provider, implement the IContentTypeProvider interface. It has the following definition: To use a custom content type provider, include an instance of it in the contentTypeProviders parameter in the call to RESTableConfig.Init().","excerpt":"Content type providers A content type provider defines serialization and deserialization operations for a content type. Content types are data formats that can be used in RESTable input and output, and using content type providers – we can add additi","tags":"","url":"/providers"},{"title":"Binary resources","text":"Building binary resources Nothing here yet","excerpt":"Building binary resources Nothing here yet","tags":"","url":"/ces"},{"title":"Getting started","text":"Getting started RESTable is distributed as a .NET package on NuGet, and an easy way to install it in an active Visual Studio project is by entering the following into the NuGet Package Manager console: If you're running Starcounter 2.4 or later, there is a version of RESTable for that as well. Use the following: The installation will also download some other packages that are required for RESTable to work. RESTable itself, however, is contained within a single assembly, RESTable.dll. When RESTable is installed, add a call to the RESTable.RESTableConfig.Init() method somewhere in your application logic, preferably so it runs once every time the app starts. This method will set up the RESTable HTTP handlers, and collect all your registered REST resources. Below is a simple RESTable application, picked from the RESTable Tutorial Repository: See this page for details on what can be specified in the call to RESTableConfig.Init().","excerpt":"Getting started RESTable is distributed as a .NET package on NuGet, and an easy way to install it in an active Visual Studio project is by entering the following into the NuGet Package Manager console: If you're running Starcounter 2.4 or later, ther","tags":"","url":"/ed"},{"title":"Event resources","text":"Event resources This part of the documentation is not yet finished","excerpt":"Event resources This part of the documentation is not yet finished","tags":"","url":"/es"},{"title":"Introduction","text":"Introduction The main purpose of RESTable, as a software framework, is to facilitate a unified REST interface between external HTTP clients and the data that the application wants to expose, and to provide fast and powerful implementations for common tasks like request parsing, request authentication, database querying, data filtering and JSON serialization. By letting the RESTable framework deal with these complex (and boring) tasks, we can increase the level of abstraction, letting the application developer worry about less things and instead focus on the content and functionality of their respective apps. RESTable encourages a resource-oriented architecture (ROA) approach to application design, where the software engineering effort is focused around declaring and defining what is exposed to the REST API, i.e. the resources, as opposed to how it's exposed. RESTable is also designed to be easily integrated with new and existing Starcounter applications, but at the same time allow the developer to override some of the functionality to accommodate more advanced use cases. RESTable resources When building RESTable application, developers mainly work with defining resources – i.e. the data that should be available for consumption over the REST API of the RESTable application. There are four kinds of resources that can be defined in RESTable: Sets of data entities, for example rows in a database table. These entities can be filtered and serialized to some content type, for example JSON Read-only binary data streams that are delivered directly to clients Small single-purpose console applications that are consumed using WebSocket connections Events are raised by the RESTable application and can be used to trigger actions, for example webhooks Each of these have their own section of the documentation, focused on how to build them. Common to all resource definitions in RESTable is that they are declarative in nature, much due to the fact that the concept of a resource in RESTable is closely coupled with a declarative component of .NET – class declarations.","excerpt":"Introduction The main purpose of RESTable, as a software framework, is to facilitate a unified REST interface between external HTTP clients and the data that the application wants to expose, and to provide fast and powerful implementations for common","tags":"","url":"/"},{"title":"Internal requests","text":"Internal requests A RESTable REST API is most commonly consumed by a REST client, that is – an application that speaks HTTP and JSON. Sometimes, however, it's useful to send internal requests from other parts of your Starcounter application, and interact with your entity resources without having to make unnecessary HTTP requests with string parsing and JSON serialization. If all RESTable entity resources were Starcounter database tables, this would not be a problem – since we could just interact with them directly using Db.Transact and Db.SQL. But since RESTable can have a wide variety of different resources, a unified interface for querying and manipulating them is needed. For this, we use the generic RESTable.Request class where T is the entity resource type we want to interact with. Request instances do not work with terminal types. Internal requests have the same main components as HTTP requests, but are much faster since they bypass request parsing, authentication and JSON serialization. They follow the same philosophy of RESTful web services in general – but without the HTTP layer. These are the public members of the Request class: Internal requests best practices For Starcounter database resources, RESTable will automatically execute the provided delegates inside transaction scopes, so there is no need to include transactions in inserter and updater lambdas. Another way to make internal REST requests is by using the Starcounter.Self class, but these are significantly slower, require authentication (if requireApiKey is set to true in the call to RESTableConfig.Init()), and are not as flexible in terms of type safety and error handling. Performance-wise, it's recommended to reuse Request objects whenever possible. When doing repetitive requests internally, it's best to keep a static Request object, and just replace the conditions between usages. RESTable provides a namespace RESTable.Linq, with a static class Conditions which contains useful methods for working with conditions of internal requests. Request objects can be very fast if used properly, especially for Starcounter database resources. When changes are made to their conditions, a Starcounter SQL query will be generated and cached within the Request object, which means that consecutive SQL queries for the same Request object are very fast. Request objects are frequently used internally within RESTable. Examples","excerpt":"Internal requests A RESTable REST API is most commonly consumed by a REST client, that is – an application that speaks HTTP and JSON. Sometimes, however, it's useful to send internal requests from other parts of your Starcounter application, and inte","tags":"","url":"/ests"},{"title":"Protocol providers","text":"Protocol providers A protocol provider is an add-on for RESTable that lets protocols other than the built-in protocol be used for defining the formats of API requests and responses. The built-in protocol is what is described in the Consuming a RESTable API section of the documentation. Using a custom protocol provider, however, a developer could decide to use a completely different set of URI conventions or response formats, but still use most of the inner workings of RESTable for declaring, finding, querying and manipulating resources. To create a protocol provider, make a new .NET class and have it implement the RESTable.IProtocolProvider interface. It has the following definition: To use a custom IProtocolProvider instance in a RESTable application, include it in the protocolProviders parameter of the call to RESTableConfig.Init(). See also: Content type providers. For a concrete example, see the RESTable.OData protocol provider.","excerpt":"Protocol providers A protocol provider is an add-on for RESTable that lets protocols other than the built-in protocol be used for defining the formats of API requests and responses. The built-in protocol is what is described in the Consuming a RESTab","tags":"","url":"/iders"},{"title":"RESTableMemberAttribute","text":"RESTableMemberAttribute RESTable has built-in member reflection for resource types, which is how it defines the JSON and Excel templates that are used during serialization and deserialization and how it creates bindings between, for example, JSON representations and instances of the actual .NET classes. We can configure the reflected resource properties by decorating their declarations with the RESTableMemberAttribute attribute and including options in its constructor. The constructor for RESTableMemberAttribute has the following signature: ignore Should this property be completely ignored by RESTable? name A new name for this property that is used instead of the declared name in all representations. order The order at which this property appears when all properties are enumerated. hide Should this property be hidden in serialized output by default? It can still be added using the add meta-condition and queried against. hideIfNull Should this property be hidden in output if the value is null? Only applies to JSON output. readOnly Makes this property read-only over the REST API, even if it has a public setter. skipConditions Sets the Skip property of all conditions matched against this property to true by default, skipping all conditions that are made to this property. allowedOperators These operators will be allowed in conditions targeting this property. excelReducer The name of an optional public ToString-like method, declared in the same scope as the property, that reduces the property to an Excel-compatible string. replaceOnUpdate Should this object be replaced with a new instance on update, or reused? Applicable for types such as Dictionaries and Lists. Non-RESTable attributes that are respected We can also change how RESTable treats certain properties of resources by using the .NET standard IgnoreDataMemberAttribute and DataMemberAttribute attributes (located in the System.Runtime.Serialization namespace). Using these attributes, we can, for example, rename properties and ignore properties when serializing and deserializing from JSON (and Excel). For more information, see the Microsoft documentation. The JSON.net JsonPropertyAttribute is also respected.","excerpt":"RESTableMemberAttribute RESTable has built-in member reflection for resource types, which is how it defines the JSON and Excel templates that are used during serialization and deserialization and how it creates bindings between, for example, JSON rep","tags":"","url":"/rAttribute"},{"title":"RESTableConfig.Init","text":"RESTableConfig.Init() This is the complete method signature for RESTableConfig.Init(): By changing the values of these parameters, you can configure RESTable to best serve your current application. port The port parameter controls which HTTP port to register the RESTable handlers on. One Starcounter HTTP handler is registered on this port for each of the following HTTP verbs: GET, POST, PATCH, PUT, DELETE, OPTIONS. uri The uri parameter is what is used for the root uri of the REST API. If the application is deployed locally, and the port parameter is set to 8282, the RESTable API will be listening for requests on http://localhost:8282/rest. requireApikey To require authentication and authorization for all requests using API keys, set this parameter to true. If set to true, it's required to include a configuration file path in the configFilePath parameter. allowAllOrigins To require the administrator of the application to whitelist all CORS origins that are allowed to make requests to this application, set the allowAllOrigins parameter to false. If set to false, it's required to include a configuration file path in the configFilePath parameter. configFilePath When either requireApikey is set to true or allowAllOrigins is set to false, RESTable needs a configuration file to read API keys and/or whitelisted CORS origins from. How to administrate API keys and CORS origins is covered in the Administering a RESTable API section, but the path to the file needs to be provided by the developer. prettyPrint The prettyPrint parameter controls whether JSON output from RESTable is \"pretty printed\", that is – indented – to increase human readability. daysToSaveErrors When the REST API aborts operations due to some error, for example a format error in the incoming request, information about the error is stored in the RESTable.Admin.Error resource. The daysToSaveErrors parameter controls after how many days the error should be deleted from the log. lineEndings By default, RESTable will use windows line endings, \\r\\n, in serialized JSON output. To change this to linux line endings, \\n, set the value of lineEndings to LineEndings.Linux. resourceProviders RESTable has support for add-ons in the form of resource providers. They provide a way to standardize RESTable operations for some data storage technology – for example SQLite. To include a resource provider in the RESTable instance, add it to a collection and assign to this parameter. protocolProviders RESTable can also take add-ons in the form of protocol providers, objects that contain the logic for parsing requests and generating responses according to some external protocol, for example OData. To include a protocol provider in the RESTable instance, add it to a collection and assign to this parameter. contentTypeProviders A third type of RESTable addon is content type providers. They add support for additional content types that can be used to read and write data from a RESTable application. Three content type providers (JSON, Excel, and XML) are already included with RESTable, but any additional providers must be added here.","excerpt":"RESTableConfig.Init() This is the complete method signature for RESTableConfig.Init(): By changing the values of these parameters, you can configure RESTable to best serve your current application. port The port parameter controls which HTTP port to ","tags":"","url":"/g.Init"},{"title":"Demo service","text":"Demo service While exploring the RESTable documentation, feel free to use this demo server and API key: Using a REST client Using your REST client of choice (Postman is a good one), send an HTTP GET request to the URI above, and include \"apikey RESTable\" as the value of the Authorization header. The response you see contains a list of all resources made available for the API key \"RESTable\". One such resource is the RESTableTutorial.Superhero resource, on which only GET requests are allowed. To query this particular resource, use the following URI: You will now see the contents of the RESTableTutorial.Superhero entity resource – that is – all Superhero entities. To only list superheroes with secret identities, use the following URI: This is the basics of how to consume a RESTable API using HTTP requests. URIs are used to specify what resource and what entities within a resource to operate on, the method specifies what operation to perform (for example GET), and headers like Authorization are used to pass additional information to the web service. Using WebSockets The most flexible way to explore the web resources of a RESTable service is to plug in to its Shell resource using a WebSocket connection. To connect to the demo service, use a WebSocket client like wscat or this chrome extension, with this URI: An introduction to how to work with WebSockets and connect to the demo service can be found here.","excerpt":"Demo service While exploring the RESTable documentation, feel free to use this demo server and API key: Using a REST client Using your REST client of choice (Postman is a good one), send an HTTP GET request to the URI above, and include \"apikey RESTa","tags":"","url":"/"},{"title":"Registering resources","text":"Registering resources This part of the documentation is not yet finished","excerpt":"Registering resources This part of the documentation is not yet finished","tags":"","url":"/esources"},{"title":"Terminal resources","text":"Building terminal resources RESTable supports custom terminal resources, so developers can create their own interactive WebSocket applications that are published in the REST API. This part of the documentation is not yet finished","excerpt":"Building terminal resources RESTable supports custom terminal resources, so developers can create their own interactive WebSocket applications that are published in the REST API. This part of the documentation is not yet finished","tags":"","url":"/urces"},{"title":"Troubleshooting","text":"Troubleshooting This article contains some infamous problems that can occur when developing RESTable applications, and how to solve them: SCERR2143 Example: This error is almost always related to the application's weaver.ignore file. The Starcounter Weaver cannot deal with strong-named assemblies, abd we therefore need to include them in the application's weaver.ignore file. Add the following assemblies to the application's weaver.ignore file, or create a new text file called weaver.ignore in your project output folder with the content from the link. SCERR2147 Example: As far as we have found out, this can be caused by three things:","excerpt":"Troubleshooting This article contains some infamous problems that can occur when developing RESTable applications, and how to solve them: SCERR2143 Example: This error is almost always related to the application's weaver.ignore file. The Starcounter ","tags":"","url":"/ng"},{"title":"HTTPS","text":"HTTPS To protect the integrity of HTTP requests to the REST API, which is especially important when sending sensitive information like customer information or API keys, it's recommended that an HTTPS compatible web server is set up next to the REST API, which then routes requests to the REST API using reverse proxy. Starcounter 2.3.2, which is the version currently targeted by RESTable, has no native support for HTTPS and SSL, but it's easy to implement a secure solution using tools already included in Windows Server. Mopedo has an article on how to create a reverse proxy using Microsoft IIS. All you need is a registered domain and an SSL certificate. Starcounter also provides the following guides for setting up HTTPS for Starcounter servers:","excerpt":"HTTPS To protect the integrity of HTTP requests to the REST API, which is especially important when sending sensitive information like customer information or API keys, it's recommended that an HTTPS compatible web server is set up next to the REST A","tags":"","url":"/"},{"title":"Dynamic resources","text":"Dynamic resources Dynamic resources are persistent entity resources that have no pre-defined schemas. They can be changed not only in content, but in structure as well, and even created during runtime. They do, however, have some limitations due to their dynamic nature. This article will cover their basics. Dynamic resources in RESTable are Dynamit DDictionary entities. Dynamit is a free to use and open-source class library for creating dynamic table definitions in Starcounter. To illustrate the difference between dynamic and non-dynamic – static – resources, consider the object-oriented programming concept object, and its standard implementations in Java and JavaScript respectively. In Java – which is class-based – objects are static with regards to their members, and this structure is defined in compile-time in a class definition. We can change the contents of objects – that is, assign values to instance variables – during runtime, but we cannot change the structure of objects without first recompiling the application. In JavaScript – which is prototype-based - however, both the content and the structure of objects can change during runtime. Entities of dynamic resources behave like JavaScript objects in this regard. There is no common schema of property names and types that applies to all entities in a dynamic resource, and their members can have any name and data type, regardless of members and types of other entities in the same resource. The advantages and disadvantages of dynamic resources are the same as for the dynamic objects of JavaScript, their biggest advantage being, of course, their runtime flexibility. Dynamic resources can be created and deleted in runtime, and properties and property types can be added, changed or deleted in runtime. This flexibility makes them easy to use while importing data, since entities in the data source can have any structure. Dynamic resources are, however, slower than static resources, and are not type-safe in the same way that static resources are. Dynamic resources are automatically placed in the RESTable.Dynamic namespace, so their access rights can be controlled like any other resources. To restrict a set of dynamic resources to only some consumers, the administrator can either add them separately as access rights to their API keys, or place the resources in a common namespace using naming, for example RESTable.Dynamic.MyInnerNamespace, which can then be targeted with API keys. To manage the dynamic resources of a RESTable application, use the RESTable.Dynamic.Resource meta-resource. Example To create a new dynamic resource, insert an entity into RESTable.Dynamic.Resource: We can now insert whatever we like into our new resource:","excerpt":"Dynamic resources Dynamic resources are persistent entity resources that have no pre-defined schemas. They can be changed not only in content, but in structure as well, and even created during runtime. They do, however, have some limitations due to t","tags":"","url":"/"},{"title":"JSON output formats","text":"JSON Output formats Sometimes when RESTable applications are consumed from other systems, for example dashboard systems like Bime or other RESTful web services, the JSON output from the RESTable application needs to conform to some external standard, for example JSend. RESTable supports placing the JSON array produced by the GET request to some resource inside an arbitrarily defined JSON object structure - and the format can be set on a per-request basis using the format meta-condition. For more information, and how to work with JSON output formats, see the documentation for the RESTable.Admin.OutputFormat resource.","excerpt":"JSON Output formats Sometimes when RESTable applications are consumed from other systems, for example dashboard systems like Bime or other RESTful web services, the JSON output from the RESTable application needs to conform to some external standard,","tags":"","url":"/"},{"title":"Macros","text":"Macros Macros is a powerful feature of RESTable, that allows an administrator to create pre-defined requests that are used as syntactic templates, pre evaluation, to fill in properties for incoming API requests. Macros can be used to replace the URI, body or headers of calling requests. They enable advanced use cases such as simplifying complicated and often repeated requests or enabling integration with REST clients that cannot make certain requests, etc. For more information, and how to manage Macros, see the documentation for the RESTable.Admin.Macro resource.","excerpt":"Macros Macros is a powerful feature of RESTable, that allows an administrator to create pre-defined requests that are used as syntactic templates, pre evaluation, to fill in properties for incoming API requests. Macros can be used to replace the URI,","tags":"","url":"/"},{"title":"ResourceProfile","text":"ResourceProfile The ResourceProfile resource gives support for profiling memory usage and calculating the sizes of Starcounter database tables, and other resources that support profiling. In the case of Starcounter database tables, it uses a simple algorithm for estimating table sizes, and should not be considered a valid absolute size calculation. It's, however, useful for determining the relative sizes of tables. Format Property name | Type | Description\n---------------- | -------------- | -----------------------------------------------------------------------\nResource | string | The name of the profiled resource\nNumberOfEntities | string | The number of entities in the resource\nApproximateSize | ResourceSize | An approximation of the resource size in memory or on disk\nSampleSize | string | The size of the sample used to generate the resource size approximation ResourceSize Property name | Type | Description\n------------- | --------- | ---------------------\nBytes | integer | The size in bytes\nKB | float | The size in kilobytes\nMB | float | The size in megabytes\nGB | float | The size in gigabytes","excerpt":"ResourceProfile The ResourceProfile resource gives support for profiling memory usage and calculating the sizes of Starcounter database tables, and other resources that support profiling. In the case of Starcounter database tables, it uses a simple a","tags":"","url":"/"},{"title":"OutputFormat","text":"OutputFormat The OutputFormat resource contains all available JSON ouput formats used by RESTable when serializing response bodies of GET requests. An output format is essentially a JSON object tree that contains exactly one occurrence of the $data macro (not to be confused with RESTable macros in general). The $data macro is used simply to define where in the JSON tree to insert the entity array generated when serializing the output from the GET request. Format Property name | Type | Description\n------------- | -------------------- | -------------------------------------------------------------\nName | string | The name of the output format\nPattern | string | The output format pattern\nIsDefault | boolean | Is this the default output format?\nExample | object (read-only) | An example of how output would be serialized with this format Output format pattern Formats are written as escaped JSON strings, and need to contain exactly one occurrence of the $data macro – specifying where to insert the JSON array generated by the GET request. Serializing data with the pattern above would result in the following JSON object tree:","excerpt":"OutputFormat The OutputFormat resource contains all available JSON ouput formats used by RESTable when serializing response bodies of GET requests. An output format is essentially a JSON object tree that contains exactly one occurrence of the $data m","tags":"","url":"/"},{"title":"Macro","text":"Macro Macros is a powerful feature of RESTable, that enables great flexibility when making REST requests, particularly when the REST client cannot send certain request components due to technical limitations. Macros are syntactic request templates that add pre-defined properties to incoming requests ahead of evaluation. Macros can syntactically insert the following request components ahead of evalution: Macros do not contain a method definition – the method is always kept in all calls to a macro. The same macro can be used with all methods. Format Properties marked in bold are required. Property name | Type | Description\n---------------- | ----------------------------- | --------------------------------------------------------------\nName | string | The name of the macro. Used in macro calls.\nUri | string | The URI to use in the resulting request\nBody | object or array of object | The body to use in the resulting request\nHeaders | object | The headers to use in the resulting request\nOverwriteBody | boolean | Should the macro overwrite the body of the calling request?\nOverwriteHeaders | boolean | Should the macro overwrite the headers of the calling request? Recursive macro calls It is possible to design macros that generate requests that in turn call macros – for example using the RESTable.Aggregator resource. These recursive requests can sometimes be hard to debug, but RESTable is designed to handle them. Potentially infinite recursive call loops are automatically aborted. Resource All macros have a specified resource that is inserted into the request upon macro call. The calling request will simply specify the macro name in place of the resource specifier, which will result in a call to whatever resource defined in the macro. Macro definition: Macro call: Rewritten request: View Views that are part of the Uri property will be used unless the calling request has some other view defined. Conditions The conditions specified in the macro are concatenated with and placed ahead of whatever conditions are included in the request calling the macro. Macro definition: Macro call: Rewritten request: Meta-conditions Same as for conditions, the meta-conditions specified in the macro are concatenated with and placed ahead of whatever meta-conditions are included in the request calling the macro. Macro definition: Macro call: Rewritten request: Body Macros can, optionally, define a body that is inserted into the request calling the macro. If a body is specified in the macro, it's used in the request calling the macro, unless the calling request already contains a body. If and only if OverwriteBody is set to true, macro bodies overwrite bodies included in caller requests. Bodies are given as objects directly in the macro object structure. Macro definition: Macro call: Rewritten request: Headers The macro can contain headers that are added to whatever request headers included in the request calling the macro. Headers are given as objects in the macro object structure, with the property name being the header name. Header values are always inserted as strings in the request calling the macro - regardless of data type in the macro. The only header not allowed in macros is the Authorization header. All macro requests are expected to contain their own means of authentication. If and only if OverwriteHeaders is set to true, will macro headers overwrite headers included in caller requests. Macro definition: Macro call: Rewritten request:","excerpt":"Macro Macros is a powerful feature of RESTable, that enables great flexibility when making REST requests, particularly when the REST client cannot send certain request components due to technical limitations. Macros are syntactic request templates th","tags":"","url":"/"},{"title":"ResourceAlias","text":"ResourceAlias The ResourceAlias resource includes all the aliases that have been assigned to some resource. To add a new alias to some resource, use the Alias property of the corresponding RESTable.Admin.Resource entity. Only GET and DELETE are available for the ResourceAlias resource. Format Property name | Type | Description\n------------- | -------- | ---------------------------------------------------\nAlias | string | The alias string\nResource | string | The name of the resource for which this is an alias","excerpt":"ResourceAlias The ResourceAlias resource includes all the aliases that have been assigned to some resource. To add a new alias to some resource, use the Alias property of the corresponding RESTable.Admin.Resource entity. Only GET and DELETE are avail","tags":"","url":"/"},{"title":"Webhook","text":"Webhook Webhooks are custom HTTP callback operations that are triggered by events that are raised by the RESTable application, and that generate HTTP requests with data that can be directed to either a local resource or a remote server on the internet. An introduction to webhooks is provided here. The Webhook resource contains all webhooks currently added to the RESTable application. Webhooks consist of the following components: Webhook request bodies When triggered by an event, the webhook will by default use the event payload as body for the outgoing HTTP request. How the payload is converted to a request body depends on the data type of the event payload, as well as the configuration of the webhook. If the event payload is a binary data stream, it's used directly as body of th outgoing HTTP request, with the content type defined by the event as value of the Content-Type request header. Since the data is already serialized, the webhook cannot change the content type. If the payload consists of entities, they are serialized to binary data streams before used in the request body, and here the webhook can define the content type to use by setting the Content-Type header in Headers of the webhook. If no content type is set, JSON is used for entity payload serialization. When serializing entity payloads to JSON, note that RESTable always writes entity payloads to JSON arrays, regardless of the number of entities contained in the event payload. This behavior mirrors how responses from GET requests always contain arrays, even if there is just one entity in the response. Remote servers accepting calls from RESTable webhooks using JSON as content type should therefore always expect arrays when deserializing the bodies of incoming requests. Format Entities in the Webhook resource have the following format: Properties marked in bold are required. Property name | Type | Description\n-------------------- | ------------------------------------------------------ | --------------------------------------------------------------------------------------------------------\nId | string (read-only) | A unique ID for this webhook\nLabel | string | A descriptive label for this webhook\nMethod | Method | The method to use in the triggered request. Default is POST\nDestination | string | The destination URI for this webhook. Can be relative or absolute\nEventSelector | string | The event selector to use for selecting the events that should trigger this webhook\nHeaders | object | The headers to include in the triggered request\nIsPaused | boolean | Is this webhook currently paused? Paused webhooks are skipped\nCustomPayloadRequest | CustomPayloadRequest | An optional local request to use when fetching event data to include as payload in the triggered request Event selectors Event selectors are URI strings that select event resources. Their syntax is identical to regular request URI strings, but cannot contain meta-conditions. Just like request URIs, they contain a resource and conditions, and the conditions are used to filter out events based on the properties of their payloads. Imagine we have an event resource PersonCreated that has Person entities as payload. Events of this event resource type are raised every time a Person entity is created. Person entities, let's say, have string properties Name and Email. For a webhook listening on PersonCreated events, we can use the following event selectors: Custom payload requests Custom payload requests are local GET requests, selecting entities from a local entity or binary resource. If a CustomPayloadRequest instance is included in a Webhook definition, the resulting entities from evaluating the custom request is used instead of the data passed along with the event when defining the body of the outgoing HTTP request. Custom webhook requests are useful when we want to use an Event as simply a webhook trigger, but define the webhook request body from a separate data source. Just as with webhooks, we need to define an Authorization header if the current RESTable application is set up to require API keys. Properties marked in bold are required. Property name | Type | Description\n---------------- | ----------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------\nMethod | Method (read-only) | The method to use. Is always set to GET\nURI | string | The URI to use\nHeaders | object | The headers to include in the request. Make sure to include Authorization if the current RESTable application requires API keys\nBody | object or array of object | The body to use in the request\nBreakOnError | boolean | Should the outgoing webhook request be aborted if this custom request generates an error response? If false, the error message is sent.\nBreakOnNoContent | boolean | Should the outgoing webhook request be aborted if this custom request generates a 204: No content? If false, an empty request is sent. Example For this example, we have an entity resource Person. Entities of this resource can look like this: We also have an event resource PersonCreated that has Person entities as payload. These events are raised whenever a new Person entity is inserted. We can list all available event resources using a GET request to RESTable.AvailableResource, and in the result we see PersonCreated: To create a webhook listening for all occurances when a Person entity was inserted, has a name longer than 10 characters and the Email property is not null or empty, we can use the following event selector: Next, we want our webhook configured to send a POST request with the Person to a remote web service with URL https://example.com/person. We include apikey ABC123 in the Authorization header to authenticate our requests with the remote server. The complete webhook would be defined as:","excerpt":"Webhook Webhooks are custom HTTP callback operations that are triggered by events that are raised by the RESTable application, and that generate HTTP requests with data that can be directed to either a local resource or a remote server on the interne","tags":"","url":"/"},{"title":"WebhookLog","text":"WebhookLog The WebhookLog resource contains log items for instances when webhooks were triggered by events. Format Property name | Type | Description\n---------------- | --------------------------------------------------------- | -------------------------------------------------------------------------------------\nWebhookId | string | The ID of the webhook of this log item\nMethod | Method | The method of the webhook of this log item\nDestination | string | The destination of the webhook of this log item\nTime | datetime | The time when the log item was created\nIsSuccess | boolean | Does this log item encode a successful operation?\nResponseStatus | string | The response status for the outgoing HTTP request of the webhook\nBodyByteCount | integer | The number of bytes contained in the body of the outgoing HTTP request of the webhook\nWebhook (hidden) | Webhook | The webhook of this log item Hidden properties can be included in response bodies by using the add meta-condition in the request URI.","excerpt":"WebhookLog The WebhookLog resource contains log items for instances when webhooks were triggered by events. Format Property name | Type | Description\n---------------- | --------------------------------------------------------- | ---------------------","tags":"","url":"/"},{"title":"WebhookLogSettings","text":"WebhookLogSettings The WebhookLogSettings resource contains settings for how webhook log items are handled in the RESTable application. To return to defaults, delete the single entity in this resource. Format Properties marked in bold are required. Property name | Type | Description\n------------------ | ---------------------------------------- | ----------------------------------------------------------------------\nLastCleared | datetime (read-only) | The date and time when old items was last cleared from the webhook log\nDaysToKeepLogItems | integer | The number of days to keep webhook log items","excerpt":"WebhookLogSettings The WebhookLogSettings resource contains settings for how webhook log items are handled in the RESTable application. To return to defaults, delete the single entity in this resource. Format Properties marked in bold are required. P","tags":"","url":"/"},{"title":"Webhooks","text":"Webhooks Sometimes it's useful to make a web application send data to a remote computer, not only when the remote computer makes a request for it – for example using a GET request – but automatically when certain events occur on the server. We could, for example, have a notification resource in the RESTable application, where we add entities representing new notifications. The client could get the latest notifications using GET requests, but the solution is not really a useful unless the application has some way to push new notifications automatically to the client once they are created. For this purpose, we use webhooks. Webhooks are custom HTTP callback opterations that define automatic outgoing HTTP requests, triggered by [events]() that occur in the RESTable application. Each event carries a payload, which by default is used as the body of the outgoing HTTP request. The webhook can also define the HTTP method and custom headers that are used in the outgoing request. As an advanced feature, RESTable webhooks can even override the payload of the event, and define a custom request used for fetching the data to include as body of the ougoing request. For more information on how to work with webhooks, see the documentation for the RESTable.Admin.Webhook resource.","excerpt":"Webhooks Sometimes it's useful to make a web application send data to a remote computer, not only when the remote computer makes a request for it – for example using a GET request – but automatically when certain events occur on the server. We could,","tags":"","url":"/"},{"title":"Aggregator","text":"Aggregator The Aggregator resource is used to create custom aggregated datasets from potentially multiple requests to the web resources of a RESTable application. It accepts a request template as input – which is included as body of GET requests. It then parses the request template and makes internal API requests for all request literals contained in the template. Then the results from these API requests, which is either an object array (for GET requests) or an integer (for REPORT requests), are substituted for t he request literals in the request template. Finally the populated request template is returned as output and sent back to the client. Simple example For this example, we use the RESTable demo service. generate a dynamic object containing the results of a number of other internal requests. It's useful for generating reports of arbitrary format without sending multiple requests and stitching together the responses. The resource expects an object template to be given in GET requests. Using simple markup, the template can encode internal requests, that are then substituted for the values they return in the object structure. These internal requests are written as internal URI strings starting with (optionally) an HTTP method (if no method is given, GET is used), followed by a forward slash ('/') followed by a resource specifier or macro, conditions and so on. Non-URI values in the template are simply ignored and returned in the output as-is. Example","excerpt":"Aggregator The Aggregator resource is used to create custom aggregated datasets from potentially multiple requests to the web resources of a RESTable application. It accepts a request template as input – which is included as body of GET requests. It ","tags":"","url":"/"},{"title":"Echo","text":"Echo RESTable.Echo is a test and utility resource that simply returns the request URI conditions as an object, where conditions keys are property names, and condition values are property values. Example:","excerpt":"Echo RESTable.Echo is a test and utility resource that simply returns the request URI conditions as an object, where conditions keys are property names, and condition values are property values. Example:","tags":"","url":"/"},{"title":"AvailableResource","text":"AvailableResource AvailableResource is a meta-resource that contains the available resources for the current consumer. The entities contained in the output from a GET request to AvailableResource, and the values of their Methods properties, are decided by the API key used in the request (if keys are required for the service). It's the default resource for HTTP requests, used if no resource locator is provided in the request URI. Format Property name | Type | Description\n:------------ | :------------------ | :--------------------------------------------------------------------------------------------------------------------\nName | string | The name of the resource\nDescription | string | The description of the resource\nMethods | array of string | The methods available for the resource (for the current API key)\nKind | string | The kind of the resource, for example EntityResource\nViews | array of ViewInfo | The views of the resource (only for entity resources) Example","excerpt":"AvailableResource AvailableResource is a meta-resource that contains the available resources for the current consumer. The entities contained in the output from a GET request to AvailableResource, and the values of their Methods properties, are decid","tags":"","url":"/source"},{"title":"Help","text":"Help The Help resource contains merely a link to the Consuming a RESTable API section of this documentation. Example","excerpt":"Help The Help resource contains merely a link to the Consuming a RESTable API section of this documentation. Example","tags":"","url":"/"},{"title":"Console","text":"Console The Console resource records all network activity to and from the RESTable API of the given RESTable application. The data is transient, and the client can decide the level of detail in the data feed. Use Console when debugging connections from external applications. Properties The Console resource has the following properties: Property name | Type | Default value | Description\n--------------- | --------- | ------------- | ----------------------------------------------------------------------------------------\nFormat | enum | \"Line\" | The format of the output feed. Can be \"Line\" or \"JSON\"\nIncludeClient | boolean | true | Should the client be included in the output feed? Default is true\nIncludeHeaders | boolean | false | Should response headers be included in the output feed? Default is false\nIncludeContent | boolean | false | Should content (e.g. response bodies) be included in the output feed? Default is false\nStatus | string | \"PAUSED\" | The current status of the console, can be \"PAUSED\" or \"OPEN\"\nShowWelcomeText | boolean | true | Should the terminal print a welcome message on launch?","excerpt":"Console The Console resource records all network activity to and from the RESTable API of the given RESTable application. The data is transient, and the client can decide the level of detail in the data feed. Use Console when debugging connections fr","tags":"","url":"/le"},{"title":"Shell","text":"Shell The Shell resource is a terminal resource that makes it possible to work with a RESTable API over a command-line interface. When launched, the shell acts as a command-line interpreter for text commands sent as WebSocket text messages, and responds with data and status information. Using shell text commands, the client can navigate around the resources of the API, read, insert, update and/or delete entities, or enter other terminals. Properties Property name | Type | Default | Description\n---------------- | --------- | ---------- | --------------------------------------------------------------------------------------------------------------------------------------------------\nQuery | string | \"\" | Determines the current location of the shell, and the URI for subsequent requests\nUnsafe | boolean | false | Is the shell currently in unsafe mode? (see the unsafe meta-condition)\nWriteHeaders | boolean | false | Should the shell include headers when writing output?\nAutoOptions | boolean | false | Should the shell automatically send an OPTIONS command after each successful navigation?\nAutoGet | boolean | false | Should the shell automatically send an GET command after each successful navigation?\nStreamBufferSize | integer | 16000000 | The buffer size (message size) to use with WebSocket streaming\nProtocol | string | \"RESTable\" | The protocol to use in requests Shell text commands Shell text commands are strings of characters sent as text messages to the Shell terminal resource over a WebSocket connection, that trigger certain server-side operations. Each command invocation consists of the name of a command, for example GET or VAR, and – optionally – a space followed by a command argument. The semantics for the given argument differs between commands. When receiving text commands, the shell evaluates the command and returns a result. Finally, after each command evaluation, a message is sent back over the WebSocket with the current value of the Query property, e.g. ? /superhero. If a potentially unsafe operation is about to be performed, e.g. deletion of multiple entities, the client will be asked to confirm before the execution continues. The following text commands are available in the Shell resource: GO GET POST PATCH PUT DELETE REPORT HEAD STREAM OPTIONS NEXT HEADER VAR HELP CLOSE The GO command sets the Query property to argument text (excluding any whitespace), and validates the query as a RESTable URI. This is the primary way to navigate between resources using the shell. If the navigation was unsuccessful, e.g. due to some syntax error in the input text string, an error message is returned. Otherwise, if AutoOptions is set to true, an OPTIONS command is made for the new query. Otherwise, if AutoGet is set to true, a GET command is made for the new query. Executes a GET request with the value of the Query property as URI along with the headers defined for the shell. Any argument given is used as the body of the request (UTF8). On success, the content of the response body is sent back to the client along with the response status code and description. On fail, an error message is returned. If the body is larger than 16 megabytes, the client will be required to stream the result over multiple WebSocket messages. Executes a POST request with the value of the Query property as URI along with the headers defined for the shell. Any argument given is used as the body of the request (UTF8). On success, the content of the RESTable-info header is sent back to the client along with the status code and description. On fail, an error message is returned. Executes a PATCH request with the value of the Query property as URI along with the headers defined for the shell. Any argument given is used as the body of the request (UTF8). On success, the content of the RESTable-info header is sent back to the client along with the status code and description. On fail, an error message is returned. Executes a PUT request with the value of the Query property as URI along with the headers defined for the shell. Any argument given is used as the body of the request (UTF8). On success, the content of the RESTable-info header is sent back to the client along with the status code and description. On fail, an error message is returned. Executes a DELETE request with the value of the Query property as URI along with the headers defined for the shell. Any argument given is used as the body of the request (UTF8). On success, the content of the RESTable-info header is sent back to the client along with the status code and description. On fail, an error message is returned. Executes a REPORT request with the value of the Query property as URI along with the headers defined for the shell. Any argument given is used as the body of the request (UTF8). On success, the content of the body is sent back to the client along with the status code and description. On fail, an error message is returned. Executes a HEAD request with the value of the Query property as URI along with the headers defined for the shell. Any argument given is used as the body of the request (UTF8). On success, the status code and description of the response is sent back to the client. On fail, an error message is returned. Performs WebSocket streaming of the results of a GET command. The value of the StreamBufferSize property decides how many bytes are included in each WebSocket message. Returns the RESTable.AvailableResource entity corresponding to the resource selected by the current Query. Returns the next page in a paginated enumeration of entities. Note how the current Query is updated with an offset meta-condition after the completion of the NEXT command evaluation. If an integer is included as argument to NEXT, it's used to determine how many pages to return. Sets the value of a header to an assignent that is given as argument. Headers are included in all subsequent requests from the shell. Use this to, for example, change the value of the Accept header. After writing to the given header, all custom headers are returned. Sets the value of a property to an assignment that is given as argument. Use this as shorthand for the standard #TERMINAL global command. After writing to the given property, all properties are returned. Simply prints a link to this documentation. Closes the terminal, and the associated WebSocket. Command shorthands Use these command shorthands when you see fit: Binary data When receiving binary data from the WebSocket client, the shell executes a POST request with the value of the Query property as URI, the headers defined for the shell as headers and the binary data as body.","excerpt":"Shell The Shell resource is a terminal resource that makes it possible to work with a RESTable API over a command-line interface. When launched, the shell acts as a command-line interpreter for text commands sent as WebSocket text messages, and respo","tags":"","url":"/"},{"title":"SetOperations","text":"SetOperations The SetOperations resource gives access to powerful set operations that work with JSON object arrays as sets of objects and objects as sets of property-value pairs. It lets the client specify a JSON tree of operations and data sources, and then returns the output as a set of objects. Use SetOperations for requests that cannot be performed using regular request components like conditions and meta-conditions. There are four operations available: Union Returns the set union (all distinct elements) of two or more input sets. Intersect Returns all entities that are elements in all input sets (two or more). Except Returns all the entities from a first set that are not elements of a second set. Map Runs each entity of an input set through a mapping function, and returns the union of all outputs. SetOperations is designed to only work with GET requests, and operations are specified in the form of a JSON object tree that is included in the body of the request. This request body must conform to the following grammar (EBNF): The syntax of request URIs is defined here. See the examples below, for instances of the above grammar. A set of objects, unlike a list, cannot contain multiple objects with (1) the same number of properties, (2) the same property names and (3) the same values for the respective properties. These objects are considered duplicates and are dropped. All the request examples below work with our demo service, if you want to try things out yourself. Example 1: The request above will find all Superhero entities where the Gender property has the value \"Female\", and perform a set union with all Superhero entities that has the HasSecretIdentity property set to true. See the tutorial repository for the definition of the Superhero resource. Example 2 Set operations calls can be nested in input JSON object trees. Also note that the order of elements in operation argument arrays is important for the non-symmetric functions Except and Map. In this example, we take the output from the previous example, and then run a set except operation on it with all the Superhero entities where the YearIntroduced property is less than 1990. The resulting set is all female superheros together with all superheroes with a secret identity, but excluding all the ones that were introduced prior to 1990. Example 3 What we want to do now is to take all superhero names that begin with the letter D and collect all the years when such a superhero was introduced. We then want to take this list of years and compile a list of all female super heroes that were introduced these years. Lastly, we want to print the names of all those female superheroes in alphabetical order. OK, let's take that again – in steps:","excerpt":"SetOperations The SetOperations resource gives access to powerful set operations that work with JSON object arrays as sets of objects and objects as sets of property-value pairs. It lets the client specify a JSON tree of operations and data sources, ","tags":"","url":"/ns"},{"title":"DatabaseIndex","text":"DatabaseIndex The Starcounter in-memory database needs to have proper database indexes set up for queries to work as fast as possible. RESTable uses Starcounter SQL to query database tables, which means that indexes are as important as in other Starcounter applications. Should the administrator need to optimize any queries on large resources for speed – adding and index can greatly improve performance. Format Property name | Type | Description\n------------- | -------------------- | -----------------------------------------------------------\nName | string | A name for the index. Needs to be unique.\nResourceName | string | The name of the resource on which this index is registered.\nProvider | string (read-only) | The resource provider that registered this index.\nColumns | array of Column | The column tuple registered in this index. Column Format: Property name | Type | Description\n------------- | --------- | ------------------------------------------------------------------------\nName | string | The name of the column (property) to include in the index.\nDescending | boolean | Should this index be in decending order? Default is false (ascending). Indexes are registered for a resource on tuple of columns, corresponding with the properties of the resource. For each column, we can decide the direction of the index, which can affect the speed of some query result ordering. For more information about Starcounter database indexes, see the Starcounter documentation. Example This is an example from online advertising. A bid request is a trading opportunity where some online advertising inventory is made available for bidding from e.g. advertisers. These opportunities are pushed to a RESTable application, and made available for API consumers in a resource Mopedo.Database.BidRequest. It's a large resource, containing millions of entities. Now we would like to get the 100 latest bid requests every minute, to generate a live view of the current trading opportunities. In this live view we will, for example, display site domains and device information for recent bid requests. For this we would like to use the following GET request: By making a GET request to /databaseindex we can see that there is no index for the Time column in the Mopedo.Database.BidRequest resource. This means that these GET requests could greatly benefit from having a new index registered for this database column. To register an appropriate index, we use this request:","excerpt":"DatabaseIndex The Starcounter in-memory database needs to have proper database indexes set up for queries to work as fast as possible. RESTable uses Starcounter SQL to query database tables, which means that indexes are as important as in other Starc","tags":"","url":"/aseIndex"},{"title":"Error","text":"Error When the REST API aborts operations due to some error, information about the error is stored in the Error resource. Error entities contain information to help debug requests and resources, and are useful when encountering unknown errors. Erronous responses will contain a link to the corresponding Error entity in the ErrorInfo header for easy traceability. Format Property name | Type | Description\n------------- | ---------------------------- | --------------------------------------------------\nId | string | The ID of the Error\nTime | datetime | The date and time when the Error was encountered\nResourceName | string | The resource that threw the exception\nAction | string | The action that failed (e.g. the method GET)\nErrorCode | ErrorCode | The ErrorCode of the Error\nStackTrace | string | The stack trace of the encountered exception\nMessage | string | The message of the encountered exception\nUri | string | The uri of the request\nHeaders | string | The headers of the request\nBody | string | The body of the request Example Request: Response: Error lookup request: Error lookup response body: The StackTrace is useful to include in bug reports to developers. Also, note that the API key is hidden in the Headers property.","excerpt":"Error When the REST API aborts operations due to some error, information about the error is stored in the Error resource. Error entities contain information to help debug requests and resources, and are useful when encountering unknown errors. Errono","tags":"","url":"/"},{"title":"PropertyCache","text":"PropertyCache The PropertyCache resource contains all the types and properties discovered by RESTable while working with the resources of the current RESTable application. It's useful when debugging RESTable applications. Format Property name | Type | Description\n------------- | ----------------- | --------------------------------------------------------------\nType | string | The name of the type for which the properties have been cached\nProperties | array of object | The properties discovered for this type","excerpt":"PropertyCache The PropertyCache resource contains all the types and properties discovered by RESTable while working with the resources of the current RESTable application. It's useful when debugging RESTable applications. Format Property name | Type ","tags":"","url":"/rtyCache"},{"title":"ErrorCode","text":"ErrorCode The error codes used by RESTable have their own resource, which is useful for administrators wanting to check some error code that appears in Error entities. Example","excerpt":"ErrorCode The error codes used by RESTable have their own resource, which is useful for administrators wanting to check some error code that appears in Error entities. Example","tags":"","url":"/Code"},{"title":"Protocol","text":"Protocol The Protocol resource lists all protocol providers that have been added to the current RESTable application, as well as their respective available input and output content types. The RESTable protocol is always enabled, but others – such as OData – can be added by the developer. See this section of the documentation for more information on how to add custom protocol providers. Format Property name | Type | Description\n------------- | -------------------------- | --------------------------------------------\nName | string | The name of the protocol\nIdentifier | string | A unique identifier for the protocol\nIsDefault | boolean | Is this the default protocol?\nContentTypes | array of ContentTypeInfo | The content types supported in this protocol ContentTypeInfo ContentTypeInfo objects describe content types that are available for some protocol in a RESTable application. Property name | Type | Description\n------------- | ----------------- | -----------------------------------------------------------------------------------\nName | string | The name of the content type\nMimeType | string | The MIME type string of the content type\nCanRead | boolean | Can the given protocol read from requests using this content type?\nCanWrite | boolean | Can the given protocol write to responses using this content type?\nBindings | array of string | The available header values that can be used to bind a request to this content type Example","excerpt":"Protocol The Protocol resource lists all protocol providers that have been added to the current RESTable application, as well as their respective available input and output content types. The RESTable protocol is always enabled, but others – such as ","tags":"","url":"/col"},{"title":"Schema","text":"Schema The Schema resource lets you print the schema for another resource. The schema contains names for all properties and types (C# namespaces and names) for the types used. Example","excerpt":"Schema The Schema resource lets you print the schema for another resource. The schema contains names for all properties and types (C# namespaces and names) for the types used. Example","tags":"","url":"/a"},{"title":"Resource","text":"Resource Resource is a meta-resource that contains entities that correspond to the resources currently registered in the REST API. All resources have a Resource entity describing it. Format Property name | Type | Description\n-------------- | ------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------\nName | string (read-only) | The name of the resource\nAlias | string | The alias of the resource, if any\nDescription | string (read-only) | The description of the resource\nEnabledMethods | array of Method (read-only) | The methods that are enabled for the resource\nEditable | boolean (read-only) | Is this resource editable?\nIsInternal | boolean (read-only) | Is this resource only available internally?\nType | string (read-only) | The .NET type registered for this resource\nViews | array of ViewInfo(read-only) | The views registered for this resource\nProvider | string (read-only) | The name of the ResourceProvider that generated this resource\nKind | ResourceKind (read-only) | The kind of the resource, for example EntityResource\nInnerResources | array if Resource (read-only) | Resources declared within the scope of this resource To get all resources currently registered by the server: To list all resource names only: Adding resources Resources can be added during runtime by calling any procedural resource controller, for example the built-in RESTable.Dynamic.Resource resource.","excerpt":"Resource Resource is a meta-resource that contains entities that correspond to the resources currently registered in the REST API. All resources have a Resource entity describing it. Format Property name | Type | Description\n-------------- | --------","tags":"","url":"/rce"},{"title":"Utilities","text":"Utilities The Utilities is a terminal resource that can trigger operations useful for administrators. Currently, the only available option in the resource is ReloadConfigFile, which reloads the configuration file and loads API keys and allowed CORS origins.","excerpt":"Utilities The Utilities is a terminal resource that can trigger operations useful for administrators. Currently, the only available option in the resource is ReloadConfigFile, which reloads the configuration file and loads API keys and allowed CORS o","tags":"","url":"/ties"},{"title":"Settings","text":"Settings The Settings resource gives access to the settings of the REST API itself. We can, for example, see the URI of the REST API, or change whether output JSON should be serialized with pretty printing or not. Format Property name | Type | Description\n---------------- | ------------- | -----------------------------------------------------------------------------\nPort | integer | The port of the RESTable REST API\nUri | string | The URI of the RESTable REST API\nPrettyPrint | boolean | Will JSON be serialized with pretty print? (indented JSON)\nLineEndings | LineEndings | The line endings to use when writing JSON\nResourcesPath | string | The path where resources are available\nDocumentationURL | string | The URL of the RESTable documentation\nDaysToSaveErrors | integer | The number of days to store errors in the RESTable.Error resource","excerpt":"Settings The Settings resource gives access to the settings of the REST API itself. We can, for example, see the URI of the REST API, or change whether output JSON should be serialized with pretty printing or not. Format Property name | Type | Descri","tags":"","url":"/ngs"},{"title":"WebSocket","text":"WebSocket The WebSocket resource contains all WebSockets currently connected to the RESTable application. The administator can close connected WebSockets by simply running DELETE on their corresponding object in this resource. Format Property name | Type | Description\n------------- | --------- | -----------------------------------------------------------------------------------\nId | string | The unique ID for the connection\nTerminalType | string | The name of the terminal resource type that the WebSocket is currently connected to\nTerminal | object | An object describing the current state of the terminal\nClient | object | An object describing the client connected to the terminal\nIsThis | boolean | Is this WebSocket the same as the one currently requesting the resource?","excerpt":"WebSocket The WebSocket resource contains all WebSockets currently connected to the RESTable application. The administator can close connected WebSockets by simply running DELETE on their corresponding object in this resource. Format Property name | ","tags":"","url":"/cket"},{"title":"TermCache","text":"TermCache RESTable caches the terms (parsed property locators) used in conditions and meta-conditions to speed up request handling. As an advanced administration feature, the TermCache can be used to control and debug this cache. Format: Property name | Type | Description\n------------- | ----------------- | -------------------------------------\nType | string | The type on which the terms is cached\nTerms | array of string | The terms cached for the type","excerpt":"TermCache RESTable caches the terms (parsed property locators) used in conditions and meta-conditions to speed up request handling. As an advanced administration feature, the TermCache can be used to control and debug this cache. Format: Property nam","tags":"","url":"/ache"},{"title":"Conditions","text":"Conditions Conditions are made up of three parts: a property locator, an operator and a value literal. They encode predicates that are either true or false of entities in the selected resource. Property locators A property locator is a string used to locate a property in a resource entity. Dot notation is used to access the contents of inner objects. If entities in a resource User contain ids, names, accounts and email addresses, and accounts contain account numbers, we can imagine using the following property locators in requests. Property locators are case-insensitive. Examples: Operators The REST API supports the following six operators in conditions: Equals: the two values are the same Not equals: the two values are different Less than: the two values are numbers or datetimes and the first is less than the second, or the two values are strings and the first is alphabetically sorted ahead of the second Greater than: the two values are numbers or datetimes and the first is greater than the second, or the two values are strings and the second is alphabetically sorted ahead of the first Less than or equals: the two values are numbers or datetimes, and the first // is less than or equal to the second, or the two values are strings and the // first is aphabetically sorted equally to or ahead of the second Greater than or equals: the two values are numbers or datetimes and the // first is greater than or equal to the second, or the two values are strings // and the second is alphabetically sorted equally to or ahead of the first Value literal The value literal is a string that encodes some value. RESTable will parse value literals and find the correct data type for the value. An error message is then returned if there is a type mismatch against the resource property specified by the property locator. To force the value literal to be handled as a string, when it would otherwise be understood as, for example, a number – wrap it in quotation marks. For example, 123 would be parsed as an integer. If we want to encode the string \"123\" in a value literal, we can surround the literal with \"-characters or '-characters in the URI. Apart from the usual convention regarding URI-safe characters, the following characters are reserved by RESTable, and always need to be escaped if used in value literals: Character | Use instead\n--------- | -----------\n! | %21 Always URI encode value literal that contain special characters Value literals are case-sensitive. Examples","excerpt":"Conditions Conditions are made up of three parts: a property locator, an operator and a value literal. They encode predicates that are either true or false of entities in the selected resource. Property locators A property locator is a string used to","tags":"","url":"/"},{"title":"Meta-conditions","text":"Meta-conditions With meta-conditions, we can include meta-information about the request in the URI, and instruct the server to perform certain operations when handling the request. Meta-conditions consist of three parts: a meta-condition name, an equals sign (\"=\"), and a meta-condition value of a predefined type. Meta-condition value literals, like all value literals, are case-sensitive, except when they are property locators – then they are case-insensitive. These are the meta-condition keys: The subsections below go through each of these in more detail: unsafe Type: boolean By default, the REST API protects against unsafe requests that could result in performance issues or serious accidental data loss or corruption if triggered by mistake. Example of such requests could be: This was previously considered an unsafe operation, but is no longer since the WebSocket shell, which has its own streaming mechanism to guard against this, is the new preferred way to debug and test RESTable applications. PATCH requests that modify multiple entities. If the wrong conditions are used when trying to update a single entity, and the server instead changes many entities, unwanted data loss or corruption could occur. DELETE requests that delete many entities, when just one entity was supposed to be deleted. To prevent this, the API uses a meta-condition unsafe to let the consumer confirm all such potentially dangerous requests. For update and delete requests, RESTable will send a 400: Bad request response whenever multiple entities would be affected by a request and unsafe was not set to true. limit Type: integer limit puts an upper limit on the number of entities selected by a request. offset Type: integer Offsets are used to offset the enumeration of the output entities from a GET request. RESTable pagination is defined in terms of limit and offset. order_asc Type: string order_asc orders the output entities in ascending order based on the value of some given property. The value is a property locator that selects the property to order by. order_desc Type: string order_desc works like order_asc but applies a descending ordering. select Type: string select takes a comma-separated list of property locators as arguments, and filters the output so that only the specified properties are included. add Type: string The add meta-condition takes a list of property locators as argument, and adds the denoted properties to the output. rename Type: string The rename meta-condition instructs the server to give certain properties of entities in output new names. rename takes a comma-separated list of strings, where each string has the following syntax (EBNF): property-locator refers to the property in the resource that should be renamed. new-name is simply a case sensitive string – the new name for the property. select and rename can be used in the same request, in which case rename is always evaluated before select. See the request evaluation order for more information. distinct Type: boolean If distinct is set to true in a request, only distinct objects will be included in the output. This operation is performed after add, rename and select, so object properties added or renamed will be taken into account. search Type: string search applies a search filter on a representation of the output, and returns only entities that included the search pattern. There are two search settings that can be included along with the search pattern, to control case sensitivity as well as to limit the search scope to the values of a given entity property. The syntax for this is the following (EBNF): Search settings are optional. If no property scope is included, the whole entity is searched. If no case sensitivity setting is included, the search is case insensitive. search_regex Type: string search_regex applies a regular expression string search filter on a representation of the output, and returns only entities that matched the search pattern. In the example below, we match only against customers with a name beginning with s and ending with l (case insensitive). Before URI encoding, the regex pattern looked like this: ^s.*l$. See this section for how to include search settings. safepost Type: string safepost is used to trigger a special type of POST request, where the input is matched against existing entities to avoid duplicates. Think of a safepost request as a series of repeated PUT requests, where all entities in the data source are matched against existing entities, and inserted only if there is no existing entity to update. As parameter, safepost takes a comma-separated list of property locators, and returns an aggregated response containing the number of inserted and updated entities. The data source can, just as in regular POST requests, be contained in the request body or specified as an external source using the Source header. safepost is also an important feature when using the Destination header. The above request is equivalent to running both of the two requests below: format Type: string The administrator will enable a set of output formats that should be enabled when serializing JSON output. The format meta-condition is used to set the output format for JSON serialization of GET response bodies on a per-request basis. The value should be a name of an output format (case insensitive).","excerpt":"Meta-conditions With meta-conditions, we can include meta-information about the request in the URI, and instruct the server to perform certain operations when handling the request. Meta-conditions consist of three parts: a meta-condition name, an equ","tags":"","url":"/tions"},{"title":"Additional operations","text":"Additional operations RESTable has built in mechanisms to handle validation of resource entities and resource-specific authorization, available to the developer by having the resource type implement the IValidatable and IAuthenticatable interfaces respectively. Entity resource validation using IValidatable The IValidatable interface has one method, IsValid(), that RESTable calls for all resources implementing IValidatable before running operations Insert and Update. If the entity resource has some validation logic that needs to be run on all entities before insertion or updating – IValidatable provides a simple way to handle invalid entities and show proper error messages to the client. Unlike the operations interfaces and IAuthenticatable below, IsValid() is not run from a static context, so references can be made to instance members. Resource-specific authentication using IAuthenticatable Sometimes it's useful to have a separate means of authentication and authorization for a given resource. RESTable API keys are appropriate for controlling access to the REST API and different resources, but should not be used for more specific authentication and authorization - for example handling user accounts that control access to some resource. IAuthenticatable is a simple interface that enables the developer to define authentication and authorization logic that is executed whenever an external REST request is made to a resource. The best way to pass authentication information to a resource is by including it in custom headers, that are then read in the Authenticate() method. These custom headers are never logged by RESTable.","excerpt":"Additional operations RESTable has built in mechanisms to handle validation of resource entities and resource-specific authorization, available to the developer by having the resource type implement the IValidatable and IAuthenticatable interfaces re","tags":"","url":"/ces/Additional%20operations"},{"title":"Resource","text":"Resource Resources can be specified in the URI either by the fully qualified name, a part of the full name or by an assignable alias. The full name is always unique for each resource. The resource Mopedo.Bidding.Campaign can be referenced with only \"Campaign\" as long as no other resource name ends with \".Campaign\" or an alias \"Campaign\" is assigned to some other resource. To find all available resources' names for a RESTable appplication, make the following GET request: Views Views are optional components of resources, that lets the consumer access different representations of the same resource. A GET request to an Employee resource will, for example, return representations of all Employee entities in the resource. But if a common use case for the resource is to get the ten employees with the highest sales scores and order them by sales score, the developer can choose to implement this as a separate view, making it easier to do this query. The consumer can see what views are available for some resource by making a GET request to the AvailableResource resource. Views are specified in the URI by adding a dash (\"-\") and the view name directly after the resource specifier, for example: https://my-server.com/rest/employee-best. When writing URIs, all conditions that are available for the resource, is also available for the view. The view may also define new properties that can be used only in conditions for that view. Macros Macros are pre-defined syntactic templates for requests that enable advanced use cases, for example integration with clients that cannot send certain REST requests. To call a macro, place the macro name, preceded by a $-character, in place of the resource specifier in the URI. For more information, see how to administer macros.","excerpt":"Resource Resources can be specified in the URI either by the fully qualified name, a part of the full name or by an assignable alias. The full name is always unique for each resource. The resource Mopedo.Bidding.Campaign can be referenced with only \"","tags":"","url":"/"},{"title":"Notes on Excel","text":"Notes on Excel Excel representations of entity resources differ from JSON representations in one important regard – the inability to encode inner entities in-line with other properties. RESTable has various ways of dealing with this limitation. When clients make GET requests to entity resources that have inner objects, and ask the server to use Excel as the representation format, RESTable will automatically reduce the inner object using their ToString() method, if no other reduce function is supplied in the entity resource definition. You can specify a custom Excel reduce function for an entity resource property by defining a method in the entity resource's definition and providing the name of that method in the excelReducer parameter of the RESTableMemberAttribute constructor for that property. Example using excelReducer: Sample Excel output from MyResource: AString | AnInt | AnObject\n------------------- | ----- | -------------------------------\nA fine string value | 42 | Name: Objecty McObject, Id: ABC","excerpt":"Notes on Excel Excel representations of entity resources differ from JSON representations in one important regard – the inability to encode inner entities in-line with other properties. RESTable has various ways of dealing with this limitation. When ","tags":"","url":"/ces/Notes%20on%20Excel"},{"title":"Examples","text":"Examples Regular Starcounter database resource This entity resource is a Starcounter database class, and has all its operations defined by RESTable. All we need to do to register it as a resource is to decorate it with the RESTableAttribute attribute. Then we can make request like these: Custom entity resource This entity resource is not a Starcounter database class, or more generally – it's not decorated by any resource provider attribute. This means that we have to define the operations required by the enabled methods using the operations interfaces. For this example, let's consider an entity resource that works as an interface for MyStarcounterResource. See working with requests and conditions for more about how to design the individual operations.","excerpt":"Examples Regular Starcounter database resource This entity resource is a Starcounter database class, and has all its operations defined by RESTable. All we need to do to register it as a resource is to decorate it with the RESTableAttribute attribute","tags":"","url":"/ces/Examples"},{"title":"Introduction","text":"Building entity resources Entity resources are resources modelled as sets of entities, where each entity has a set of properties consisting of a key and a value. By using REST and operations like GET, POST and DELETE, we can manipulate the contents of entity resources and get representations of them, for example in JSON. Registering entity resources Entity resources – like all RESTable resources – are .NET classes, and the entities themselves are, not surprisingly, instances of these classes. There are two ways to register a class as an entity resource in RESTable: The easiest way to make an existing class, for example a Starcounter database class, work as a RESTable resource is to simply decorate it with the RESTableAttribute attribute and assign the REST methods we want to make available as parameters to its constructor. The resource is then registered when the application calls [RESTableConfig.Init()]() is called, and made available for REST requests. Sometimes, however, we cannot make code changes in the definition of the class we want to use as a resource, or we do not want a dependency from that assembly to RESTable. In those cases, we can register resources by subclassing the abstract generic ResourceWrapper class. Here the HR_EmployeeContact class is registered as a RESTable resource. It's the HR_EmployeeContact class that will define the members of the resource, for example. The name, namespace and operations of the resource, however, is taken from the wrapper class, in this case Employee. RESTable always require operation definitions for the methods provided in the RESTableAttribute constructor. These operations are used to, for example, select existing entities in the resource and insert new ones. There are two ways to assign operations to a RESTable resource. By assigning a resource provider attribute to its resource declaration, and letting the resource provider assign its default operations. This is what we do in the examples above, since the DatabaseAttribute attribute is a resource provider attribute in RESTable. When we combine the DatabaseAttribute and RESTableAttribute in a resource declaration, we assign the default operation implementations for Starcounter database types to the resource. By creating a custom operation implementation by having the .NET class implement one or more operations interfaces. This is how we override the operations defined by a resource provider, or define operations if the resource has no resource provider attribute. There are five operations that are used by RESTable when evaluating requests. These should not be confused with the REST methods. RESTable use these operations to implement the semantics of REST methods. When executing RESTableConfig.Init(), RESTable will check so that all operations needed for the methods provided in the RESTableAttribute constructor are defined. If not, it will throw a runtime exception. Used in GET, PATCH, PUT and DELETE. Select gets a set of entities from a data storage backend that satisfy certain conditions provided in the request, and returns them. Used in POST and PUT. Takes a set of entities and inserts them into the data storage backend, and returns the number of entities successfully inserted. Used in PATCH and PUT. Takes a set of entities and updates their corresponding entities in the data storage backend, and returns the number of entities successfully updated. Used in DELETE. Takes a set of entities and deletes them from the data storage backend, and returns the number of entities successfully deleted. Used in REPORT requests. Selects and counts entities in the storage backend. If no Count operation is implemented for a resource, RESTable will simply call Select and count the entities in the returned IEnumerable. Note: when implementing Count, we need to take the Distinct meta-condition into account. RESTable references the operation definitions from the interface implementations using delegates, and all calls to them are from a static context – meaning that the this reference technically available from the instance methods defined by the interfaces above will always be null. Always treat operations interface method implementations as static methods when defining operations.","excerpt":"Building entity resources Entity resources are resources modelled as sets of entities, where each entity has a set of properties consisting of a key and a value. By using REST and operations like GET, POST and DELETE, we can manipulate the contents o","tags":"","url":"/ces/Introduction"},{"title":"Working with requests and conditions","text":"Working with requests and conditions This article does not exist yet! Please check back soon","excerpt":"Working with requests and conditions This article does not exist yet! Please check back soon","tags":"","url":"/ces/Working%20with%20requests%20and%20conditions"},{"title":"Resource providers","text":"Resource providers As we have seen in these articles, the concept of an entity resource is general enough to encompass all kinds of data structures, as long as they can represent themselves as sets of entities. A MySQL database table, for example, can be used as a RESTable entity resource, and interacted with using the same kinds of requests as native Starcounter tables. All we need to do to make that work is to register a resource like this: This works well, but it puts a lot of responsibility on the developer designing the entity resource. A better way to create a RESTable integration with some data technology, for example MySQL, is to create a resource provider for it, that defines the default operations for interaction with MySQL databases. This way, we can have a simple and organized way for developers to add MySQL database tables to their RESTable applications, without them defining Select, Insert, Update and Delete methods for each of these resources. Instead, developers can declare MySQL resources like this: All resource providers have a resource provider attribute that is used to label the class definitions that should be claimed by the resource provider. In the example above, our MySQL resource provider has a MySQLAttribute attribute type that is used in MySQL resource declarations. This syntax should be familiar to you if you have seen how Starcounter resources are registered. The Starcounter.DatabaseAttribute is, in fact, a RESTable resource provider attribute, that binds a resource to the default operations for Starcounter database classes. By default, RESTable contains the following resource providers: So classes that are not Starcounter database tables need to either define their own operations, or be bound to some custom resource provider. See also: RESTable.SQLite – an SQLite resource provider Building a custom resource provider To implement a custom resource provider, create a new class that inherits from RESTable.ResourceProvider where T is an optional shared base class for all resource types provided by the resource provider. If there is no such base class, simply make your class ResourceProvider. Then define a class inheriting from System.Attribute, to use as resource provider attribute. When executing RESTableConfig.Init(), RESTable will find all entity resource declarations that are decorated with the resource provider attribute, and use your resource provider to register operations for them. You can also specify a DatabaseIndexer sub-class to use when indexing your resources (if indexing is applicable to the technology you are building support for). To use a resource provider in a RESTable application, include an instance of it in the call to RESTableConfig.Init(). See the open-source RESTable.SQLite resource provider for an example. Feel free to contact develop@mopedo.com if you need help creating a resource provider for some technology.","excerpt":"Resource providers As we have seen in these articles, the concept of an entity resource is general enough to encompass all kinds of data structures, as long as they can represent themselves as sets of entities. A MySQL database table, for example, ca","tags":"","url":"/ces/Resource%20providers"},{"title":"Resource","text":"RESTable.Dynamic.Resource The RESTable.Dynamic namespace contains all the procedurally generated resources that have been created for the current RESTable application. By default, the namespace contains a single resource, RESTable.Dynamic.Resource, a meta-resource that is used to create additional resources in the namespace. For an overview of dynamic resources, see this section. RESTable.Dynamic.Resource is a meta-resource that contains entities representing all procedurally created resources (runtime resources) for the current RESTable application. Each entity in the resource corresponds with a dynamic Starcounter table created using the Dynamit library. Format The format of RESTable.Dynamic.Resource is the same as for RESTable.Admin.Resource","excerpt":"RESTable.Dynamic.Resource The RESTable.Dynamic namespace contains all the procedurally generated resources that have been created for the current RESTable application. By default, the namespace contains a single resource, RESTable.Dynamic.Resource, a","tags":"","url":"/"}]